\subsection{调试}

调试是软件开发的关键部分，通常被认为是最耗时且最昂贵的过程。
调试使软件开发人员能够创建满足高性能、低功耗和可靠性三大关键标准的应用程序、中间件和平台软件。
然而，Bug 可能很难检测、重现和修复，同时也难以预测解决缺陷所需的时间。
产品交付给客户后，解决问题的成本显著增加。
在许多情况下，如果产品有一个很短的销售时间窗口，产品延期可能会错过市场机会。
因此，系统提供的调试功能对于任何开发人员来说都是一个重要的考虑因素。

许多使用 ARM 处理器的嵌入式系统具有有限的输入 / 输出设施，这意味着传统的桌面调试方法（例如使用 printf()）可能不适用。
在过去的这种系统中，开发人员可能使用昂贵的硬件工具，如逻辑分析仪或示波器来观察程序的行为。
本书描述的处理器是包含内存、缓存和许多其他模块的复杂片上系统（SoC）的一部分。
可能没有可见的处理器信号暴露在芯片外，因此无法通过连接逻辑分析仪（或类似设备）来监控行为。
基于这个原因，ARM 系统通常包括专门的硬件，以提供广泛的控制和观察功能进行调试。

外部调试功能最早在 ARMv4 架构处理器上引入，以支持使用嵌入式和深度嵌入式处理器的开发人员，并已演变成广泛的调试和跟踪功能组合。
支持丰富的应用软件平台，特别是自托管调试和性能分析，是在 ARMv6 和 ARMv7-A 架构中最近添加的功能。

ARMv8 处理器提供的硬件功能使调试工具能够显著控制核心活动，并非侵入性地收集大量关于程序执行的数据。
硬件功能大致分为两类：侵入性和非侵入性。

\subsubsection{ARM 硬件调试}

侵入式调试提供了使您能够停止程序并逐行执行它们的功能，既可以在 C 源代码级别，也可以逐步执行汇编语言指令。
这可以通过使用芯片 JTAG 引脚连接到核心的外部设备，或者通过调试监控代码来实现。

\begin{Tcbox}[title={注意}]
  JTAG 代表联合测试行动小组（Joint Test Action Group），指的是 IEEE-1149.1 规范，最初设计用于标准化电子设备在电路板上的测试，但现在广泛用于核心调试连接。
\end{Tcbox}

\paragraph*{概述}

调试器提供了控制程序执行的能力，使您能够运行代码到某个点，停止核心，逐步执行代码，并恢复执行。
您可以在特定指令上设置断点，当核心达到该指令时，调试器将接管执行。
这些断点使用两种不同的方法。
软件断点通过将指令替换为 HLT 或 BRK 指令的操作码来工作。

HLT 指令会在外部调试器连接且相关安全权限允许进入调试状态时，使核心进入调试状态。
在 AArch64 中，BRK 指令生成同步调试异常，但不会使核心进入调试状态。
有关调试状态的更多信息，请参见页面 18 - 4 上的调试事件。

显然，这些只能用于存储在 RAM 中的代码，但它们的优点是可以大量使用。
调试软件必须跟踪它放置软件断点的位置以及这些地址原始位置的操作码，以便在您想要执行断点指令时可以将正确的代码放回。
硬件断点使用内核内置的比较器，在执行到达指定地址时停止执行。
由于这些不需要对代码进行更改，因此可以在内存的任何地方使用，但硬件提供的硬件断点单元数量有限。

调试工具可以支持更复杂的断点，例如，在地址范围内停止任何指令，或仅当发生特定事件序列或硬件处于特定状态时才停止。
数据监视点在读取或写入特定数据地址或地址范围时使调试器控制。
这些也可以称为数据断点。
例如，Cortex-A57 处理器在硬件资源中具有六个硬件断点和四个监视点。
要获取给定实现的这些值，请参阅调试 ID 寄存器（DBGDIDR）。

单步执行指的是调试器逐个指令地移动代码。
Step-In 和 Step-Over 之间的区别可以通过参考函数调用来解释。
如果您在 Step-Over 函数调用上，则整个函数将作为一个步骤执行，使您能够在不需要逐步执行的函数之后继续执行。
Step-In 意味着您将逐步执行函数。

在命中断点或进行单步执行时，您可以检查和更改 ARM 寄存器和内存的内容。
更改内存的特殊情况是代码下载。
调试工具通常使您能够更改代码，重新编译，然后将新图像下载到系统中。

\paragraph*{暂停（Halting）和自托管调试}

入侵式调试可以分为暂停调试（也称为外部调试）和监控调试（也称为自主托管调试）。
在任一情况下，核心的调试逻辑会响应某些情况（例如命中断点）生成调试事件。
区分监控调试和暂停调试的是对该调试事件的处理方式。

在暂停调试中，调试事件会导致核心进入调试状态。
在调试状态下，核心被停止，意味着它不再获取指令。
相反，核心在通过 JTAG 连接的不同主机上运行的调试器的指导下执行指令，或者通过其他外部接口执行指令。

在监控调试中，调试事件会引发调试异常。
该异常必须由同一核心上运行的专用调试监视器软件处理。
监控调试需要软件支持。

\paragraph*{调试事件}

处理器的调试逻辑负责生成调试事件。
调试事件是正在调试的过程中导致系统通知调试器的某个部分。
调试事件包括诸如断点单元将指令地址与其寄存器中存储的地址进行匹配等事件。
它们可以是同步的或异步的。
断点、BRK 和 HLT 指令以及监视点都是同步调试事件。
处理器将调试事件转换为以下几种操作之一：

\begin{itemize}
\item
  调试异常。
  调试异常是自主托管调试模型的基础。
\item
  进入特殊的调试状态。
  调试状态是外部调试模型的基础。
\item
  忽略调试事件。
\item
  将调试事件挂起，并稍后将其转换为操作。
\item
  进入两种调试模式之一，具体取决于外部调试状态和控制寄存器（EDSCR）的设置：

  \begin{enumerate}
  \item
    监控调试模式。
  \item
    停止调试模式。
  \end{enumerate}
\end{itemize}

调试事件转换为异常或进入调试状态取决于调试逻辑的配置和调试事件的类型。
例如，某些调试事件永远不会导致进入调试状态，而另一些永远不会引发调试异常。
调试事件永远不会同时转换为调试异常和进入调试状态。

有时，尽管调试逻辑的配置允许，处理器也无法将调试事件转换为这些操作之一。
这是因为这样做会违反处理器的安全模型。
如果处理器处于安全状态，并且连接到其上的外部调试器不受信任，则处理器不允许进入调试状态。

\subparagraph*{软件调试事件}

软件调试事件包括：

\begin{itemize}
  \item 断点调试事件
  \item 监控点调试事件
  \item 软件单步调试事件
  \item 软件断点指令调试事件
  \item 向量捕获调试事件
\end{itemize}

除了下面描述的外部调试中使用断点和监视点的情况外，断点和监视点调试事件还有以下特点：

\begin{itemize}
\item
  如果为当前安全状态和异常级别启用了调试异常，它们会向调试异常目标异常级别生成调试异常。
\item
  只有在启用调试异常时，才会生成软件单步调试事件。
\item
  软件断点指令调试事件总是生成调试异常。
\end{itemize}

\subparagraph*{断点调试事件}

地址断点通过将系统寄存器中的值与指令地址进行比较来生成调试事件。

一些断点是上下文感知的，可以编程为与上下文 ID 或（在非安全状态下）虚拟机标识符（VMID）的值进行比较的上下文断点。

断点可以编程为仅在特定模式、异常级别和安全状态下匹配。
地址断点可以与上下文断点相关联。

处理器中的断点数量是实现定义的。

\subparagraph*{数据监视点调试事件}

地址监视点通过将系统寄存器中的值与由加载和存储指令生成的数据地址进行比较来生成调试事件。

监视点可以编程为仅在特定模式、异常级别和安全状态下匹配。
地址监视点可以与上下文断点相关联。

监视点还可以编程为匹配访问类型；
也就是说，仅匹配加载、仅匹配存储，或者匹配加载和存储。
监视点不会匹配指令提取。

处理器中的监视点数量由实现定义。

\subparagraph*{软件单步调试事件}

软件单步调试事件用于逐步执行一条指令，即执行单个指令，然后将控制返回给调试器。
要逐步执行一条指令：

\begin{enumerate}
\item
  调试器软件启用软件单步。
\item
  调试器软件将程序计数器设置为要执行的指令。
\item
  处理器执行该单个指令。
\item
  下一条指令上会发生软件单步异常。
\end{enumerate}

但是，当执行指令时可能会生成另一个同步异常。

\subparagraph*{软件断点指令调试事件}

A64 指令集定义了一个软件断点指令。

\lstinline!BRK #<immediate>!

A32 和 T32 指令集定义了软件断点指令。

\lstinline!BKPT #<immediate>!

软件断点指令生成无法屏蔽的同步调试异常。

\subparagraph*{向量捕获调试事件}

向量捕获调试事件仅在 AArch32 阶段 1 转换模式下生成，并且仅生成调试异常。
向量捕获异常仅从 AArch32 状态生成。

\paragraph*{外部调试}

复杂系统在使用任何标准接口进行调试之前，需要其大部分硬件和软件功能正常运行。
在不依赖于正在调试的系统的情况下进行调试非常重要。
为此，您需要可靠的外部调试，即硬件辅助的运行控制调试和跟踪功能。
所有这些都可以在不需要在平台上运行软件的情况下进行控制，但通常在产品设计周期的早期阶段就需要这样做。

自托管工具通常需要多层软件支持，这使得调试软件的某些部分变得困难，或者使得调试对于诊断某些类型的错误过于侵入性。
低成本的外部调试接口，例如串行线调试（SWD），也有助于扩展外部调试适用范围。
有关更多信息，请参阅第~\ref{sec:CoreSight} 章节的 CoreSight。

\paragraph*{停止调试模式}

在停止调试模式下，调试事件会导致核心进入调试状态。
核心被停止，并与系统的其余部分隔离。
这意味着调试器显示的是核心所见的内存，并且内存管理和缓存操作的效果变得可见。
在调试状态下，核心停止执行来自程序计数器指示的位置的指令，而是通过外部调试接口进行控制。
这使得外部代理，例如调试器，可以询问核心上下文并控制所有后续指令执行。
核心和系统状态都可以修改。
由于核心被停止，直到调试器重新启动执行之前，不会处理任何中断。
停止调试的基本原则与 ARMv7-A 时代的原则保持不变：

\begin{itemize}
\item
  当调试事件被设置为停止调试时，会导致进入特殊的调试状态。
\item
  在调试状态下，核心不会从内存中获取指令，而是从特殊的指令传输寄存器获取。
\item
  数据传输寄存器用于在主机和目标之间移动寄存器和内存内容。
\end{itemize}

外部调试器的一个重要特征是它是同时运行的，并且（可能）独立于正在调试的进程或处理器运行，调试必须在设备复位后可能发生。
因此，ARMv8-A 中外部调试器还使用外部认证接口。

\paragraph*{自托管调试}

我们已经看到了 ARM 架构提供的广泛功能，可以供外部调试器访问。
许多这些设施也可以被运行在核心上的软件所使用，这些软件是驻留在目标系统上的调试监视器。
监视系统可能成本较低，因为它们可能不需要任何额外的硬件。
但是，它们会占用系统中的内存空间，并且只能在目标系统实际运行时使用。
在至少不能正确启动的系统上，它们的价值不大。

为了帮助开发人员创建应用程序，平台需要开发工具，这些工具通常至少部分运行在应用处理器本身上，而不需要昂贵的接口硬件来连接第二个主机计算机。
ARMv8-A 架构对这种自托管形式的调试提供了更完善的架构支持。
在现有的桌面平台上，自托管是软件开发的主要方法。

\paragraph*{调试 Linux 应用程序}

Linux 是一个多任务操作系统，其中每个进程都有自己的进程地址空间，包含私有的转换表映射。
这可能会使某些问题的调试变得相当棘手。

广义上讲，在 Linux 系统中有两种不同的调试方法。

Linux 应用程序通常使用运行在目标设备上的 GDB 调试服务器进行调试，通过以太网与主机计算机进行通信。
调试会话进行时，内核会继续正常运行。
这种调试方法不提供对内置硬件调试设施的访问。
目标系统始终处于运行状态。
服务器接收来自主机调试器的连接请求，然后接收命令并向主机提供数据。

主机调试器向 GDB 服务器发送加载请求，服务器响应并启动一个新进程来运行正在调试的应用程序。
在执行开始之前，它使用系统调用 ptrace() 来控制应用程序进程。
该进程的所有信号都将转发到 GDB 服务器。
而发送给应用程序的信号则转发到可以处理该信号的 GDB 服务器或转发到正在调试的应用程序。

要设置断点，GDB 服务器在代码中所需的位置插入生成 SIGTRAP 信号的代码。
当执行到此代码时，将调用 GDB 服务器，然后可以执行经典的调试器任务，如检查调用堆栈信息、变量或寄存器内容。

\paragraph*{调试 Linux 内核}

用于内核调试的是基于 JTAG 的调试器。
当执行断点时，系统会停止运行。
这是检查问题的最简单方法，例如设备驱动程序加载、操作不正确或内核启动失败。
另一种常见方法是通过 printk() 函数调用。
strace 工具显示有关用户系统调用的信息。

Kgdb 是 Linux 内核的源代码级调试器，与另一台机器上的 GDB 配合使用，可以检查堆栈跟踪和查看内核状态（如 PC 值、定时器内容和内存）。
设备 /dev/kmem 允许运行时访问内核内存。

当然，可以使用支持 Linux 的 JTAG 调试器来调试线程。
通常只能暂停所有进程；
无法暂停单个线程或进程并使其他线程继续运行。
可以为所有线程设置断点，也可以仅在特定线程上设置断点。

由于内存映射取决于哪个进程处于活动状态，因此通常只能在特定进程映射时设置软件断点。
ARM DS-5 Debugger 能够使用 gdbserver 调试 Linux 应用程序，并使用 JTAG 调试 Linux 内核和 Linux 内核模块。
DS-5 Debugger 的调试和跟踪功能将在下一节中介绍。

\paragraph*{调用栈}

应用程序代码使用调用堆栈来传递参数、存储局部数据和存储返回地址。
每个函数在堆栈上推送的数据被组织成一个栈帧。
当调试器停止一个核心时，它可能能够分析堆栈上的数据，为您提供一个调用堆栈，即导致当前情况的函数调用列表。
在调试时，这可能非常有用，因为它使您能够确定应用程序为什么会达到特定的状态。

为了重建调用堆栈，调试器必须能够确定堆栈上哪些条目包含返回地址信息。
如果代码是使用这些信息构建的（包含了 DWARF 调试表），则这些信息可能包含在调试器信息中，或者通过跟随应用程序在堆栈上推送的帧指针链来确定。
为此，代码必须构建为使用帧指针。
如果这两种类型的信息都不存在，则无法构建调用堆栈。

在多线程应用程序中，每个线程都有自己的堆栈。
因此，调用堆栈信息只与正在检查的特定线程相关联。

\paragraph*{Semihosting 调试}

Semihosting 是一种机制，允许在 ARM 目标上运行的代码使用在运行调试器的主机计算机上提供的功能。

这些功能的示例可能包括键盘输入、屏幕输出和磁盘 I/O。
例如，您可以使用这种机制使 C 库函数，如 printf() 和 scanf()，使用主机的屏幕和键盘。
开发硬件通常没有完整的输入和输出设施，但是 Semihosting 使主机计算机能够提供这些设施。

Semihosting 是通过一组定义的软件指令来实现的，这些指令会生成一个异常。
应用程序调用适当的 Semihosting 调用，然后调试代理处理异常。
调试代理提供与主机的必要通信。

Semihosting 使用的规范与实现 ARMv7 的处理器不同。
DS-5 调试器通过拦截 AArch64 中的 HLT 0xF000 来处理 Semihosting。

当然，在开发环境之外，运行在主机上的调试器通常不会连接到系统。
因此，开发人员需要重新定位任何使用 Semihosting 的 C 库函数，例如使用 fputc()。
这将涉及将使用 SVC 调用的库代码替换为可以输出字符的代码。

\subsubsection{ARM 硬件跟踪}

非侵入式调试使您能够观察核心在执行时的行为。
虽然有不同种类的非侵入式调试，但本节特别描述了跟踪和跟踪硬件。
可以记录执行的内存访问（包括地址和数据值），并生成程序的实时跟踪，查看外设访问、堆栈和堆访问以及变量的更改。
对于许多实时系统来说，使用侵入式调试方法是不可能的。
例如，考虑一下引擎管理系统，虽然您可以在特定点停止核心，但引擎会继续运转，您将无法进行有用的调试。
即使在实时要求较少的系统中，跟踪也可以非常有用。

跟踪通常由连接到核心的内部硬件块提供。
这被称为嵌入式跟踪宏单元（ETM），并且是大多数基于 ARM 处理器的系统的一部分。
在某些情况下，每个核心都有一个 ETM。
片上系统设计人员可以省略此块以减少硅片成本。
这些块观察但不影响核心行为，并且能够监视指令执行和数据访问。

捕获跟踪的主要问题有两个。
首先，随着当前非常高的核心时钟速度，即使几秒钟的操作也可能意味着数万亿个周期的执行。
显然，理解这么多信息将极其困难。

第二个相关问题是，当前的核心可能每个周期执行一个或多个 64 位缓存访问，为了记录数据地址和数据值，可能需要大量带宽。
这带来的问题是，通常芯片上可能只提供了少量引脚，而且这些输出可以以显着低于核心时钟频率的速率进行切换。
如果核心每个周期产生 100 位信息，时钟速度为 1GHz，但芯片只能以 200MHz 的速度输出四位跟踪信息，那么就会出现问题。

为了解决后一个问题，跟踪宏单元尝试压缩信息以减少所需的带宽。
然而，处理这些问题的主要方法是控制跟踪块，以仅收集选定的跟踪信息。
例如，您可能只跟踪执行，而不记录数据值。

此外，通常将跟踪信息存储在片上存储器缓冲区中（嵌入式跟踪缓冲区（ETB））。
这消除了以速度将信息传送到芯片外部的问题，但以硅片面积（因此芯片价格）为代价，并且还提供了可以捕获的跟踪量的固定限制。

ETB 以循环方式存储压缩的跟踪信息，不断捕获跟踪信息直至停止。
ETB 的大小因芯片实现而异，但 8 或 16KB 的缓冲区通常足以容纳几千行程序跟踪。
当程序失败时，如果启用了跟踪缓冲区，则可以查看部分程序历史记录。
有了这个程序历史记录，更容易回溯您的程序，查看故障点之前发生了什么。
对于调查难以通过传统调试方法（需要停止和启动核心）确定的间歇性和实时故障，使用硬件跟踪可以显着减少查找故障所需的时间，因为跟踪显示了确切执行了什么、时间和发生了什么数据访问。

\paragraph*{CoreSight} \label{sec:CoreSight}

ARM CoreSight™ 技术扩展了 ETM 提供的功能。
再次强调，特定系统中的其存在和功能由系统设计者定义。
CoreSight 提供了许多非常强大的调试设施。
它使得多核系统（包括非对称和 SMP）的调试可以共享调试访问和跟踪引脚，并完全控制在哪些时间追踪哪些核心。
嵌入式交叉触发机制使工具能够以同步的方式控制多个核心，例如，当一个核心命中断点时，所有其他核心也将停止。

性能分析工具可以使用数据显示程序花费时间的位置以及存在的性能瓶颈。
代码覆盖工具可以使用跟踪数据提供调用图探索。
操作系统感知调试器可以利用跟踪，并在某些情况下，通过额外的代码仪表化提供高级系统上下文信息。
以下是一些可用 CoreSight 组件的简要描述：

\begin{description}
  \item[调试访问端口（DAP）] \hfill \\
    DAP 是 ARM CoreSight 系统的可选部分。
    并非每个设备都包含 DAP。
    它使外部调试器能够直接访问系统的内存空间，而无需将核心置于调试状态。
    如果没有 DAP，读取或写入内存可能需要调试器停止核心并使其执行 Load 或 Store 指令。
    DAP 使外部调试工具能够访问系统中所有的 JTAG 扫描链，从而能够调试和跟踪可用核心和其他组件的配置寄存器。

  \item [嵌入式交叉触发（ECT）] \hfill \\
    ECT 块是 CoreSight 系统中可能包含的一个组件。
    其目的是将系统中多个设备的调试功能连接在一起。
    例如，您可以有两个独立运行的核心。
    当您在一个核心上的程序上设置断点时，如果能够指定当该核心停止在断点时，另一个核心也必须停止（无论它当前执行的指令是什么），那将非常有用。
    ECT 中的交叉触发矩阵和接口使得调试状态和控制信息能够在核心和跟踪宏单元之间传播。

    在 ARMv8 处理器系统中，总是需要交叉触发块，因为它提供了处理器在进入停止模式后重新启动执行的唯一方式。

  \item[CoreSight 串行线] \hfill \\
    CoreSight 串行线调试使用 Debug 访问端口（DAP）提供了一个 2 引脚连接，其功能相当于一个 5 引脚的 JTAG 接口。

  \item[系统跟踪宏单元（STM）] \hfill \\
    这提供了一种多核（和进程）执行 printf() 样式调试的方式。
    系统中任何主控可以在不知道其他人使用的情况下访问 STM 通道，使用非常简单的代码片段。
    这使得可以对内核和用户空间代码进行时间戳软件仪表化。
    时间戳信息提供了与前一个事件相对的增量，非常有用。

  \item[跟踪内存控制器（TMC）] \hfill \\
    如前所述，向封装的 IC 添加额外引脚可能会显着增加成本。
    在一个设备上有多个核心（或其他能够生成跟踪信息的块）的情况下，经济因素可能使提供多个跟踪端口的可能性不大。
    CoreSight 跟踪内存控制器是一个跟踪漏斗，具有将多个跟踪源合并到系统内存中的能力。
    提供了控制来启用、优先级和选择这些多个输入源之间的选项。
    跟踪信息可以通过专用跟踪端口、通过 JTAG 或串行线接口或通过重新使用 SoC 的 I/O 端口导出。
    跟踪信息可以存储在 ETB 中或系统内存中。
\end{description}


\subsubsection{DS-5 调试和跟踪}

DS-5 Debugger 提供了一个强大的工具，用于调试基于 ARM 架构处理器的硬件目标和模型上的应用程序。
您可以完全控制执行流程，以便快速隔离和纠正错误。

DS-5 Debugger 提供了一系列广泛的调试功能，包括：

\begin{itemize}
\item
  加载镜像和符号。
\item
  运行镜像。
\item
  断点和监视点。
\item
  源码和指令级步进。
\item
  控制变量和寄存器值。
\item
  查看调用堆栈。
\item
  支持处理异常和 Linux 信号。
\item
  调试多线程 Linux 和 Android 应用程序。
\item
  调试 Linux、内核和 Android 模块、引导代码和内核移植。
\item
  应用程序倒带，允许您通过 Linux 和 Android 应用程序进行前向和后向调试。
\end{itemize}

调试器支持在 Eclipse IDE、脚本文件或命令行控制台中执行的一套全面的 DS-5 调试器命令。
此外，还有一小部分足以运行目标初始化脚本的 CMM 风格命令子集。

DS-5 调试器支持使用 JTAG 进行裸机调试，使用 gdbserver 进行 Linux 应用程序调试，使用 JTAG 进行 Linux 内核调试和内核模块调试。
对裸机 SMP 系统的调试和跟踪支持，包括交叉触发和与核心相关的视图和断点、PTM 跟踪，以及使用 DSTREAM 进行高达 4GB 的跟踪。
这些支持在以下章节中进行了描述。

此外，DS-5 调试器支持 ARM CoreSight ETM、PTM、ETB 和 STM，提供非侵入式的程序跟踪，使您可以回顾指令（及其相关的源代码）的执行情况。
它还提供了调试时间敏感性问题的能力，否则这些问题将无法通过传统的侵入式步进技术检测到。

\paragraph*{使用 DS-5 调试 Linux 和安卓程序}

调试 Linux 或 Android 应用程序需要在目标设备上安装并运行 gdbserver 等调试服务器。
您可以使用 TCP 或串行连接到运行操作系统的目标设备，该设备可以是真实的目标硬件或软件模型。

DS-5 调试器负责下载并连接到调试服务器。
开发人员只需指定平台和 IP 地址即可。
这将复杂的任务简化为 IDE 中的几个步骤，而不需要使用多个应用程序和终端。

\paragraph*{调试内核模块}

Linux 内核模块提供了扩展内核功能的方式，通常用于诸如设备和文件系统驱动程序等功能。
模块可以构建到内核中，也可以编译为可加载模块，然后在开发过程中动态地插入和删除运行中的内核，而无需频繁重新编译内核。

然而，某些模块必须构建到内核中，并且不适合动态加载。
内核中的一个示例是在内核启动期间必须可用并且必须在挂载根文件系统之前可用的模块。

您可以使用 DS-5 调试器在模块中设置源级断点，前提是调试信息已加载到调试器中。
在将模块插入内核之前尝试在模块中设置断点将导致断点被挂起。

在调试模块时，必须确保目标设备上的模块与主机上的模块相同。
代码布局必须相同，但目标上的模块不必包含调试信息。

\subparagraph*{内嵌模块}

要使用 DS-5 调试器调试已构建到内核中的模块，步骤与调试内核本身的步骤相同：

\begin{enumerate}
\item
  将内核与模块一起编译。
\item
  将内核映像加载到目标设备上。
\item
  将带有调试信息的相关内核映像加载到调试器中。
\item
  就像调试任何其他内核代码一样调试模块。
\end{enumerate}

\subparagraph*{可加载模块}

调试可加载内核模块的过程更加复杂。
从Linux 终端 shell 中，您可以使用 insmod 和 rmmod 命令来插入和删除模块。
必须将内核和可加载模块的调试信息加载到调试器中。
插入和删除模块时，DS-5 调试器会自动解析调试信息和现有断点的内存位置。
为此，DS-5 调试器拦截内核中插入和删除模块的调用。
这会在每个操作中引入小的延迟，因为调试器会停止内核来询问各种数据结构。

\paragraph*{调试 Linux 内核}

要调试 Linux 内核模块，您可以使用诸如 DSTREAM 之类的调试硬件代理，在主机工作站和运行目标之间建立连接。
要能够以源代码级别调试内核，您需要将包含调试符号的 vmlinux 文件加载到调试器中。

\Figure[caption={使用 DS-5 调试内核}, label={fig:debug-linux-kernel-ds-5}, width=1]{debug-linux-kernel-ds-5}

\paragraph*{调试多线程应用}

DS-5 调试器使用调试器变量 \$thread 跟踪当前线程。
您可以在打印命令或表达式中使用此变量。
线程显示在调试控制视图中，具有调试器使用的唯一 ID 和操作系统使用的唯一 ID。
例如：

Thread 1（OS ID 1036）

其中，Thread 1 是调试器使用的 ID，而 OS ID 1036 是操作系统使用的 ID。
每个线程都维护着单独的调用堆栈，选择的堆栈帧以粗体文本显示。
DS-5 调试透视图中的所有视图都与所选的堆栈帧相关联，并在选择其他帧时进行更新。

\Figure[caption={DS-5 中的线程调用栈}, label={fig:thread-call-stack-ds-5}, width=1]{thread-call-stack-ds-5}

\paragraph*{调试共享库}

共享库使您的应用程序的部分能够在运行时动态加载。
您必须确保目标上的共享库与主机上的共享库相同。
代码布局必须相同，但目标上的共享库不必包含调试信息。

您可以在共享库中设置标准执行断点，但是直到应用程序加载共享库并将调试信息加载到调试器中才能设置。
但是，挂起断点使您能够在应用程序加载共享库之前在其中设置执行断点。

当新的共享库被加载时，DS-5 调试器会重新评估所有挂起的断点，那些它可以解析地址的断点会被设置为标准执行断点。
未解析的地址保持为挂起的断点。

当您的应用程序卸载共享库时，调试器会自动将共享库中的任何断点更改为挂起断点。

\paragraph*{DS-5 跟踪支持}

DS-5 使您能够对应用程序或系统进行跟踪。
您可以实时捕获指令的历史非侵入式跟踪。
跟踪是一种强大的工具，使您能够在系统以全速运行时调查问题。
这些问题可能是间歇性的，并且通过传统的调试方法很难识别，因为这些方法需要启动和停止核心。
跟踪还在试图确定潜在瓶颈或改善应用程序中性能关键区域时非常有用。

\subparagraph*{跟踪视图}

一旦跟踪数据被捕获，调试器会从跟踪流中提取信息并进行解压，以提供执行的代码的完整反汇编，包含符号。
这个视图显示了一个图形导航图表，显示了带有导航时间轴的函数执行情况。
此外，反汇编跟踪显示了与关联地址和（如果选择）指令相关联的函数调用。
单击图表中的特定时间会同步显示反汇编视图。
在图表的左侧列中，为每个函数显示了与总跟踪相关的百分比。
例如，如果执行了总共 1000 条指令，并且其中有 300 条指令与 myFunction() 相关，则该函数将显示为 30\%。
在导航时间轴中，颜色编码是一种``热''图，显示了每个时间轴中执行的指令以及每个函数在每个时间轴中执行的指令数。
深红色显示更多的指令，浅黄色显示较少的指令。
然而，在 1:1 的比例下，颜色方案会改变，将内存访问指令显示为深红色，分支指令显示为中等橙色，而其他所有指令则显示为较浅的绿色。

\Figure[caption={DS-5 跟踪视图}, label={fig:ds-5-trace}, width=0.9]{ds-5-trace}

\subparagraph*{基于跟踪的分析}

根据从目标设备接收的跟踪数据，DS-5 调试器可以生成时间线图表，提供信息以帮助开发人员快速了解其软件在目标设备上的执行情况以及哪些函数最多地使用了核心。
时间线图表提供各种缩放级别，并且可以根据每个时间单位内的指令数量显示热图，或者在其最高分辨率时，提供按照每个指令的典型延迟进行颜色编码的逐条可视化。

