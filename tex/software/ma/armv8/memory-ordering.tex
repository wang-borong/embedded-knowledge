\subsection{内存排序} \label{sec:memory-ordering}

如果您的代码直接与硬件交互，或者与在其他核心上执行的代码交互，或者直接加载或写入要执行的指令，或者修改页表，您需要注意内存排序问题。

如果您是应用程序开发人员，则硬件交互可能是通过设备驱动程序进行的，与其他核心的交互是通过 Pthreads 或其他多线程 API 进行的，与分页内存系统的交互是通过操作系统进行的。
在以上这些情况下，相关代码会为您处理内存排序问题。
但是，如果您正在编写操作系统内核或设备驱动程序，或者实现超级监视器、即时编译器或多线程库，那么您必须对 ARM 架构的内存排序规则有很好的理解。
\textbf{您必须确保在您的代码需要显式排序内存访问时，通过正确使用障碍来实现这一点}。

ARMv8 架构采用了弱排序的内存模型。
一般来说，这意味着内存访问的顺序不需要与加载和存储操作的程序顺序相同。
处理器能够对内存读取操作进行重新排序。
写操作也可以被重新排序（例如，写组合）。
因此，硬件优化，例如使用缓存和写缓冲区，以提高处理器的性能，这意味着处理器与外部存储之间所需的带宽可以降低，并且与此类外部存储访问相关的长延迟被隐藏。

对于普通内存的读写可以被硬件重新排序，只受数据依赖关系和显式内存屏障指令的影响。
某些情况需要更强的排序规则。
您可以通过描述该内存的翻译表条目的内存类型属性向核心提供相关信息。

在性能非常高的系统中，可能会支持诸如 speculative memory reads、指令的多次发射、乱序执行等技术，这些技术与其他技术一起，提供了硬件重新排序内存访问的进一步可能性：

\begin{itemize}
\item
  指令的多次发射：处理器可能会在每个周期发射和执行多条指令，因此程序顺序中紧随其后的指令可以同时执行。
\item
  乱序执行：许多处理器支持非依赖性指令的乱序执行。
  每当一条指令因为等待前一条指令的结果而停滞时，处理器可以执行不具有依赖性的后续指令。
\item
  推测执行：当处理器遇到条件指令（例如分支）时，它可以在确定是否必须执行该特定指令之前进行推测性地执行指令。
  因此，如果条件解析为推测是正确的，结果将更快地得到。
\item
  推测加载：如果对可缓存位置的加载指令进行了推测性执行，这可能导致缓存行填充和潜在的现有缓存行逐出。
\item
  加载和存储优化：由于对外部存储器的读写可能具有较长的延迟，处理器可以通过将多个存储合并成一个较大的事务来减少传输次数。
\item
  外部存储系统：在许多复杂的片上系统（SoC）设备中，有许多代理可以启动传输，并且读取或写入的从设备有多个路由。
  一些设备，如 DRAM 控制器，可能能够接受来自不同主设备的同时请求。
  事务可以被缓冲或者由互连重新排序。
  这意味着来自不同主设备的访问可能需要不同数量的周期来完成，并且可能相互超越。
\item
  缓存一致的多核处理：在多核处理器中，硬件缓存一致性可以在核之间迁移缓存行。
  因此，不同的核可能以不同的顺序看到对缓存的内存位置的更新。
\item
  优化编译器：优化编译器可以重新排列指令以隐藏延迟或充分利用硬件功能。
  它通常会将内存访问向前移动，以便更早地进行，并为其提供更多的时间以在所需值之前完成。
\end{itemize}

在单核系统中，这种重新排序的效果通常对程序员来说是透明的，因为单个处理器可以检查危险并确保数据依赖关系得到尊重。
然而，在具有通过共享内存进行通信或以其他方式共享数据的多核心系统中，内存排序考虑变得更为重要。
本章讨论了与多处理（MP）操作和多个执行线程同步相关的几个主题。
它还讨论了由架构定义的内存类型和规则以及如何进行控制。

\subsubsection{内存类型}

ARMv8 架构定义了两种互斥的内存类型。
内存的所有区域都配置为这两种类型之一，即 Normal 和 Device。
第三种内存类型，强顺序（Strongly Ordered），是 ARMv7 架构的一部分。
这种类型与 Device 内存之间的差异很少，因此现在在 ARMv8 中被省略了。

除了内存类型外，属性还可以控制缓存性、共享性、访问和执行权限。
可共享和缓存属性仅适用于 Normal 内存。
设备区域始终被视为非缓存和外部共享。
对于可缓存的位置，您可以使用属性来指示处理器的缓存分配策略。

内存类型不是直接编码在翻译表项中的。
相反，每个块条目指定了一个 3 位索引，该索引指向内存类型表。
此表存储在 Memory Attribute Indirection Register MAIR\_ELn 中。
该表有八个条目，每个条目都有八位，如图 13 - 1 所示。

尽管翻译表块条目本身不直接包含内存类型编码，但处理器内部的 TLB 条目通常会为特定条目存储此信息。
因此，对 MAIR\_ELn 的更改可能直到执行 ISB 指令屏障和 TLB 失效操作之后才能观察到。

\Figure[caption={类型编码}, label={fig:type-encoding}, width=0.8]{type-encoding}

\paragraph*{Normal}

您可以将 Normal 内存用于所有代码和大多数内存中的数据区域。
Normal 内存的示例包括物理内存中的 RAM、Flash 或 ROM 区域。
这种类型的内存提供了最高的处理器性能，因为它是弱有序的，并且对处理器施加的限制较少。
处理器可以重新排序、重复和合并对 Normal 内存的访问。

此外，标记为 Normal 的地址位置可以由处理器进行推测性访问，因此数据或指令可以从内存中读取，而无需在程序中明确引用，或者在明确引用之前执行。
这种推测性访问可能是由于分支预测、推测性缓存行填充、乱序数据加载或其他硬件优化而发生的。

为了获得最佳性能，始终将应用程序代码和数据标记为 Normal，并在需要强制执行内存顺序的情况下，可以通过使用显式的屏障操作来实现。
Normal 内存实现了一种弱有序的内存模式。
Normal 访问不需要与其他 Normal 访问或 Device 访问顺序完全一致。

但是，处理器必须始终处理由地址依赖性引起的冲突。
例如，考虑以下简单的代码序列：

\begin{lstlisting}
STR X0, [X2]
LDR X1, [X2]
\end{lstlisting}

处理器始终确保将放置在 X1 中的值是存储在 X2 中的地址写入的值。

当然，这也适用于更复杂的依赖关系。
考虑以下代码：

\begin{lstlisting}
ADD X4, X3, #3
ADD X5, X3, #2
STR X0, [X3]
STRB W1, [X4]
LDRH W2, [X5]
\end{lstlisting}

在这种情况下，访问的地址重叠。
处理器必须确保内存更新为像 STR 和 STRB 按顺序发生一样，以便 LDRH 返回最新的值。
处理器仍然可以将 STR 和 STRB 合并为一个包含最新、正确数据的单个访问，这是有效的。

\paragraph*{Device}

你可以将设备内存用于所有可能具有副作用的内存区域。
例如，对 FIFO 位置或计时器的读取是不可重复的，因为每次读取返回的值都不同。
对控制寄存器的写入可能会触发中断。
通常仅用于系统中的外设。
设备内存类型对核心施加了更多限制。

不能对标记为设备的内存区域执行推测性数据访问。
这有一个单独的、不常见的例外情况。
如果使用 NEON 操作从设备内存读取字节，则处理器可能会读取未显式引用的字节，如果它们位于一个对齐的 16 字节块中，该块包含一个或多个显式引用的字节。

尝试从标记为设备的区域执行代码通常是不可预测的。
实现可能会将指令提取处理为具有正常非可缓存属性的内存位置，或者可能会发生权限故障。

有四种不同类型的设备内存，适用不同的规则。

\begin{itemize}
\item
  Device-nGnRnE 最严格的（相当于 ARMv7 架构中的 Strongly Ordered 内存）。
\item
  Device-nGnRE
\item
  Device-nGRE
\item
  Device-GRE 最不严格的
\end{itemize}

字母后缀表示以下三个属性：

\begin{description}
  \item [Gathering or non Gathering (G 或 nG)]

  决定是否可以将多个访问合并成单个总线事务。
  对于标记为非 Gathering（nG）的地址，执行到该位置的内存总线上的访问次数和大小必须与代码中的显式访问次数和大小完全匹配。
  如果地址标记为 Gathering（G），则处理器可以将两个字节写入合并为单个半字写入。
  对于标记为 Gathering 的区域，多个内存访问可以合并到相同的内存位置。
  例如，如果程序两次读取相同的位置，则核心只需要执行一次读取，并且可以为两个指令返回相同的结果。
  对于从标记为非 Gathering 的区域的读取，数据值必须来自终端设备，不能从写缓冲区或其他位置窃取。

  \item [Re-ordering (R 或 nR)]

  决定对同一设备的访问是否可以相互重排。
  如果地址标记为非重排序（nR），则同一块内的访问始终按程序顺序出现在总线上。
  此块的大小由实现定义。
  如果此块的大小较大，则可能跨越多个表项。
  在这种情况下，对于也标记为
  nR 的任何其他访问，都遵守排序规则。

  \item [Early Write Acknowledgement (E 或 nE)]

  确定在处理器和被访问的从设备之间是否允许有一个中间写入缓冲区发送写入完成的确认。
  如果地址标记为非早期写入确认（nE），则写入响应必须来自外围设备。
  如果地址标记为早期写入确认（E），则允许在实际接收到写入之前，互连逻辑中的缓冲区提前信号写入接受。
  这本质上是对外部内存系统的一种消息。

\end{description}

\subsubsection{屏障}

ARM 架构包含屏障指令，用于在特定点强制访问排序和访问完成。
在某些架构中，类似的指令称为栅栏。

如果你正在编写重要的排序代码，请参阅《ARM 架构参考手册 -
ARMv8-A 架构配置文件》附录 J7 中的屏障测试和《ARM 架构参考手册
ARMv7-A/R 版本》附录 G 中的屏障测试，其中包含许多示例。

ARM 架构参考手册定义了一些关键词，特别是“观察”和“必须观察”的术语。
在典型的系统中，这定义了主控件（例如，核心或 GPU）的总线接口和互连必须如何处理总线事务。
只有主控件能够观察到传输。
所有总线事务都由主控件发起。
主控件执行事务的顺序不一定与这些事务在从设备完成的顺序相同，因为事务可能会被互连重新排序，除非显式强制执行某些排序。

描述可观测性的一种简单方法是说，“当我可以读到你写的内容时，我已经观察到了你的写入，并且当我不能再更改你读取的值时，我已经观察到了你的读取”，其中我和你都指的是系统中的核心或其他主控件。

架构提供了三种类型的屏障指令：

\begin{description}
  \item [指令同步屏障（ISB）] 用于保证后续指令再次被获取，以便使用当前的 MMU 配置进行特权和访问检查。
  它用于确保先前执行的上下文切换操作（例如写入到系统控制寄存器）在 ISB 完成时已经完成。
  在硬件方面，这可能意味着刷新指令流水线，例如。
  典型的用法包括内存管理、缓存控制和上下文切换代码，或者代码在内存中移动的情况。
  \item [数据内存屏障（DMB）] 防止在屏障指令之间对数据访问指令进行重新排序。
  在 DMB 之前由该处理器执行的所有数据访问（即加载或存储），但不包括指令获取，对于指定的可共享域内的所有其他主控件都是可见的，在 DMB 之后的任何数据访问之前。
    例如：
    \begin{lstcode}
      LDR x0, [x1] // Must be seen by the memory system before the STR below.
      DMB ISHLD
      ADD x2, #1   // May be executed before or after the memory system sees LDR.
      STR x3, [x4] // Must be seen by the memory system after the LDR above.
    \end{lstcode}

    它还确保在执行任何后续数据访问之前，任何明确的前置数据或统一缓存维护操作都已完成。

    \begin{lstcode}
      DC CSW, x5   // Data clean by Set/way
      LDR x0, [x1] // Effect of data cache clean might not be seen by this
                   // instruction
      DMB ISH
      LDR x2, [x3] // Effect of data cache clean will be seen by this
      instruction
    \end{lstcode}
  \item [数据同步屏障（DSB）] 强制执行与数据内存屏障相同的排序，并额外阻止执行任何进一步的指令，而不仅仅是加载或存储，或两者，直到同步完成。
  这可用于防止执行 SEV 指令，例如，该指令会向其他核心发出信号，表示发生了事件。
  它等待由该处理器发出的所有缓存、TLB 和分支预测器维护操作针对指定的共享域都已经完成。
    例如：
    \begin{lstcode}
      DC ISW, x5     // operation must have completed before DSB can complete
      STR x0, [x1]   // Access must have completed before DSB can complete DSB ISH
      ADD x2, x2, #3 // Cannot be executed until DSB completes
    \end{lstcode}
\end{description}

正如你从上述示例中看到的那样，DMB 和 DSB 指令带有一个参数，指定屏障操作的访问类型（之前或之后），以及适用的共享域。

可用选项列在表中。

\begin{ltblr}[caption={屏障参数}, label={tbl:barrier-param}]{colspec={c>{\centering\arraybackslash}Xc}}
  \hline[1pt]
  <option>   & Ordered Accesses (before – after) & Shareability Domain \\
  \hline
  OSHLD      & Load – Load, Load – Store         &                     \\
  OSHST      & Store – Store                     & Outer shareable     \\
  OSH        & Any – Any                         &                     \\
  NSHLD      & Load – Load, Load – Store         &                     \\
  NSHST      & Store – Store                     & Non-shareable       \\
  NSH        & Any – Any                         &                     \\
  ISHLD      & Load – Load, Load – Store         & Inner shareable     \\
  ISHST      & Store – Store                     &                     \\
  ISH        & Any – Any                         &                     \\
  LD         & Load – Load, Load – Store         &                     \\
  ST         & Store – Store                     & Full system         \\
  SY         & Any – Any                                               \\
  \hline[1pt]
\end{ltblr}

有序访问字段指定屏障操作的访问类别。
有三种选择。

\begin{itemize}
\item 装载
\item 装载 / 存储

  这意味着屏障要求在屏障之前完成所有装载，但不要求存储完成。
  程序顺序中出现在屏障之后的装载和存储都必须等待屏障完成。
\item 存储 - 存储

    这意味着屏障只影响存储访问，装载可以在屏障周围自由重排序。
\item 任意 - 任意

  这意味着在屏障之前必须完成装载和存储。
  程序顺序中出现在屏障之后的所有装载和存储都必须等待屏障完成。
\end{itemize}

屏障用于防止不安全的优化发生，并强制执行特定的内存排序。
因此，不必要的屏障指令使用可能会降低软件性能。
在特定情况下，请仔细考虑是否需要屏障，以及使用哪种正确的屏障。

排序规则的更微妙影响是核心的指令界面、数据界面和 MMU 表遍历器被视为单独的观察者。
这意味着您可能需要，例如，使用 DSB 指令以确保在一个接口上的访问被保证在另一个接口上是可观察到的。

如果执行数据缓存清除和使无效指令，例如 DCCVAU，X0，您必须在此之后插入 DSB 指令，以确保后续的页表遍历、翻译表条目修改、指令获取或内存中的指令更新都可以看到新值。

例如，考虑对翻译表的更新：

\begin{lstlisting}
STR X0，[X1]    // 更新一个翻译表条目
DSB ISHST       // 确保写入已完成
TLBI VAE1IS，X2 // 使更改的 TLB 条目无效
DSB ISH         // 确保 TLB 失效已完成
ISB             // 在该处理器上同步上下文
\end{lstlisting}

必须使用 DSB 来确保维护操作完成，并且必须使用 ISB 来确保后续指令看到这些操作的影响。

处理器可能随时对标记为 Normal 的地址进行推测性访问。
因此，在考虑是否需要屏障时，不仅要考虑由装载或存储指令生成的显式访问。

\paragraph{单路屏障}

AArch64
引入了带有隐含屏障语义的新加载和存储指令。
这些指令要求在隐含屏障之前或之后的所有加载和存储操作按照程序顺序观察到。

\begin{description}
\item
  [加载 - 获取 (Load-Acquire, LDAR)]
    程序顺序中在 LDAR 之后的所有加载和存储操作，并且与目标地址的共享域匹配的，必须在 LDAR 之后观察到。
\item
  [存储 - 释放 (Store-Release, STLR)]
    程序顺序中在 STLR 之前的所有加载和存储操作，并且与目标地址的共享域匹配的，必须在 STLR 之前观察到。
\end{description}

还有这些指令的独占版本：LDAXR 和 STLXR。

与数据屏障指令不同，数据屏障指令需要一个限定符来控制哪些共享域可以看到屏障的效果，而 LDAR 和 STLR 指令使用的是被访问地址的属性。

一个 LDAR 指令保证在 LDAR 之后的任何内存访问指令，只有在加载 - 获取之后才可见。
存储 - 释放保证所有较早的内存访问在存储 - 释放变为可见之前都是可见的，并且存储在系统中所有可以存储缓存数据的部分同时可见。

\Figure[caption={单路屏障}, label={fig:one-way-barriers}, width=0.4]{one-way-barriers}

上图展示了访问如何可以在一个方向上穿过单向屏障，但在另一个方向上不能穿过。

\paragraph{详视 ISB}

ARMv8 架构定义了上下文为系统寄存器的状态，并且上下文改变操作包括缓存、TLB 和分支预测器维护操作，或者对系统控制寄存器（例如 SCTLR\_EL1、TCR\_EL1 和 TTBRn\_EL1）的更改。
上下文改变操作的效果只有在上下文同步事件发生后才能被保证看到。

有三种上下文同步事件：

\begin{itemize}
\item
  发生异常。
\item
  从异常返回。
\item
  指令同步屏障（ISB）。
\end{itemize}

ISB 会刷新流水线，从缓存或内存重新获取指令，并确保在 ISB 之前完成的任何上下文改变操作的效果对 ISB 之后的任何指令可见。
它还确保在 ISB 指令之后的任何上下文改变操作仅在 ISB 执行后生效，并且不会被 ISB 之前的指令看到。
这并不意味着在每个修改处理器寄存器的指令之后都需要一个 ISB。
例如，对 PSTATE 字段、ELRs、SPs 和 SPSRs 的读写相对于其他指令按程序顺序执行。

以下示例展示了如何在 AArch64 中启用浮点单元和 NEON，这可以通过写入 CPACR\_EL1 寄存器的第{[}20{]}位来实现。
ISB 是一个上下文同步事件，保证在任何后续或 NEON 指令执行之前启用操作已经完成。

\begin{lstlisting}
MRS X1, CPACR_EL1
ORR X1, X1, #(0x3 << 20)
MSR CPACR_EL1, X1
ISB
\end{lstlisting}

\paragraph{C 中使用屏障}

C11 和 C++11 语言提供了一个良好的平台无关的内存模型，如果可能的话，使用它们比使用内在函数更优。

所有版本的 C 和 C++都有序列点（sequence points），但 C11 和 C++11 还提供了内存模型。
序列点只防止编译器重新排序 C++源代码。
没有任何机制可以阻止处理器在生成的目标代码中重新排序指令，或读写缓冲区重新排序数据传输发送到缓存的顺序。
换句话说，它们仅适用于单线程代码。
对于多线程代码，要么使用 C11/C++11 的内存模型特性，要么使用操作系统提供的其他同步机制，例如互斥锁（mutexes）。
通常情况下，编译器不能跨越序列点重新排列语句，并且限制了编译器可以进行的优化。
代码中序列点的示例包括函数调用和对易失性变量的访问。

C 语言规范对序列点的定义如下：

“在执行序列中的某些特定点，称为序列点，之前所有评估的副作用都应完成，并且后续评估的副作用尚未发生。”

\subparagraph*{Linux 内核中的屏障}

Linux 内核包含许多平台无关的屏障函数。
更多详细信息请参见内存屏障的 Linux 内核文档 memory-barriers.txt 文件：
\url{https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/}。

\paragraph{non-temporal 加载和存储对}

ARMv8 引入了一个新概念，即非时间相关（non-temporal）加载和存储。
LDNP（Load Non-temporal Pair）和 STNP（Store Non-temporal Pair）指令执行一对寄存器值的读取或写入操作。
同时，它们向内存系统提供一个缓存提示，表明这些数据缓存无用。
这个提示并不禁止内存系统活动，如地址缓存、预加载或聚合，而只是表示缓存可能不会提升性能。
一个典型的使用案例是数据流处理，但需要注意的是，有效使用这些指令需要特定于微架构的方法。

非时间相关加载和存储放宽了内存排序要求。
在上述情况下，LDNP 指令可能会在前面的 LDR 指令之前被观察到，这可能导致从 X0 中读取不可预测的地址。

例如：

\begin{lstlisting}
LDR X0, [X3]
LDNP X2, X1, [X0]
\end{lstlisting}

为了纠正上述情况，需要一个显式的加载屏障：

\begin{lstlisting}
LDR X0, [X3]
DMB NSHLD
LDNP X2, X1, [X0]
\end{lstlisting}

\paragraph{内存属性}

系统的内存映射被划分成多个区域。
每个区域可能需要不同的内存属性，例如访问权限，包括不同权限级别的读写权限、内存类型和缓存策略。
功能性的代码和数据通常在内存映射中被组合在一起，并且每个区域的属性分别受到控制。
这一功能由内存管理单元（Memory Management Unit, MMU）执行。
翻译表条目使得 MMU 硬件能够将虚拟地址翻译为物理地址。
此外，这些条目还指定了与每个页面相关的一系列属性。

下图显示了在一级块条目中如何指定内存属性。
翻译表中的块条目定义了每个内存区域的属性。
二级条目有不同的布局。

\Figure[caption={1 级块内存属性}, label={fig:s1-blk-mem-attr}, width=1]{s1-blk-mem-attr}

其中：

\begin{itemize}
\item
  \textbf{UXN}（Unprivileged eXecute Never）和\textbf{PXN}（Privileged
  eXecute Never）是执行权限。
\item
  \textbf{AF}（Access Flag）是访问标志。
\item
  \textbf{SH}（Shareable attribute）是可共享属性。
\item
  \textbf{AP}（Access Permission）是访问权限。
\item
  \textbf{NS}（Non-Secure bit）是安全位，但仅在 EL3 和 Secure EL1 时使用。
\item
  \textbf{Indx}是 Memory Attribute Indirection
  Register（MAIR\_ELn）的索引。
\end{itemize}

描述符格式支持分层属性，因此在一个级别设置的属性可以被下层继承。
这意味着在 L0、L1 或 L2 表中的表项可以覆盖它所指向的表中指定的一个或多个属性。
这可以用于访问权限、安全性和执行权限。
例如，L1 表中的一个具有 NSTable=1 的条目意味着忽略了它所指向的 L2 和 L3 表中的 NS 位，并且所有条目都被视为具有 NS=1。
这个特性只限制了同一级别的后续查找。

\subparagraph*{可缓存和可共享的内存属性}

标记为 Normal 的内存区域可以被指定为缓存或非缓存。
有关可缓存内存的更多信息，请参阅第下一章节“多核处理器”。
内存缓存可以通过内外属性分别控制，以适应多级缓存。
内外属性之间的划分是实现定义的，但通常内属性用于处理器集成的缓存，而外属性则通过外部内存总线从处理器导出，因此可能被处理器或集群外部的缓存硬件使用。

共享属性用于定义一个位置是否与多个核心共享。
将一个区域标记为 Non-shareable 意味着它仅由该核心使用，而将其标记为内共享（inner shareable）或外共享（outer shareable），或两者皆是，意味着该位置与其他观察者共享，例如 GPU 或 DMA 设备可以被认为是另一个观察者。
同样，内外属性之间的划分是实现定义的。
这些属性的架构定义使我们能够定义一组观察者，对于这些观察者，共享属性使数据或统一缓存对数据访问透明。
这意味着系统提供硬件一致性管理，使得在内共享域中的两个核心必须看到标记为内共享的位置的一致副本。
如果系统中的处理器或其他主设备不支持一致性，则它必须将共享区域视为非缓存的。

\Figure[caption={内部和外部共享区域}, label={fig:inner-outer-sh-domains}, width=0.8]{inner-outer-sh-domains}

缓存一致性硬件会带来一定的开销。
数据内存访问可能会比原本需要的更长，并且消耗更多的功率。
通过将一致性保持在更少的主设备之间并确保它们在硅片上物理上靠在一起，可以最小化这种开销。
因此，架构将系统分成域，使得可以将开销限制在仅需要一致性的位置。

以下是可用的共享性域选项：

\begin{description}
\item
  [非共享] 表示仅由单个处理器或其他代理访问的内存，因此内存访问永远不需要与其他处理器同步。
  这种域通常不用于 SMP 系统。
\item
  [内部共享] 表示可以由多个处理器共享的共享性域，但不一定是系统中所有代理。
  系统可能具有多个内部共享性域。
  影响一个内部共享性域的操作不会影响系统中的其他内部共享性域。
  这样一个域的示例可能是一个四核 Cortex-A57 集群。
\item
  [外部共享] 外部共享（OSH）域被多个代理共享，可以由一个或多个内部共享域组成。
  影响外部共享域的操作也会隐含地影响其中所有的内部共享域。
  但是，它在其他方面不会像内部共享操作那样行为。
\item
  [完整系统] 在完整系统上的操作会影响系统中的所有观察者。
\end{description}

