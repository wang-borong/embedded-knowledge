\subsection{Caches}\label{sec:caches}

ARM 架构开发初期，处理器的速度和访问内存的速度大体相近。
当今的处理器核心的运行速度要比内存访问速度快上许多。
然而，外部总线和存储设备的频率并没有达到与处理器相同的程度，所以可以在芯片内部实现一些与处理器内核同等速度的 RAM。
不过这些 RAM 与 DRAM 比起来非常昂贵，相比起来，DRAM 一般拥有数千倍以上的容量。
ARM 架构下，访问外部 ram 通常需要数十个处理器周期，甚至数千个。

Cache 是一个小型的快速的内存块，它存在于主内存和处理器之间，保存有主内存中的数据缓存。
访问 Cache 的速度比访问外存快很多。
处理核需要读取或者写入一个特定地址时，先去查看 Cache 里面有没有保存该地址的数据。
如果 Cache 找到该地址，那么它就使用 Cache 中的数据，并不再访问主内存。
由于减少了对外部内存的访问次数所以大大增加了系统的潜在性能。
另外，由于避免了驱动外部信号所以也减少了系统的功耗。

\Figure[caption={Cache 的基本组成}, label={fig:basic-cache-arrangement}]{basic-cache-arrangement}

ARMv8 架构处理器一般有 2 - 3 级 cache，通常每个 CPU 核都含有较小的一级 I-Cache 和 D-Cache。
基于 Cortex-A53 和 Cortex-A57 的处理器一般有 2 级及以上的 Cache，即较小的一级 I-Cache 和 D-Cache，以及更大的 Cluster 共享的二级 Cache。
另外，还可以增加 Cluster 之间共享的更大的 3 级 Cache。

系统初始状态访问数据不会得到加速，此时 Cache 也需要填充从内存中读取的数据。
然而，当 Cache 中缓存了一定量的数据，系统再次需要这些数据时，Cache 的加速功能便显现出来。
处理器在取指令或数据读写时先去检查 Cache，但是有一部分内存地址必须要标记为不可缓存的，比如外设寄存器地址空间。
由于 Cache 中只能缓存一小部分主存数据，所以必须要想出一种高效的方式来快速检测数据是否在 Cache 中。

有时，Cache 中的数据和外部主存的数据会出现不一致。
可能的情况有，处理器更新了 Cache 中的数据，但是还没有写回主存；
或者，某个硬件机构在处理器获取主存的数据后更改了主存中的数据，例如 DMA。
这种数据一致性的问题将在后续章节继续讲述。
这种问题在多核和有 DMA 的情况下特别需要注重。

\subsubsection{Cache 术语}

Von Neumann 架构定义单个 Cache 用于指令和数据的缓存（统一 Cache）。
Harvard 架构更新了该种形式，提出 I-Cache 和 D-Cache 分开缓存指令和数据的形式。
ARMv8 架构则在 L1 Cache 中使用 Harvard 形式，更高级使用统一的 Cache。

Cache 需要保存地址、数据和一些状态信息。

下图简略描述了 Cache 的术语及基础框架。

\Figure[caption={Cache 术语}, label={fig:cache-terminology}]{cache-terminology}

\begin{itemize}
  \item \textit{tag} 是保存在 Cache 中的部分内存地址，这部分地址用于连系内存地址和 Cache line。
    64 位内存地址的高字段告诉 Cache 数据信息在内存中的来源，该高字段即称为 \textit{tag}。
    总缓存大小衡量的是它可以保存的数据量，但用于保存 \textit{tag} 的 RAM 不包括在计算中。
    然而，tag 仍然是占用物理空间的。
  \item 如果每个 tag 下只存放一个 word，那么 tag 所占的比重就太大了，导致 Cache 的利用率很低。
    所以就定义了每个 tag 下可以存放 \textit{Cache line} 大小的数据。
    Cache line 是 Cache 可以提供的最小数据量，并且 Cache line 中保存的数据是内存中连续的数据 word。
    当 Cache line 中存有指令或数据时，称为有效（valid），反之则为无效（invalid）。

    Cache line 数据相关联有一个或多个状态位。
    通常，有一个有效位表明 Cache line 是否存在有效数据，意味着 tag 中含有真是数据。
    D-Cache 中也可能含有污染（dirty）位，用以表明该 Cache line 中的数据（或部分数据）与主存中数据是否不同（比其更新）。
  \item \textit{way} 是 Cache 的细分，每个 way 都具有相同的大小，相同的索引方式。
    \textit{set} 由所有 way 中的所有具有相同索引方式的 line 组成。
  \item 地址中的低字段（做为 offset），则不需要保存到 tag 中。
    Cache 给出的是一行（cache line）数据，所以地址中有 5 到 6 个最低有效位恒为 0（也就是说 cache line 有 $2^5$ - $2^6$ 个 byte）。
\end{itemize}

\paragraph*{组（Set）相连 Cache 和 way}

ARM 架构下的 Cache 基本都是组相连的，这种类型的 Cache 极大的减少了直接映射型 Cache 的抖动（thrashing）问题\footnote{
Where main memory is accessed in a pattern that leads to multiple main memory locations competing for the same cache lines, resulting in excessive cache misses.
This is most problematic for caches that have low associativity.
 }，从而提升程序的执行速度并且增加了更多可预测的执行。
不过，该种类型的 Cache 也会增加硬件的复杂度和略微增加功耗，这是由于每个 cycle 下会比较多个 tag。

在这种类型的 Cache 组织方式下，Cache 被分成许多大小相同的块，这些块就是 \textit{way}。
那么内存地址便可以映射到 way，而不是 line 上。
可以使用地址中的索引字段继续选择特定的 line，但是此时它指向的是每个 way 中的单独 line。
通常，L1 Cache 中有 2 - 4 路，Contex-A57 则有 3-way 的 L1 I-Cache。
而 L2 Cache 通常有 16 路。

外部的 L3 Cache 的大小更大，所以有更多路，因此有更高的关联性。
具有相同索引值的 line 属于同一 set，于是检查是否命中需要查看 set 中的所有 tag。

下图是一个 2-way 相连的 Cache。
主存中的 0x00、0x40 和 0x80 可能出现在其中一路中，但是不会同时存在于两路中。

\Figure[caption={2-way 组相连 Cache}, label={fig:2-way-set-associative-cache}]{2-way-set-associative-cache}

关联性的增加（即增加 way 数）可以降低 thrashing 的概率。
最理想的情况是全相连 Cache，即主存和 Cache 一一映射，每个地址都能找到对应。
如果不是想缓存很少的数据来说（例如 TLB），构建这样的 Cache 是不现实的。
实际上，8-way 以上的对与性能来说提升很小，16-way 的关联性对于更大的 L2 才更有用。

\paragraph*{tag 和 物理地址}

一个 tag 对应一条 line，用于记录关联于 line 的外部内存物理地址。
Cache line 的大小是由\textbf{实现决定的}，但是所有的 CPU 核都具有相同的 Cache line 大小，因为这些核之间是相互连系的。

要访问的物理地址决定数据缓存在 Cache 中的位置。
最低有效字段用于选择 Cache 中的相关条目。
中间字段用于选择 set 中的特定 line。
最高有效字段标识地址的剩余部分，并与保存的 tag 进行比较。
ARMv8 下数据 Cache 通常是 \textit{Physically Indexed, Physically Tagged}（PIPT），也可以是 non-aliasing \textit{Virtually Indexed, Physically Tagged}（VIPT）。

Cache line 包含以下成员：

\begin{itemize}
  \item 关联物理地址中的 tag 值。
  \item 表明 line 是否存在的有效位，亦即 tag 是否有效。
    如果缓存在多个核心之间是一致的，有效位也可以是 MESI 状态的状态位。
  \item 表明 Cache line 与外部内存不一致的 dirty 位。
\end{itemize}

一个简单的 4 路组相连的 32KB L1 D-Cache 如下所示，该 Cache 的 line 大小为 16-word（64 byte）。

\Figure[caption={32KB 4-way D-Cache}, label={fig:32KB-4-way-D-Cache}]{32KB-4-way-D-Cache}

\paragraph*{包容或排它 Cache}

包容型 Cache 即数据可以同时存在与 L1 和 L2 Cache 中。
排它型 Cache 即数据只能同时存在于单级 Cache，同一地址不可能同时在 L1 和 L2 中出现。

\subsubsection{Cache 控制器}

Cache 控制器负责管理 Cache 缓存，它对于应用程序来说几乎是透明的。
它自动的将内存中的代码或数据写入到 Cache 中。
它从处理器核处获取内存读写请求并且执行必要的 Cache 缓存或外部内存操作。

它收到处理核的请求命令后，首先检查该请求地址是否在 Cache 中，这个步骤称为 \textit{cache look-up}。
它将请求中的部分地址位与 Cache line 对应的 tag 进行比对来完成 \textit{cache look-up} 操作。
如果上述对比成功，那么说明 Cache 中存在匹配 line，称为命中（hit），并且控制器将该行标注为有效（valid），从而使用 Cache 缓存作为对写请求的数据来源。

当读写请求无法从 Cache 中找到匹配的 tag，或者 tag 是无效的，那么即产生 Cache 未命中（miss）。
此时，请求必须传给下一级内存层级 L2 Cache，或外部内存。
这将产生一个 cache line 填充（cahe linefill），即将内存中的数据拷贝到 cache 中。
请求的数据或指令流也会同时发送给处理核。
该过程对于软件开发人员是透明的，是不直接可见的。
处理核不用等到 cache line 填充完数据才能使用。
Cache 控制器通常先从 cache line 中获取关键字（\textit{critical word}）。
例如，当执行一个加载指令而发生 cahce miss 并产生一个 cache linefill 时，CPU 核先从 cache line 中获取部分请求的数据。
这部分关键数据先提供给 CPU 核的流水线（pipeline），然后 Cache 和外部总线接口在后台读取 cache line 中剩余的数据。

\subsubsection{缓存策略}

Cache 策略简而言之就是，数据 Cache 何时需要申请 line；
存储指令执行时并且数据 Cache 命中后应该发生什么事情。

Cache 的分配机制有以下几种：

\begin{description}
  \item[Write allocation (WA)] 在写未命中时分配 cache line。
    这意味 CPU 执行存储指令时会发生读操作。
    在写操作执行前，cache 会先获取数据填充对应的 cache line。
    即使只是写入一个 byte，Cache 中也会保存一个完整行，因为这是它的最小单元。
  
  \item[Read allocation (RA)] 在读为命中时分配 cache line。
\end{description}

Cache 更新机制有：

\begin{description}
  \item[Write-back (WB)] 写时更新 Cache，并且只会将 cache line 标记为污染（dirty）。
    外部内存只在该行被驱逐出去或明确的清理操作发生时更新。
  
  \item[Write-through (WT)] 写时更新 Cache 和外部内存。
    该机制不会标注 cache line 为污染。
\end{description}

两种更新机制的数据读操作命中时的 Cache 行为相同。

普通内存的可缓存属性分为 \textit{inner} 和 \textit{outer} 属性。
至于这两种属性的范围是\textbf{由实现所决定的}。
一般来说，inner 属性用于集成 Cache（CPU 核内集成的 Cache），outer 属性可在处理器内存总线上供外部 Cache 使用。

\Figure[caption={内存的可缓存属性}, label={fig:cacheable-properties-of-memory}, width=0.8]{cacheable-properties-of-memory}

处理器可以预测式的访问普通内存，也就是说处理器可以自动暗中加载数据到 cache 中。
这个行为并不需要开发人员的干涉，也无需指定请求地址。
当然，开发人员也可以暗示处理器哪些数据将被使用。
ARMv8 提供的预加载暗示（hint）指令。
但是 cache 是否支持预测和预加载是由\textbf{实现决定}。
下面的指令是架构提供的：

\begin{description}
  \item[AArch64] \lstinline!PRFM PLDL1KEEP, [Xm, #imm]! 意思是将 \lstinline!Xm + offset! 的数据加载到 L1 缓存中作为临时预取，这意味着数据可能会被使用多次。
  \item[AArch32] \lstinline!PLD Rm! 将数据从 Rm 中的地址预加载到缓存。
\end{description}

A64 预取内存指令更一般的形式：

\begin{lstcode}
  PRFM <prfop>, addr

  Where:

  <prfop>     <type><target><policy> | #uimm5
  <type>      PLD for prefetch for load
              PST for prefetch for store
  <target>    L1 for L1 cache, L2 for L2 cache, L3 for L3 cache
  <policy>    KEEP for retain or temporal prefetch means allocate in cache
              normally
              STRM for streaming or non-temporal prefetch means the memory
              is used only once
  uimm5       Represents the hint encodings as a 5-bit immediate.
              These are optional.
\end{lstcode}

\subsubsection{POC 和 POU}

对于基于 set 和基于 way 的 cache 清理和 invalidate 来说，操作是施加到指定 cache 级上的。
对于使用虚拟地址的操作，该架构定义两个观察点。

\begin{description}
  \item[\textit{Point of Coherency} (PoC)] 对于一个特定的地址，PoC 是所有观察者的点，例如，处理器、DSP 或 DMA 引擎等可以访问内存的单元，这些单元都确保可以在一个内存地址下看到同样的数据。
    通常这个观察点为外部内存。
  \item[\textit{Point of Unification} (POU)] PoU 是指令和数据 Cache 和 TLB 在内存地址可以看到的相同数据。
    例如，L2 Cache 即为 Harvard 架构的一级 Cache 和 TLB 可见的相同点。
    如果没有 L2 等外部 cache，那么内存则为 PoU。
\end{description}

了解 PoU 可以确保在取指修改后的代码时的正确性。
可以通过以下两个阶段的来处理：

\begin{itemize}
  \item 通过地址来清理相关的数据 cache 条目。
  \item 通过地址来无效指令 cache 条目。
\end{itemize}

即使对于共享内存地址来说，ARM 架构也不需要硬件来确保指令 cache 和内存的一致性。

\subsubsection{Cache 维护}

有时在软件中清除和无效 cache 是必要的。
在外部内存已经发生改变这种操作可能就是必要的，并且这时需要从 cache 中把陈旧的数据移除掉。
在 MMU 相关的活动后也有必要进行上述的 cache 操作，比如：改变内存访问权限、cache 策略或虚拟地址到物理地址的映射，或者诸如 JIT 和动态库加载产生动态代码时必须要进行指令和数据 cache 同步。

\begin{itemize}
  \item 无效 cache 或 cache line 意味着清除它的数据，即清除 cache line 中的有效位。
    \textbf{初始化后必须要无效 cache，因为此时数据是未定义的。}
    这也可以被看作是一种使缓存外的内存域中的更改对缓存的使用者可见的方式。
  \item 清理缓存或缓存行意味着将标记为污染的数据写入到下一级缓存或主内存中，并清除缓存行中的污染位。
    这使得缓存行的内容与下一级缓存或内存系统保持一致。
    这仅适用于使用写回策略的数据缓存。
    这也是使缓存中的更改对外部内存域的用户可见的一种方式，但仅适用于数据缓存。
  \item 清零。
    这会在缓存内将一块内存清零，而无需先从外部域读取其内容，仅适用于数据缓存。
\end{itemize}

您可以选择哪些条目需要应用于这些操作：

\begin{description}
  \item[All] 指整个缓存，不适用于数据缓存或统一缓存。
  \item[\textit{Modified Virtual Address} (MVA)] 是虚拟地址 (VA) 的另一种名称，是指包含特定虚拟地址的缓存行。
  \item[Set or Way] 指通过其在缓存结构中的位置选定的特定缓存行。
\end{description}

AArch64 缓存维护操作使用具有以下一般形式的指令执行：

\lstinline!<cache> <operation>{, <Xt>}!

有多种操作可用。

\begin{ltblr}[caption={数据、指令和统一缓存的操作}, label={tbl:diu-cache-ops}]
  {colspec={cc>{\centering\arraybackslash}Xc}}
  \hline[1pt]
  Cache & 操作 & 描述 & AArch32 等效\\
  \hline
     & CISW & Clean and invalidate by Set/Way & DCCISW \\ 
     & CIVAC & Clean and Invalidate by Virtual Address to Point of Coherency & DCCIMVAC \\
     & CSW & Clean by Set/Way & DCCSW \\
  DC & CVAC & Clean by Virtual Address to Point of Coherency & DCCMVAC \\
     & CVAU & Clean by Virtual Address to Point of Unification & DCCMVAU \\
     & ISW & Invalidate by Set/Way & DCISW \\
     & IVAC & Invalidate by Virtual Address, to Point of Coherency & DCIMVAC \\
  \hline
  DC &  ZVA & Cache zero by Virtual Address & - \\
  \hline
     & IALLUIS & Invalidate all, to Point of Unification, Inner Sharable & ICIALLUIS \\
  IC & IALLU & Invalidate all, to Point of Unification, Inner Shareable & ICIALLU \\
     & IVAU & Invalidate by Virtual Address to Point of Unification & ICIMVAU \\
  \hline[1pt]
\end{ltblr}

那些接受地址参数的指令使用一个 64 位寄存器，该寄存器保存要维护的虚拟地址。
该地址没有对齐限制。
接受组 / 路 / 级别参数的指令，使用一个 64 位寄存器，其低 32 位遵循 ARMv7 架构中描述的格式。
AArch64 数据缓存失效指令，\lstinline!DC IVAC!，需要写入权限，否则会生成权限故障。

所有指令缓存维护指令可以以任何顺序执行，相对于其他指令缓存维护指令、数据缓存维护指令和加载存储指令，除非在指令之间执行了 DSB。

除了 \lstinline!DC ZVA! 之外的数据缓存操作，如果它们指定了一个地址，只有在它们指定相同地址时，才保证按程序顺序执行。
指定地址的那些操作，相对于不指定地址的所有维护操作，按程序顺序执行。

考虑以下代码。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={对于 PoU 的 cache 无效和清理操作},
  label={lst:cache-ic-pou}
]
IC IVAU, X0  // Instruction Cache Invalidate by address to Point of Unification
DC CVAC, X0  // Data Cache Clean by address to Point of Coherency
IC IVAU, X1  // Might be out of order relative to the previous operations if
             // x0 and x1 differ
\end{lstlisting}

前两条指令按顺序执行，因为它们引用相同的地址。
然而，最后一条指令可能相对于前面的操作重新排序，因为它引用了不同的地址。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={对于 PoU 的 cache 无效操作},
  label={lst:cache-i-pou}
]
IC IVAU, X0  // I cache Invalidate by address to Point of Unification
IC IALLU     // I cache Invalidate All to Point of Unification
             // Operations execute in order
\end{lstlisting}

这仅适用于发出指令。
只有在执行 DSB 指令后才能确保完成。

在 ARMv8-A 中，使用 \lstinline!DC ZVA! 指令预加载数据缓存的零值是一项新功能。
处理器的运行速度通常显著快于外部内存系统，有时从内存加载缓存行可能需要很长时间。

缓存行清零的行为类似于预取，它是一种提示处理器未来可能会使用某些地址的方式。
然而，清零操作可能会更快，因为不需要等待外部内存访问完成。
与从内存读取实际数据到缓存不同，您会得到填充了零的缓存行。
它可以提示处理器，代码完全覆盖了缓存行的内容，因此不需要初始读取。

考虑这样一种情况：您需要一个大的临时存储缓冲区，或者正在初始化一个新的结构。
您可以让代码直接开始使用内存，或者在使用之前预取它。
两者都会消耗大量的周期和内存带宽来读取初始内容到缓存中。
通过使用缓存清零选项，您可能可以节省这种浪费的带宽，并且让代码执行得更快。

缓存维护指令执行的时机可以根据指令是通过虚拟地址 (VA) 还是通过组 / 路 (Set/Way) 操作而定。

您可以选择作用域，可以是 PoC 或 PoU，对于可以广播的操作，您可以选择共享性。

以下示例代码展示了一种通用机制，用于将整个数据缓存或统一缓存清理（对于 PoC）。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={对于 PoC 的 cache 清除操作},
  label={lst:clean-cache-poc}
]
       MRS X0, CLIDR_EL1
       AND W3, W0, #0x07000000  // Get 2 x Level of Coherence
       LSR W3, W3, #23
       CBZ W3, Finished
       MOV W10, #0              // W10 = 2 x cache level
       MOV W8, #1               // W8 = constant 0b1
Loop1: ADD W2, W10, W10, LSR #1 // Calculate 3 x cache level
       LSR W1, W0, W2           // extract 3-bit cache type for this level
       AND W1, W1, #0x7
       CMP W1, #2
       B.LT Skip                // No data or unified cache at this level
       MSR CSSELR_EL1, X10      // Select this cache level
       ISB                      // Synchronize change of CSSELR
       MRS X1, CCSIDR_EL1       // Read CCSIDR
       AND W2, W1, #7           // W2 = log2(linelen)-4
       ADD W2, W2, #4           // W2 = log2(linelen)
       UBFX W4, W1, #3, #10     // W4 = max way number, right aligned
       CLZ W5, W4               /* W5 = 32-log2(ways), bit position of way in
                                   DC operand */
       LSL W9, W4, W5           /* W9 = max way number, aligned to position in
                                   DC operand */
       LSL W16, W8, W5          // W16 = amount to decrement way number per
                                // iteration
Loop2: UBFX W7, W1, #13, #15    // W7 = max set number, right aligned
       LSL W7, W7, W2           /* W7 = max set number, aligned to position in
                                   DC operand */
       LSL W17, W8, W2          // W17 = amount to decrement set number per
                                // iteration
       Loop3: ORR W11, W10, W9  // W11 = combine way number and cache number...
       ORR W11, W11, W7         // ... and set number for DC operand
       DC CSW, X11              // Do data cache clean by set and way
       SUBS W7, W7, W17         // Decrement set number
       B.GE Loop3
       SUBS X9, X9, X16         // Decrement way number
       B.GE Loop2
Skip: ADD W10, W10, #2          // Increment 2 x cache level
       CMP W3, W10
       DSB                      /* Ensure completion of previous cache
                                   maintenance operation */
       B.GT Loop1
\end{lstlisting}

一些需要注意的要点：

\begin{itemize}
  \item 在正常情况下，清理或使整个缓存失效是固件应该执行的任务之一，作为核心上电或关机代码序列的一部分。
  这可能需要相当长的时间，因为 L2 缓存中的行数可能相当多，需要逐个遍历它们。

    因此，这种清理绝对是为特殊场合准备的！
  \item 缓存维护操作，如 \lstinline!DC CSW!，在上述节中有描述。
  \item 在代码序列开始时必须禁用缓存，以防止在序列中段分配新行。
  如果缓存是排它性的，行可能会在级别之间迁移。
  \item 在 SMP 系统中，另一个核心可能会在序列中段从缓存中获取脏缓存行，阻止它们到达 PoC。
  Cortex-A53 和 Cortex-A7 处理器都可以做到这一点。
  \item 如果存在 EL3，则必须从安全世界使缓存失效，因为某些条目可能是“安全脏”数据，不能从普通世界使其失效。
  如果不处理，“安全脏”数据在被驱逐时可能会破坏内存系统，因为在安全世界或普通世界中进行正常缓存使用。
\end{itemize}

如果软件需要在指令执行和内存之间保持一致性，它必须使用 ISB 和 DSB 内存屏障以及缓存维护指令来管理这种一致性。
下面的代码序列可用于此目的。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={清理一行自改代码},
  label={lst:clean-one-line}
]
/* Coherency example for data and instruction accesses within the same Inner
Shareable domain. Enter this code with <Wt> containing a new 32-bit instruction,
to be held in Cacheable space at a location pointed to by Xn. */
STR Wt, [Xn]
DC CVAU, Xn // Clean data cache by VA to point of unification (PoU)
DSB ISH     // Ensure visibility of the data cleaned from cache
IC IVAU, Xn // Invalidate instruction cache by VA to PoU
DSB ISH     // Ensure completion of the invalidations
ISB         // Synchronize the fetched instruction stream
\end{lstlisting}

这个代码序列仅适用于适合单个 I 或 D 缓存行的指令序列。

该代码根据给定的起始基地址（存储在寄存器 x0 中）和长度（存储在寄存器 x1 中），对指定区域的数据和指令缓存进行虚拟地址清理和失效操作。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={通过虚拟地址清理 cache},
  label={lst:clean-cache-by-virt}
]

//
// X0 = base address
// X1 = length (we assume the length is not 0)
//

// Calculate end of the region
ADD x1, x1, x0  // Base Address + Length
//
// Clean the data cache by MVA
//
MRS X2, CTR_EL0 // Read Cache Type Register

// Get the minimun data cache line
//

UBFX X4, X2, #16, #4 // Extract DminLine (log2 of the cache line)
MOV X3, #4           // Dminline iss the number of words (4 bytes)
LSL X3, X3, X4       // X3 should contain the cache line
SUB X4, X3, #1       // get the mask for the cache line

BIC X4, X0, X4       // Aligned the base address of the region
clean data cache:
DC CVAU, X4          // Clean data cache line by VA to PoU
ADD X4, X4, X3       // Next cache line
CMP X4, X1           // Is X4 (current cache line) smaller than the end
                     // of the region
B.LT clean_data_cache // while (address < end_address)

DSB ISH              // Ensure visibility of the data cleaned from cache

//
//Clean the instruction cache by VA
//
// Get the minimum instruction cache line (X2 contains ctr_el0)
AND X2, X2, #0xF  // Extract IminLine (log2 of the cache line)
MOV X3, #4        // IminLine is the number of words (4 bytes)
LSL X3, X3, X2    // X3 should contain the cache line
SUB x4, x3, #1    // Get the mask for the cache line

BIC X4, X0, X4    // Aligned the base address of the region
clean_instruction_cache:
IC IVAU, X4       // Clean instruction cache line by VA to PoU
ADD X4, X4, X3    // Next cache line
CMP X4, X1        // Is X4 (current cache line) smaller than the end
                  // of the region
B.LT clean_instruction_cache // while (address < end_address)

DSB ISB           // Ensure completion of the invalidations
ISH               // Synchronize the fetched instruction stream
\end{lstlisting}

\subsubsection{Cache 探测}

缓存维护操作可以通过缓存集、路或虚拟地址进行。
与平台无关的代码可能需要了解缓存的大小、缓存行的大小、集合和路的数量，以及系统中有多少级缓存。
这种需求最有可能出现在后重置的缓存失效和清零操作中。
在架构缓存上的所有其他操作很可能是基于 PoC 或 PoU 进行的。

有一些系统控制寄存器包含了这些信息：

\begin{itemize}
  \item 软件可以通过读取缓存级别 ID 寄存器（\lstinline!CLIDR_EL1!）来确定存在的缓存级别数量。
  \item Cache line 大小可以在缓存类型寄存器中获取（\lstinline!CTR_EL0!）。
  \item 如果需要由在执行级别 EL0 运行的用户代码访问，可以通过设置系统控制寄存器（\lstinline!SCTLR/SCTLR_EL1!）的 UCT 位来实现。
\end{itemize}

要确定缓存中的集合数量（set）和路数（way），需要对两个单独的寄存器进行异常级别的访问。

\begin{enumerate}
  \item 代码必须首先写入缓存大小选择寄存器（\lstinline!CSSELR_EL1!），以选择要获取信息的缓存。
  \item 然后，代码读取缓存大小 ID 寄存器（\lstinline!CCSIDR/CCSIDR_EL1!）。
  \item 数据缓存零 ID 寄存器（\lstinline!DCZID_EL0!）包含用于零操作的块大小。
  \item \lstinline!SCTLR/SCTLR_EL1! 中的 \lstinline![DZE]! 位和 Hypervisor Configuration Register (\lstinline!HCR/HCR_EL2!) 中的\lstinline![TDZ]!位控制哪些执行级别和哪些世界可以访问 \lstinline!DCZID_EL0!。
    \lstinline!CLIDR_EL1!、\lstinline!CSSELR_EL1! 和 \lstinline!CCSIDR_EL1! 只能通过特权代码访问，即在 AArch32 中为 PL1 或更高级别，在 AArch64 中为 EL1 或更高级别。
  \item 如果在异常级别上禁止执行通过虚拟地址进行数据缓存零操作（\lstinline!DC ZVA!）指令，例如通过 \lstinline!SCTLR_EL1.DZE! 位控制 EL0 级别，或通过 \lstinline!HCR_EL2.TDZ! 位控制 EL1 和 EL0 级别的非安全执行，则读取此寄存器会返回一个指示不支持该指令的值。

  \item \lstinline!CLIDR! 寄存器只知道集成到处理器本身中的缓存有多少级。
  它无法提供关于外部内存系统中的任何缓存的信息。

    例如，如果仅集成了 L1 和 L2，则 \lstinline!CLIDR/CLIDR_EL1! 标识了两个级别的缓存，处理器不知道任何外部 L3 缓存。

    在执行缓存维护操作或维护与集成缓存的一致性的代码时，可能需要考虑非集成缓存。
\end{enumerate}

\Figure[caption={缓存探测}, label={fig:cache-discovery}, width=0.2]{cache-discovery}

此外，在 big.LITTLE 系统中，描述的缓存层次结构可能会因核心而异，例如，Cortex-A53 和 Cortex-A57 处理器具有不同的 \lstinline!CTR.L1IP! 字段。
