\subsection{ISA 概述}

ARMv8 架构中引入的最重要的变化之一是增加了 64 位指令集。
该指令集补充了现有的 32 位指令集架构。
这一指令集提供了对 64 位宽整数寄存器和数据操作的访问，以及使用 64 位内存指针的能力。
新的指令集被称为 A64，并且在 AArch64 状态下执行。
ARMv8 架构还包括原始的 ARM 指令集（现称为 A32）和 Thumb（T32）指令集。
A32 和 T32 都以 AArch32 状态执行，并且向后与 ARMv7 架构兼容。

虽然 ARMv8-A 向后兼容了 32 位 ARM 架构的特性，但 A64 指令集与旧的 ISA 指令是独立且不同的，而且他们的编码方式也不同。
A64 增加了一些额外的功能，同时也删除了影响高性能或功耗的功能。
ARMv8 架构还包括对 32 位指令集（A32 和 T32）的一些增强性功能。
然而，使用这些功能的代码与旧的 ARMv7 不兼容。
需要注意的是，A64 指令集中的指令操作码长度仍然是 32 位，而不是 64 位。

\subsubsection{ARMv8 指令集简介}

新的 A64 指令集与 A32 类似，都是 32 bit 宽度，并且语法类似。
该指令集使用通用的命名，原先的 32-bit 指令集则称为 A32 和 T32（16-bit 指令，以性能换空间）。
运行在 AArch64 新的指令集（64-bit 操作）则命名为 A64。

A64 指令集有两种整型指令形式，即通用寄存器保存 32-bit 或是 64-bit 值。
当查看指令中的寄存器名称时，如果是 X 开头则使用的是 64-bit 值；
W 开头则是 32-bit 值。
当使用 32-bit 形式时，会有以下体现：
\begin{itemize}
  \item 右移和旋转操作止于 31 位，而非 63 位。
  \item 由指令设置的状态标志是从低 32 位里计算而来。
  \item 向 W 寄存器写入时，X 寄存器的 $[63:32]$ 位自动设为 0。
\end{itemize}

64-bit 指令集极大扩展了地址空间。
因此，在程序中访问大量内存变得更加简单。
在 32-bit 的 CPU 核上执行一个线程，会将内存的访问限制在 4GB 空间。
大部分地址空间保留给 OS 内核、库代码和外设等成员使用。
所以，程序会面临内存不足的问题，那么程序在执行时可能需要将内存的一些数据映射出去或再映射回来。
拥有更大的内存空间，更大的 64-bit 指针，便可以避免以上问题。
而且类似文件内存映射等技术将更加具有可用性和方便性。
在这种情况下，即使文件的内容大小超出了物理 RAM 的大小，文件内容也可以映射到线程的内存中。

其它改进包括：独占访问、增加相对 PC 的偏移地址、支持未对齐地址、批量传输、加载 / 存储和对齐检查。

在问题~\ref{pb:state_changing} 中，我们分析了如何状态切换。
下面是手册中给出的切换图。

\Figure[caption={Switching between instruction sets}, label={fig:state_changing}, width=0.8]{state_changing}
