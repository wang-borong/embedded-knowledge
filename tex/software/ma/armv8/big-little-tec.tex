\subsection{big.LITTLE 技术}\label{sec:big-little-tec}

现代软件堆栈对移动系统提出了相互冲突的要求。
一方面，对于像游戏这样的任务，需要非常高的性能，而另一方面，需要对能源储备进行节约，以满足像音频播放这样的低强度应用的需求。
传统上，很难设计出一种能够既具有高峰值性能又具有高能效性的单一处理器设计。
这意味着大量的能源被浪费，因为高性能内核会被用于低强度任务，导致电池寿命缩短。
性能本身受到核心可以持续运行的热限制的影响。

ARM 的 big.LITTLE 技术通过将高性能的 big 核与能效高的 LITTLE 核结合起来，解决了这个问题。
big.LITTLE 是异构处理系统的一个例子。
这种系统通常包括几种不同类型的处理器，具有不同的微体系结构，如通用处理器和专用 ASIC。

big.LITTLE 将异构性推向更高一层，因为它包含了具有不同微体系结构但具有兼容指令集体系结构的通用处理器。
一个经常与这种系统一起使用的术语是异构多处理（HMP）。
与不对称多处理（AMP）不同的是，HMP 系统中的所有处理器都是完全一致的，并且运行相同的操作系统映像。
软件可以根据性能要求在 big 或 LITTLE 处理器上运行（或两者兼有）。
当需要峰值性能时，软件可以移至仅在 big 处理器上运行。
对于普通任务，软件可以在 LITTLE 处理器上运行得很好。
通过这种组合，big.LITTLE 提供了一种解决方案，能够在系统的热限制范围内，以最大的能效性提供最新移动设备所需的峰值性能。

\subsubsection{big.LITTLE 系统结构}

在 big.LITTLE 系统中，两种类型的核心都是完全缓存一致的，并且共享相同的指令集架构（ISA）。
相同的应用程序二进制文件可以在任一核心上不经修改地运行。
处理器内部微架构的差异使它们能够提供 big.LITTLE 概念所需的不同功耗和性能特性。
这些通常由操作系统管理。

big.LITTLE 软件模型要求在 big 和 LITTLE 集群之间透明且高效地传输数据。
硬件一致性使这一点对软件来说是透明的。
集群之间的一致性由缓存一致性互连（如第 14 章描述的 ARM CoreLink CCI-400）提供。
如果没有硬件一致性，big 和 LITTLE 核心之间的数据传输将始终通过主内存进行，这会很慢且不节能。
此外，这将需要复杂的缓存管理软件来实现 big 和 LITTLE 集群之间的数据一致性。

此外，这样的系统还需要一个共享的中断控制器，如 GIC-400，使中断可以在集群中的任意核心之间迁移。
所有核心可以通过分布式中断控制器（如 CoreLink GIC-400）互相发送信号。
任务切换通常完全由操作系统调度程序处理，对应用软件是不可见的。
下图展示了一个示例系统。

\Figure[caption={典型 big.LITTLE 系统}, label={fig:typical-big-little-sys}, width=0.6]{typical-big-little-sys}

\subsubsection{big.LITTLE 配置}

多种 big.LITTLE 配置是可能的，上图中使用 Cortex-A57 内核作为 big 集群，Cortex-A53 内核作为 LITTLE 集群，但其他配置也是可能的。

LITTLE 集群能够处理大多数低强度任务，如音频播放、网页滚动、操作系统事件和其他始终在线、始终连接的任务。
因此，软件堆栈可能会一直停留在 LITTLE 集群上，直到运行像游戏或视频处理这样强度较大的任务。

big 集群可以用于高负载任务，例如某些高性能游戏图形。
网页渲染是另一个常见的例子。
这两种集群类型的结合提供了节能的机会，并满足了移动设备上应用程序堆栈日益增长的性能需求。

\subsubsection{big.LITTLE 中的软件执行模型}

big.LITTLE 主要有两种执行模型：

\begin{description}
  \item[{迁移（Migration）}] \hfill \\
    迁移模型是 DVFS 等电源性能管理技术的自然扩展（如动态电压和频率调节，参见第~\ref{sec:pm-state-coordination-if} 章节的动态电压和频率调节）。
    迁移模型有两种类型：

    \begin{itemize}
      \item 集群迁移
      \item CPU 迁移
    \end{itemize}

    迁移操作类似于 DVFS 操作点转换。
    核心的 DVFS 曲线上的操作点根据负载变化进行遍历。
    当当前核心（或集群）达到最高操作点时，如果软件堆栈需要更高的性能，就会执行核心（或集群）迁移操作。
    然后，执行在另一核心（或集群）上继续，遍历该核心（或集群）的操作点。
    当不需要高性能时，执行可以切换回去。

  \item[{全局任务调度}] \hfill \\
    在全局任务调度（参见第~\ref{sec:global-task-sched} 的全局任务调度）中，操作系统任务调度器了解 big 和 LITTLE 核心之间的计算能力差异。
    调度器跟踪每个软件线程的性能需求，并根据这些信息决定使用哪种类型的核心。
    未使用的核心可以关闭。
    与迁移模型相比，这种方法有许多优点。
\end{description}

\BlockDesc{集群迁移}

在任何时刻，只有一个集群（big 或 LITTLE）是活跃的，除非在集群上下文切换到另一个集群期间会有短暂的例外。
为了实现最佳的功耗和性能效率，软件堆栈主要运行在节能的 LITTLE 集群上，仅在需要高性能的短时间内运行在 big 集群上。
此模型要求两个集群中的核心数量相同。

该模型在处理不平衡的软件工作负载时表现不佳，即在一个集群内的核心上负载显著不同的工作负载。
在这种情况下，集群迁移会导致完全切换到 big 集群，即使并非所有核心都需要那种性能水平。
因此，集群迁移不如其他方法受欢迎。

\BlockDesc{CPU 迁移}

在这种模型中，每个 big 核心与一个 LITTLE 核心配对。
在任何时候，每对中的只有一个核心是活跃的，非活跃的核心被关闭。
根据当前的负载情况选择活跃核心。
使用图 16 - 2（第 16 - 5 页）中的例子，操作系统看到的是四个逻辑核心。
每个逻辑核心在物理上可以是 big 核心或 LITTLE 核心。
这个选择由动态电压和频率调节（DVFS）驱动。
该模型要求两个集群中的核心数量相同。

\Figure[caption={CPU 迁移}, label={fig:cpu-migration}, width=0.9]{cpu-migration}

系统主动监控每个核心的负载情况。
当负载较高时，执行上下文被移动到 big 核心；
相反，当负载较低时，执行被移动到 LITTLE 核心。
在任何时候，每对中的只有一个核心可以是活跃的。
当负载从出站核心（负载离开的核心）移动到入站核心（负载到达的核心）时，前者被关闭。
该模型允许在任何时候混合使用 big 和 LITTLE 核心。

\BlockDesc{全局任务调度}\label{sec:global-task-sched}

通过 big.LITTLE 技术的发展，ARM 已经演化出了一系列软件模型，从各种迁移模型到全局任务调度（GTS），后者构成了所有未来 big.LITTLE 技术发展的基础。
ARM 对 GTS 的实现称为 big.LITTLE 多处理（MP）。

在这种模型中，操作系统的任务调度器能够感知 big 核心和 LITTLE 核心之间计算能力的差异。
利用统计数据，调度器跟踪每个软件线程的性能需求，并根据这些信息决定使用哪种类型的核心。
这种模型可以在具有任意数量核心的 big.LITTLE 系统上工作。
如图 16 - 3（第 16 - 5 页）所示。
这种方法相较于迁移模型有许多优势，例如：

\begin{itemize}
\item
  系统可以有不同数量的 big 和 LITTLE 核心。
\item
  与迁移模型不同，任何时候可以有任意数量的核心处于活跃状态。
  如果需要峰值性能，这可以增加可用的最大计算能力。
\item
  可以将 big 集群隔离，用于专门处理密集线程，而轻量线程在 LITTLE 集群上运行。
  这使得重计算任务可以更快完成，因为没有额外的后台线程干扰。
\item
  可以单独将中断目标设定为 big 或 LITTLE 核心。
\end{itemize}

\subsubsection{big.LITTLE MP}

对于 Linux 内核上的 big.LITTLE 多处理（MP），基本要求是调度器决定软件线程何时可以在 LITTLE 核心或 big 核心上运行。
调度器通过将软件线程的跟踪负载与可调负载阈值进行比较来完成这一任务，如下图所示，包括上迁移阈值和下迁移阈值。

\Figure[caption={迁移阈值}, label={fig:migration-thresholds}, width=1]{migration-thresholds}

当一个分配给 LITTLE 核心的线程的跟踪负载平均值超过上迁移阈值时，该线程被视为符合迁移到 big 核心的条件。
相反地，当一个分配给 big 核心的线程的负载平均值下降到低于下迁移阈值时，它被视为符合迁移到 LITTLE 核心的条件。
在big.LITTLE MP 中，这些基本规则决定了任务在 big 核心和 LITTLE 核心之间的迁移。
在集群内部，标准的 Linux 调度器负载均衡适用。
这试图在一个集群的所有核心之间保持负载平衡。

该模型通过根据核心当前的频率调整跟踪负载指标来进行优化。
当核心以一半的速度运行时，正在运行的任务以一半的速度累积跟踪负载，如果核心以全速运行，该任务的跟踪负载将以全速累积。
这使得 big.LITTLE MP 和 DVFS 管理可以协同工作。

big.LITTLE MP 使用多种机制来确定何时在 big 核心和 LITTLE 核心之间迁移任务：

\BlockDesc{fork 迁移}

这种机制在使用 fork 系统调用创建新的软件线程时起作用。
在这一点上，显然没有可用的历史负载信息。
系统默认将新线程分配到 big 核心，假设轻量线程通过唤醒迁移迅速迁移到 LITTLE 核心。

fork 迁移使要求严格的任务受益而不会造成昂贵的开销。
低强度和持续的线程，如 Android 系统服务，在创建时仅移动到 big 核心，随后迅速移动到更适合的 LITTLE 核心。
明显要求持续性性能的线程不会因为被强制在 LITTLE 核心上启动而产生不利影响。
偶尔运行但倾向于需要性能的线程受益于在 big 集群上启动，并根据需要继续在那里运行。

\BlockDesc{Wake 迁移}

当先前处于空闲状态的任务准备运行时，调度器必须决定哪个集群执行该任务。
为了在 big 和 LITTLE 之间做出选择，big.LITTLE MP 使用了任务的跟踪负载历史。
通常情况下，假设任务在同一集群上恢复运行。
对于正在睡眠的任务，负载指标不会更新。
因此，在调度器在唤醒时检查任务的负载指标之前，在选择要在哪个集群上执行任务时，该指标的值与任务上次运行时的值相同。
这一特性意味着足够繁忙的任务总是倾向于在 big 核心上唤醒。
例如，音频播放任务周期性地繁忙。
但这通常是一个不苛刻的任务，因此总体负载可能很容易适应 LITTLE 核心。
要改变集群，任务必须实际修改其行为。

\Figure[caption={在大核上唤醒迁移}, label={fig:wake-mig-on-big-core}, width=1]{wake-mig-on-big-core}

\Figure[caption={在小核上唤醒迁移}, label={fig:wake-mig-on-lit-core}, width=1]{wake-mig-on-lit-core}

如果一个任务修改了其行为，并且负载指标越过了上迁移或下迁移阈值中的任何一个，那么该任务可以被分配到一个不同的集群。
图~\ref{fig:wake-mig-on-big-core} 和图~\ref{fig:wake-mig-on-lit-core} 说明了这个过程。
有一些规则被定义，以确保 big 核心通常只运行一个高强度的线程，并将其运行到完成，因此向上迁移只会发生在空闲的 big 核心上。
当向下迁移时，这个规则不适用，可以将多个软件线程分配给一个 LITTLE 核心。

\BlockDesc{强制迁移}

强制迁移处理了长时间运行的软件线程不休眠或很少休眠的问题。
调度器定期检查每个 LITTLE 核心上正在运行的当前线程。
如果跟踪的负载超过上迁移阈值，则任务被转移到一个 big 核心上，如下图所示。

\Figure[caption={强制迁移}, label={fig:force-mig}, width=0.8]{force-mig}

\BlockDesc{Idle pull 迁移}

空闲拉动（Idle pull）迁移旨在充分利用活跃的 big 核心。
当一个 big 核心没有任务可运行时，会检查所有 LITTLE 核心，看看 LITTLE 核心上当前运行的任务是否具有比上迁移阈值更高的负载指标。
这样的任务可以立即迁移到空闲的 big 核心上。
如果没有找到合适的任务，那么该 big 核心可以被关闭电源。
这种技术确保了 big 核心在运行时始终承担系统中最密集的任务，并将它们运行到完成。

\BlockDesc{Offload 迁移}

离载（Offload）迁移要求禁用正常的调度器负载平衡。
这样做的缺点是，长时间运行的线程可能会集中在 big 核心上，导致 LITTLE 核心处于空闲和低利用状态。
在这种情况下，通过利用所有核心，可以明显改善整体系统性能。

离载迁移定期将线程向下迁移到 LITTLE 核心，以利用未使用的计算容量。
以这种方式向下迁移的线程仍然是在下一次调度机会时超过阈值的向上迁移的候选项。
