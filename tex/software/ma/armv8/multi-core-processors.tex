\subsection{多核处理器}

ARMv8-A 架构为包含多个处理单元的系统提供了显著的支持。
像 Cortex-A57 的 MPCore 和 Cortex-A53 的 MPCore 这样的 ARM 多核处理器可以包含一到四个核心。
使用 Cortex-A57 或 Cortex-A53 处理器的系统几乎总是以这种方式实现。
一个多核处理器可能包含几个能够独立执行指令的核心，这些核心可以被视为一个单元或集群。
ARM 的多核技术使得集群内的任何一个组成核心在不使用时可以关闭以节省功耗，例如当设备负载较轻或处于待机模式时。
当需要更高性能时，所有处理器都在使用以满足需求，同时共享工作负载以保持尽可能低的功耗。

多处理可以定义为在包含两个或多个核心的单个设备内同时运行两个或多个指令序列。
这种技术现在被广泛应用于用于通用应用处理器的系统以及更传统定义的嵌入式系统中。

多核系统的总体能耗可以显著低于基于单个处理器核心的系统。
多个核心可以使得执行更快完成，因此系统的某些功能单元可以完全关闭更长时间。
或者，一个具有多个核心的系统可能能够以比单处理器实现相同吞吐量所需的频率更低的频率运行。
较低功耗的硅工艺或较低的电源电压可以降低功耗和减少的能量使用。
大多数当前系统不允许独立更改核心的频率。
然而，每个核心可以动态时钟门控（clock gated），从而提供额外的功率和能量节省。

拥有多个核心还为系统配置提供了更多选项。
例如，你可能拥有一个系统，其中一个核心用于处理硬实时需求，另一个核心用于需要高性能且不中断的应用。
这些可以整合到一个多处理器系统中。

多核设备也可能比单核设备更具响应能力。
当中断分布在多个核心之间时，有多个核心可以响应中断，每个核心需要处理的中断更少。
多个核心还使一个重要的后台进程能够与一个重要但不相关的前台进程同时进行。

\subsubsection{多处理系统}

我们可以将系统区分为：

\begin{itemize}
  \item
  单处理器包含一个核心。
  \item
  多核处理器，例如 Cortex-A53，具有多个能够独立执行指令的核心，并且可以被系统设计者或操作系统外部视为单个单元或集群，操作系统可以从应用层抽象出底层资源。
  \item
  多个集群（如图~\ref{fig:bl-system} 所示），每个集群包含多个核心。
\end{itemize}

以下对多处理系统（multi-processing system）的描述定义了本书中使用的术语。
在其他操作系统上，这些术语可能有不同的含义。

\paragraph{确定那个核在运行代码}

全局初始化通常由在单个核心上运行的代码执行，随后在所有核心上进行本地初始化。
多处理器关联寄存器（MPIDR\_EL1）使软件能够确定它正在执行的核心，无论是在一个集群内还是在具有多个集群的系统中，它都可以确定在哪个核心和哪个集群中执行。

在一些处理器配置中，U 位指示这是一个单核心还是多核集群。
关联字段提供核心相对于其他核心位置的分层描述。
通常，关联 0 是集群内的核心 ID，关联 1 是集群 ID。

\begin{Tcbox}[title={注意}]
在 EL1 运行的软件可能在由虚拟机管理程序管理的虚拟机中运行。
为了配置虚拟机，EL2 或 EL3 可以在运行时将 MPIDR\_EL1 设置为不同的值，使特定虚拟机看到每个虚拟核心的一个一致且唯一的值。
虚拟核心与物理核心之间的关系由虚拟机管理程序控制，并可能随着时间变化。

MPIDR\_EL3 包含每个物理核心的不可更改的 ID。
没有两个核心共享相同的 MPIDR\_EL3 值。
\end{Tcbox}

\paragraph{对称多处理系统}

对称多处理（SMP）是一种软件架构，能够动态确定各个核心的角色。
集群中的每个核心对内存和共享硬件都有相同的视图。
任何应用程序、进程或任务都可以在任何核心上运行，操作系统调度程序可以动态地在核心之间迁移任务，以实现系统负载的优化。
多线程应用程序可以同时在多个核心上运行，操作系统能够隐藏应用程序的许多复杂性。

在本指南中，操作系统下运行的每个应用程序实例称为进程。
应用程序通过调用系统库来执行许多操作，系统库提供某些功能的库代码，也作为对内核操作的系统调用的包装器。
各个进程有相关的资源，包括栈、堆和常量数据区，以及诸如调度优先级设置等属性。
内核对进程的视图称为任务。
进程是共享某些公共资源的任务集合。
其他操作系统可能有不同的定义。

在描述 SMP 操作时，我们使用术语“内核”来表示操作系统中包含异常处理程序、设备驱动程序以及其他资源和进程管理代码的那部分。
我们还假设存在一个通常通过计时器中断调用的任务调度程序。
调度程序负责在多个任务之间切片核心的可用周期，动态确定各个任务的优先级，并决定下一个要运行的任务。

线程是在同一进程空间内执行的独立任务，使应用程序的不同部分能够在不同核心上并行执行。
它们还允许应用程序的一部分在等待资源时继续执行。

一般而言，一个进程内的所有线程共享多个全局资源（包括相同的内存映射以及对任何打开文件和资源句柄的访问）。
线程也有自己的局部资源，包括它们自己的栈和寄存器使用，这些在上下文切换时由内核保存和恢复。
然而，这些资源是局部的并不意味着任何线程的局部资源能够得到其他线程不正确访问的保护。
线程是独立调度的，即使在同一进程中，它们也可以有不同的优先级。

一个支持 SMP 的操作系统向应用程序提供了可用核心资源的抽象视图。
在 SMP 系统中，多个应用程序可以同时运行而无需重新编译或更改源代码。
一个传统的多任务操作系统使系统能够在单核或多核处理器中同时执行多个任务或活动。
在多核系统中，我们可以实现真正的并发，在不同核心上同时并行地运行多个任务。
管理这些任务在可用核心之间分配的角色由操作系统执行。

通常，操作系统任务调度程序可以在系统的可用核心之间分配任务。
这一功能被称为负载均衡，旨在获得更好的性能或节能，甚至两者兼有。
例如，在某些类型的工作负载中，如果工作负载的任务被调度到较少的核心上，可以实现节能。
这将使更多的资源能够闲置更长时间，从而节省能源。

在其他情况下，如果任务分布在更多的核心上，工作负载的性能可能会提高。
这些任务可以比在较少核心上运行时更快地向前推进，而不会相互干扰。

另一个案例是，可能值得在更多的核心上以较低频率运行任务，而不是在较少的核心上以较高频率运行。
这样做可以在节能和性能之间提供更好的权衡。

SMP 系统中的调度程序可以动态地重新优先级任务。
这种动态任务优先级使其他任务可以在当前任务休眠时运行。
例如，在 Linux 中，性能受处理器活动限制的任务可以降低其优先级，以便性能受 I/O 活动限制的任务可以提高其优先级。
I/O 绑定的进程中断计算绑定的进程，以便它可以启动其 I/O 操作，然后返回休眠，而处理器可以在 I/O 操作完成时执行计算绑定的代码。

中断处理也可以在核心之间进行负载均衡。
这可以帮助提高性能或节省能源。
在核心之间平衡中断或为特定类型的中断保留核心可以减少中断延迟。
这也可能导致减少缓存使用，从而帮助提高性能。

使用更少的核心来处理中断可能会使更多的资源闲置更长时间，从而在降低性能的情况下节省能源。
Linux 内核不支持自动中断负载均衡。
然而，内核提供了将中断绑定到特定核心的机制。
有一些开源项目，例如 irqbalance（https://github.com/Irqbalance/irqbalance），使用这些机制在可用核心之间分配中断。
irqbalance 能够识别系统属性，例如共享缓存层次结构（哪些核心有公共缓存）和电源域布局（哪些核心可以独立关闭）。
然后，它可以确定最佳的中断到核心的绑定。

SMP 系统按定义，在集群中的核心之间共享内存。
为了向应用软件保持所需的抽象级别，硬件必须负责为你提供一致和一致的内存视图。

对共享内存区域的更改必须对所有核心可见，而无需任何显式的软件一致性管理，尽管需要同步指令（如屏障）来确保以正确的顺序看到更新。
同样，对内存映射的任何更新（例如，由于需求分页、新内存的分配或将设备映射到当前虚拟地址空间）都必须一致地呈现给所有核心。

\paragraph{时钟（Timer）}

在支持 SMP（对称多处理）的操作系统内核中，任务调度器负责在多个任务之间分配核心的可用周期。
它动态确定各个任务的优先级，并决定每个核心下一个要运行的任务。
通常需要一个计时器，以便能够定期中断每个核心上的活动任务，从而让调度程序有机会选择其他任务继续运行。

当所有核心争夺相同的关键资源时，可能会出现问题。
每个核心都运行调度程序来决定它应该执行的任务，而这是在固定间隔内发生的。
内核调度程序代码需要使用一些共享数据，例如任务列表，这些数据可以通过排除（由互斥锁提供）来保护免受并发访问。
互斥锁允许在任何时候只有一个核心能有效地运行调度程序。

\subparagraph*{系统计时器架构}

系统计时器架构描述了一个通用的系统计数器，为每个核心提供多达四个计时器通道。
这个系统计数器应具有固定的时钟频率。
系统计时器包括安全和非安全物理计时器，以及两个用于虚拟化的计时器。
每个通道都有一个比较器，将其与一个系统范围内的 64 位计数值进行比较，该计数值从零开始计数。
可以配置计时器，使得当计数大于或等于已编程的比较器值时生成中断。

虽然系统计时器必须具有固定的频率（通常以 MHz 为单位），但允许不同的更新粒度。
这意味着计时器可以在每个时钟周期递增 1 的同时，每 10 或 100 个周期递增一个较大的数值（例如 10 或 100），以相应降低的速率更新。
这提供了相同的有效频率，但减少了更新粒度，这在实现较低功耗状态时非常有用。

\subparagraph*{关键寄存器}

\begin{itemize}
  \item
    \textbf{CNTFRQ\_EL0}：报告系统计时器的频率。
    需要注意的是，CNTFRQ\_EL0 只是每个核心的一个寄存器，但从固件的角度来看，所有其他软件应该已经看到这个寄存器在所有核心上初始化为相同的正确值。
    计数频率是全局的，并且对于所有核心是固定的。
    CNTFRQ\_EL0 为启动 ROM 或固件提供了一种方便的方式，以告诉其他软件全局计数频率，但它不控制任何硬件行为的方面。
  \item
    \textbf{CNTPCT\_EL0}：报告当前的计数值。
  \item
    \textbf{CNTKCTL\_EL1}：控制是否 EL0 可以访问系统计时器。
\end{itemize}

\subparagraph*{配置计时器的步骤}

\begin{enumerate}
  \item
    \textbf{写入比较值到 CNTP\_CVAL\_EL0}：这是一个 64 位寄存器，用于设置比较值。
  \item
    \textbf{在 CNTP\_CTL\_EL0 中启用计数器和中断生成}：这一步启动计数器并启用中断。
  \item
    \textbf{轮询 CTP\_CTL\_EL0 以报告 EL0 计时器中断的原始状态}：检查计时器中断的状态。
\end{enumerate}

\subparagraph*{使用计时器作为倒计时计时器}

在这种情况下，所需的计数被写入到 32 位的 CNTP\_TVAL\_EL0 寄存器。
硬件将为你计算正确的 CNTP\_CVAL\_EL0 值。

这种架构和机制使得在多核系统中实现精确的定时和同步变得更加容易，从而提高系统的性能和响应能力。

\paragraph{同步}\label{sec:synchronization}

在 SMP（对称多处理）系统中，数据访问通常需要限制在任意特定时间内只能由一个修改者进行。
这对于外围设备以及由多个线程或进程访问的全局变量和数据结构都是如此。
保护这些共享资源的常用方法是互斥（mutual exclusion）。
在多核系统中，可以使用自旋锁（spinlock）来实现，这实际上是一个共享的标志，通过原子不可分割的机制来测试和设置其值。

ARM 架构提供了三条与独占访问相关的指令及其变体，这些指令可用于字节、半字、字或双字大小的数据。
这些指令依赖于核心或内存系统的能力，将特定地址标记为由该核心进行独占访问监控，使用独占访问监视器。
使用这些指令在多核系统中很常见，但在单核系统中也用于在同一核心上运行的线程之间实现同步操作。

A64 指令集有以下指令来实现这样的同步功能：

\begin{itemize}
\item
  \textbf{Load Exclusive (LDXR)}:
  {\lstinline!LDXR W|Xt, [Xn]!}
\item
  \textbf{Store Exclusive (STXR)}:
  {\lstinline!STXR Ws, W|Xt, [Xn]!}
  其中 Ws 指示存储是否成功，0 表示成功。
\item
  \textbf{Clear Exclusive Access Monitor (CLREX)}:
  用于清除本地独占监视器的状态。
\end{itemize}

\subparagraph*{这些指令的工作机制}

\begin{itemize}
\item
  \textbf{LDXR}
  执行内存加载，并将物理地址标记为由该核心监视的独占访问地址。
\item
  \textbf{STXR}
  执行条件存储，只有当目标位置被该核心标记为独占访问时才会成功。
  如果存储不成功，该指令在通用寄存器 Ws 中返回非零值；
  如果存储成功，返回 0。
  汇编语法中，Ws 始终指定为 W 寄存器，即非 X 寄存器。
  此外，STXR 会清除独占标记。
\end{itemize}

\subparagraph*{独占访问指令的要求}

独占加载和存储操作仅保证在映射了以下属性的普通内存上工作：

\begin{itemize}
\item
  内部或外部可共享。
\item
  内部写回。
\item
  外部写回。
\item
  读写分配提示。
\item
  非瞬态。
\end{itemize}

\subparagraph*{使用自旋锁或互斥锁}

自旋锁或互斥锁可以用于控制对外围设备的访问。
锁的位置应在普通 RAM 中。
独占加载或存储指令不会直接访问外围设备。

每个核心只能标记一个地址。
独占监视器并不会阻止其他核心或线程读取或写入被监视的位置，而只是监视自从 LDXR 之后该位置是否被写入。

\subparagraph*{程序员的责任}

虽然架构和硬件支持独占访问的实现，但依赖于程序员强制执行正确的软件行为。
互斥锁仅仅是一个标志，而独占访问机制使得这个标志可以以原子的方式进行访问。
任何访问标志的线程或程序都可以知道它是否被正确设置。
然而，互斥锁控制的实际资源仍然可以被不正确行为的软件直接访问。
同样，用于存储互斥锁的内存没有特殊属性。
当独占访问序列完成后，它只是内存中的另一段数据。

\subparagraph*{内存顺序考虑}

在编写使用互斥锁进行资源保护的代码时，理解弱序内存模型是至关重要的。
例如，如果没有正确使用屏障和其他内存排序考虑，推测执行可能意味着在获得互斥锁之前数据已经被加载，或者在关键资源更新之前释放了互斥锁。
有关内存排序考虑的更多信息，请参见内存排序章节。

总之，正确实现和使用互斥锁以及独占访问指令对于确保多核系统中共享资源的安全和正确访问至关重要。
理解并应用内存排序的概念是确保这些机制正确运行的关键。

\paragraph{不对称多处理系统}

AMP（非对称多处理）系统允许将单个集群中的每个核心分配特定角色，这意味着每个核心都执行各自的任务，这被称为功能分布的软件架构。
通常，这意味着在各个核心上运行单独的操作系统（OS）。
这样的系统可以表现为一个单核系统，但配有用于某些关键系统服务的专用加速器。
AMP 系统不涉及将任务或中断分配给特定核心。

\subparagraph*{AMP 系统的特点和用途}

\begin{itemize}

\item
  \textbf{独立的任务视图}：每个任务可以有不同的内存视图，不能将高负载的工作转移给低负载的核心。
\item
  \textbf{硬件缓存一致性}：这类系统通常不需要硬件缓存一致性，尽管可能需要通过共享资源（可能需要专用硬件）在核心之间进行通信。
\item
  \textbf{实现原因}：实施 AMP 系统的原因可能包括安全性、实时性需求或因为各个核心专用于执行特定任务。
\item
  \textbf{SMP 和 AMP 的结合}：一些系统结合了 SMP 和 AMP 特性，多个核心运行 SMP
  OS，同时系统有不作为 SMP 系统一部分的其他元素。
  SMP 子系统可以看作 AMP 系统中的一个元素，SMP 核心之间实现了缓存一致性，但这种一致性不一定扩展到 AMP 元素。
\item
  \textbf{多操作系统}：在 AMP 系统中，各个核心可以运行不同的操作系统，这种系统称为多操作系统（Multi-OS）系统。
\end{itemize}

\subparagraph*{通信和同步}

对于需要同步的不同核心，可以通过消息传递通信协议实现，如多核通信协会 API（MCAPI）。
这种通信可以通过共享内存传递数据包，并通过软件触发中断实现所谓的“门铃”机制。

\subparagraph*{具体实现方法}

\begin{itemize}

\item
  \textbf{消息传递协议（MCAPI）}：用于核心间的通信。
\item
  \textbf{共享内存}：用于传递数据包。
\item
  \textbf{软件触发中断}：用于实现同步机制。
\end{itemize}

AMP 系统在多核处理器上实现的原因多种多样，包括：

\begin{itemize}

\item
  \textbf{安全性}：独立核心运行不同 OS 可以提高系统安全性。
\item
  \textbf{实时性}：保证实时任务的截止期限。
\item
  \textbf{专用任务}：各个核心专门用于执行特定任务，提高效率。
\end{itemize}

\subparagraph*{具体例子}

\begin{itemize}

\item
  \textbf{安全和实时性}：一个核心运行实时操作系统（RTOS）处理实时任务，另一个核心运行 Linux 处理非实时任务。
\item
  \textbf{专用任务分配}：一个核心专用于音频处理，另一个核心专用于视频处理。
\end{itemize}

通过这种方式，AMP 系统可以在满足特定需求的同时，充分利用多核处理器的能力，实现更高效和安全的系统设计。

\paragraph{异构多处理系统}

异构多处理（Heterogeneous multi-processing，HMP）这一术语在许多不同的情境中都有应用。
它经常与 AMP 混淆，用来描述由不同类型的处理器组成的系统，例如多核 ARM 应用处理器和应用特定处理器（例如基带控制器芯片或音频编解码器芯片）。

ARM 将 HMP 定义为由应用处理器集群组成的系统，它们在指令集架构上完全相同，但在微体系结构上非常不同。
所有处理器都具有完全的缓存一致性，并且属于同一一致性域。

最好的例子是使用 ARM 实现的 HMP 技术，即 big.LITTLE。
在 big.LITTLE 系统中，能源高效的 LITTLE 核心与高性能的 big 核心相结合，形成一个系统，可以以最节能的方式完成高强度和低强度任务。

\Figure[caption={一个典型的大小核系统}, label={fig:bl-system}, width=0.5]{bl-system}

big.LITTLE 的核心原则是应用软件可以在任何类型的处理器上不经修改地运行。
有关 big.LITTLE 技术及其软件执行模型的详细概述，请参阅第~\ref{sec:big-little-tec} 章。

这种技术的出现源于对能源高效性和性能的需求。
通过将高性能和低功耗核心结合在一起，big.LITTLE 技术实现了在不同工作负载下的最佳平衡。

\paragraph{独占监视器区域}

一个典型的多核系统可能包括多个独占监视器。
每个核心都有自己的本地监视器，还有一个或多个全局监视器。
与独占加载或存储指令相关的转换表条目的可共享和可缓存属性决定了使用哪个独占监视器。

在硬件中，核心包括一个名为本地监视器的设备。
该监视器观察核心。
当核心执行独占加载访问时，它会在本地监视器中记录这一事实。
当它执行独占存储时，它会检查之前是否执行了独占加载，并且如果不是这种情况，则独占存储失败。
体系结构使得各个实现能够确定监视器执行的检查级别。
核心一次只能标记一个物理地址。

本地独占监视器在每次异常返回时被清除，也就是执行 ERET 指令时。
在 Linux 内核中，多个任务在 EL1 内核上下文中运行，并且可以在没有异常返回的情况下进行上下文切换。
只有当我们返回到与其相关联的内核任务的用户空间线程时，才执行异常返回。
这与 ARMv7 架构不同，在 ARMv7 架构中，内核任务调度器必须在每次任务切换时显式清除独占访问监视器。
重置本地独占监视器是否还会重置全局独占监视器是由实现定义的。

当用于独占访问的位置标记为不可共享时，即只能由同一核心上运行的线程访问时，会使用本地监视器。
本地监视器还可以处理访问被标记为内部可共享的情况，例如，在任何核心上运行的 SMP 线程之间共享的资源受到互斥锁的保护。
对于运行在不同、不一致的核心上的线程，互斥锁位置被标记为普通、非缓存，并且在系统中需要一个全局访问监视器。

系统可能不包括全局监视器，或者全局监视器可能仅适用于某些地址区域。
如果对不存在适当监视器的位置执行独占访问，则由实现定义会发生什么。
以下是一些允许的选项：

\begin{itemize}
\item
  指令生成外部异常。
\item
  指令生成 MMU 故障。
\item
  指令被视为 NOP。
\item
  将独占指令视为标准的 LDR/STR
  指令，存储独占指令的结果寄存器中的值变为未知。
\end{itemize}

独占保留颗粒度（ERG）是独占监视器的粒度。
它的大小是由实现定义的，但通常为一个缓存行。
它提供了监视器在区分地址之间的最小间距。
将两个互斥锁放置在单个 ERG 中可能会导致误报，即执行 STXR 指令到任一互斥锁会清除两者的独占标签。
这不会阻止架构上正确的软件正常运行，但可能效率较低。
可以从特定核心的缓存类型寄存器 CTR\_EL0 中读取独占监视器的 ERG 大小。

\subsubsection{缓存一致性}

第~\ref{sec:caches} 章只考虑了单个处理器内缓存的影响。
Cortex-A53 和 Cortex-A57 处理器支持在集群中的不同核心之间进行一致性管理。
这需要将地址区域标记为正确的可共享属性。
这些处理器允许构建包含多核集群的系统，其中可以维护集群之间共享数据的一致性。
这种系统级的一致性需要一个缓存一致的互连，例如 ARM 的 CCI-400，它实现了 AMBA 4 ACE 总线规范。
参见下图。

\Figure[caption={Cache 一致性组}, label={fig:cache-coherency-groups}, width=0.5]{cache-coherency-groups}

系统中的一致性支持取决于硬件设计决策，存在许多可能的配置。
例如，一致性只能在单个集群内支持。
一个双集群 big.LITTLE 系统是可能的，其中内部域包括两个集群的核心，或者一个多集群系统，其中内部域包括一个集群，外部域包括其他集群。
有关 big.LITTLE 系统的更多信息，请参见第~\ref{sec:big-little-tec} 章的 big.LITTLE 技术。

除了硬件之外，用于在缓存之间维护数据一致性的广播缓存维护活动的能力也是必要的，该活动由在一个核心上运行的代码执行。
在重置时会对硬件配置信号进行采样，以控制内部、外部或两者缓存维护操作是否广播，以及系统屏障指令是否广播。
AMBA 4 ACE 协议允许将屏障信号传递给其他主控器，以保持维护和一致性操作的顺序。
互连逻辑可能需要由引导代码进行初始化。

软件必须定义哪些地址区域由哪组主控器使用，也就是说，哪些其他主控器共享这个地址，方法是创建适当的转换表条目。
对于正常的可缓存区域，这意味着将共享属性设置为非共享、内部共享或外部共享之一。
对于非可缓存区域，共享属性将被忽略。

在多核系统中，不可能知道特定核心是否具有覆盖其缓存中特定地址的缓存行（特别是在具有缓存功能的互连中，如 CCN-50x）。

维护操作可能需要广播到互连。
这意味着位于一个核心上的软件可以向一个地址发出缓存清理或使其失效的操作，而该地址目前可能存储在持有该地址的另一个核心的数据缓存中。
如下图所示，当维护操作被广播时，该操作将由特定共享性域中的所有核心执行。

\Figure[caption={广播 cache 操作到其它核}, label={fig:broadcast-cache-op-to-other-cores}, width=0.9]{broadcast-cache-op-to-other-cores}

SMP 操作系统通常依赖于能够广播缓存和 TLB 维护操作。
考虑一种情况，外部 DMA 引擎能够修改外部存储器的内容。

运行在特定核心上的 SMP 操作系统不知道哪个核心有哪些数据。
它只需要在集群中的任何位置使地址范围失效。
如果操作不被广播，操作系统必须在每个核心上本地发出清理或使其失效的操作。
DSB 屏障指令使得核心等待其发出的广播操作完成。
但该屏障不会强制接收到的广播操作完成。
有关屏障指令的更多信息，请参阅第~\ref{sec:memory-ordering} 章内存排序。

下表列出了第~\ref{sec:caches} 章中描述的缓存维护操作以及它们是否被广播。

% \begin{minipage}{\textwidth}
%   \centering
  \begin{ltblr}[caption={带有广播的指令}, label={tbl:inst-with-broadcast}]
    {colspec={c>{\centering\arraybackslash}Xc}}
    \hline[1pt]
    指令 & 描述 & 广播？\\
    \hline
    IC IALLUIS   & I-cache invalidate all to Point of Unification, Inner Shareable & Yes (inner only) \\
    IC IALLU     & I-cache invalidate all to Point of Unification                  & No\footnotemark[1]              \\
    IC IVAU, Xt  & I-cache invalidate by address to Point of Unification           & Maybe\footnotemark[2]           \\
    DC ZVA, Xt   & D-cache zero by address                                         & No               \\
    DC IVAC, Xt  & D-cache invalidate by address to Point of Coherency             & Yes              \\
    DC ISW, Xt   & D-cache invalidate by Set/Way                                   & No               \\
    DC CVAC, Xt  & D-cache clean by address to Point of Coherency                  & Maybe\footnotemark[2]           \\
    DC CSW, Xt   & D-cache clean by Set/Way                                        & No               \\
    DC CVAU, Xt  & D-cache clean by address to Point of Unification                & Maybe\footnotemark[2]           \\
    DC CIVAC, Xt & D-cache clean and invalidate by address to Point of Coherency   & Yes              \\
    DC CISW, Xt  & D-cache clean and invalidate by Set/Way                         & No               \\
    \hline[1pt]
  \end{ltblr}
  \footnotetext[1]{在非安全 EL1 中，如果 HCR/HCR\_EL2 的 FB 位被设置，这将覆盖正常行为。
  该位会导致以下指令在非安全模式下从 EL1 执行时在内部共享域内广播：

  EL1: TLBI VMALLE1, TLBI VAE1, TLBI ASIDE1, TLBI VAAE1, TLBI VALE1, TLBI VAALE1, IC IALLU。
  }  \footnotetext[2]{内存区域的可共享性决定了广播行为。
  }  % \footnotetext{请看上一脚注}
  % \footnotetext{请看上一脚注}
% \end{minipage}

对于 IC 指令，即指令缓存维护操作，IS 表示该功能适用于内部共享域内的所有指令缓存。

\subsubsection{集群内的多核缓存一致性}

一致性（Coherency）意味着确保系统内所有处理器或总线主控设备对共享内存具有相同的视图。
这意味着一个核心缓存中数据的变化对其他核心是可见的，防止核心看到过时或旧的数据副本。
这可以通过不缓存来处理，即对共享内存位置禁用缓存，但这通常会带来高性能成本。

\paragraph*{软件管理的一致性}

软件管理的一致性是一种更常见的数据共享处理方式。
数据被缓存，但软件（通常是设备驱动程序）必须清除脏数据或从缓存中无效旧数据。
这需要时间，增加了软件的复杂性，并且在高共享率情况下会降低性能。

\paragraph*{硬件管理的一致性}

硬件在集群内的一级数据缓存之间维护一致性。
当核心启动并启用其数据缓存（D-cache）和内存管理单元（MMU）时，如果地址被标记为一致性地址，核心会自动参与一致性方案。
然而，这种缓存一致性逻辑\textbf{不}维护数据缓存和指令缓存之间的一致性。

在 ARMv8-A 架构及其相关实现中，可能会存在硬件管理的一致性方案。
这些方案确保在硬件一致性系统中标记为共享的数据在该共享域内的所有核心和总线主控设备中具有相同的值。
这增加了互连和集群的硬件复杂性，但极大简化了软件，并使得一些仅靠软件一致性无法实现的应用成为可能。

缓存一致性方案可以通过多种标准方式运行。
ARMv8 处理器使用 MOESI 协议。
ARMv8 处理器还可以连接到 AMBA 5 CHI 互连系统，其缓存一致性协议类似于但不完全等同于 MOESI。

通过硬件管理的一致性，系统性能和软件复杂度可以达到更好的平衡，确保共享内存的正确性和有效性。

根据使用的协议，SCU（Snoop Control
Unit）将缓存中的每一行标记为以下五种属性之一：M（Modified，已修改）、O（Owned，已拥有）、E（Exclusive，独占）、S（Shared，共享）或 I（Invalid，无效）。
这些属性的具体描述如下：

\begin{description}
\item [已修改 (Modified, M)] \hfill
\begin{itemize}
\item
  \textbf{描述}:
  缓存行中包含的最新版本数据仅存在于这个缓存中，其他缓存中不存在该内存位置的副本。
  缓存行的内容与主内存已经不一致。
\item
  \textbf{关键点}: 数据已被修改且只存在于当前缓存中，不再与主内存同步。
\end{itemize}

\item [{已拥有 (Owned, O)}] \hfill
\begin{itemize}
\item
  \textbf{描述}:
  缓存行是脏数据（即已被修改）并且可能存在于多个缓存中。
  拥有状态的缓存行持有数据的最新、正确副本。
  只有一个核心可以持有数据的拥有状态，其他核心可以持有数据的共享状态。
\item
  \textbf{关键点}:
  数据是最新的、正确的，并且可能在多个缓存中存在，但只有一个缓存持有该数据的修改权限。
\end{itemize}

\item [{独占 (Exclusive, E)}] \hfill
\begin{itemize}

\item
  \textbf{描述}:
  缓存行存在于这个缓存中且与主内存一致。
  其他缓存中不存在该内存位置的副本。
\item
  \textbf{关键点}:
  数据是最新的且未被修改，只有当前缓存拥有该数据的副本。
\end{itemize}

\item [{共享 (Shared, S)}] \hfill
\begin{itemize}
\item
  \textbf{描述}:
  缓存行存在于这个缓存中，数据不一定与内存一致，因为拥有状态允许脏数据复制为共享数据。
  然而，这行数据将是最新版本。
  其他缓存中也可能存在其副本。
\item
  \textbf{关键点}:
  数据是最新的，可能与主内存不同步，并且可能在多个缓存中存在。
\end{itemize}

\item[{无效 (Invalid, I)}] \hfill
\begin{itemize}
\item
  \textbf{描述}: 缓存行无效。
\item
  \textbf{关键点}: 数据不再有效，不能被使用。
\end{itemize}

\end{description}

\begin{Tcbox}[title={扩展}]

\paragraph*{缓存一致性协议}

在多处理器系统中，为了确保所有处理器都能看到相同的内存视图，使用缓存一致性协议。
常见的协议有：

\begin{itemize}

\item
  \textbf{MESI}（Modified, Exclusive, Shared, Invalid）：这是最基础的一致性协议，用于标记缓存行的状态。
\item
  \textbf{MOESI}（Modified, Owned, Exclusive, Shared, Invalid）：这是 MESI 协议的扩展，增加了“Owned”状态，用于优化共享数据的访问。
\item
  \textbf{MSI}（Modified, Shared, Invalid）：这是一个更简单的协议，但效率较低。
\end{itemize}

这些协议通过不同状态的组合和转换，确保在多处理器系统中，数据的一致性和正确性。
这对于现代多核处理器系统尤为重要，因为它们需要高效地管理和共享数据，同时避免数据不一致和竞态条件。

\paragraph*{ARM 缓存一致性}

在 ARM 处理器中，缓存一致性是通过硬件和软件结合的方式实现的。
硬件管理的一致性通过复杂的互连系统和缓存控制逻辑来确保数据的一致性，而软件管理的一致性则需要开发者在应用层面进行精细控制。

ARMv8 处理器通常使用 MOESI 协议，并支持 AMBA 5 CHI 互连系统，这些系统通过高级协议和信号传递机制，确保缓存一致性和系统性能。

缓存一致性对于多处理器系统的性能和正确性至关重要。
通过不同的缓存状态和一致性协议，可以有效地管理多核处理器系统中的数据共享和同步，确保系统的稳定和高效运行。

\end{Tcbox}

标准协议的实现规则如下：

\begin{itemize}
\item
  \textbf{写操作只能在缓存行处于“已修改”或“独占”状态时执行}。
  如果缓存行处于“共享”状态，必须先将所有其他缓存的副本无效化。
  写操作会将缓存行移动到“已修改”状态。
\item
  \textbf{缓存可以随时丢弃共享的缓存行}，将其变为“无效”状态。
  如果缓存行处于“已修改”状态，则必须先将其写回主存。
\item
  \textbf{如果缓存行处于“已修改”状态}，系统中其他缓存的读取操作将接收到该缓存的更新数据。
  通常，这是通过先将数据写回主存，然后将缓存行状态改为“共享”状态，再进行读取操作来实现的。
\item
  \textbf{如果缓存行处于“独占”状态}，当其他缓存读取该缓存行时，必须将其状态改为“共享”状态。
\item
  \textbf{“共享”状态可能不精确}。
  如果一个缓存丢弃了共享的缓存行，另一个缓存可能不会意识到现在可以将该缓存行移动到“独占”状态。
\end{itemize}

\paragraph*{缓存一致性协议中的状态转换}

状态说明：

\begin{itemize}
\item
  \textbf{已修改（Modified, M）}：缓存行被修改，且数据与主存不同步。
  写操作只能在此状态或“独占”状态下执行。
\item
  \textbf{独占（Exclusive, E）}：缓存行数据与主存同步，且该缓存行的唯一副本在当前缓存中。
\item
  \textbf{共享（Shared, S）}：缓存行可能在多个缓存中存在副本，数据可能不同步。
\item
  \textbf{无效（Invalid, I）}：缓存行无效，不包含有效数据。
\end{itemize}

状态转换规则：

\begin{description}
\item [{写操作}] \hfill
  \begin{itemize}
  \item
    若缓存行为“已修改”或“独占”，可直接写入。
  \item
    若缓存行为“共享”，则先使其他缓存副本无效化，再将其状态改为“已修改”。
  \end{itemize}
\item
  [{读操作}] \hfill
  \begin{itemize}
  \item
    若缓存行为“已修改”，其他缓存需从当前缓存读取最新数据，通常是先写回主存再读。
  \item
    若缓存行为“独占”，其他缓存读取时需将其状态改为“共享”。
  \end{itemize}
\item [{丢弃操作}] \hfill
  \begin{itemize}
  \item
    “共享”缓存行可随时丢弃，变为“无效”状态。
  \item
    “已修改”缓存行丢弃前需先写回主存。
  \end{itemize}
\end{description}

处理器簇（cluster）包含一个嗅探控制单元（Snoop Control Unit,
SCU），该单元包含存储在各个 L1 数据缓存中的标签的重复副本。
因此，缓存一致性逻辑负责以下任务：

\begin{itemize}
\item
  \textbf{维护 L1 数据缓存之间的一致性}：SCU 确保所有处理器核心的 L1 数据缓存中的数据保持一致。
  如果一个核心对数据进行了修改，其他核心能够及时获知并更新其缓存。
\item
  \textbf{仲裁对 L2 接口的访问}：SCU 管理对 L2 缓存接口的访问，既包括指令也包括数据。
  这种仲裁确保了多个核心可以高效地访问共享的 L2 缓存资源，而不会发生冲突或数据不一致。
\item
  \textbf{拥有重复的标签 RAMs}：SCU 使用重复的标签 RAM 来跟踪每个核心的数据缓存中分配了哪些数据。
  这些标签用于标识缓存行的状态和位置，以便在需要时快速定位和更新数据。
\end{itemize}

\Figure[caption={缓存一致性逻辑}, label={fig:cache-coherency-logic}, width=0.8]{cache-coherency-logic}

每个核心（如上图所示）都有自己的数据缓存和指令缓存。
缓存一致性逻辑包含了数据缓存（D-cache）的本地标签副本。
然而，指令缓存不参与一致性管理。
数据缓存和一致性逻辑之间存在双向通信。

ARM 多核处理器还实现了一些优化，可以在参与的一致性 L1 缓存之间直接复制干净数据和移动脏数据，而无需访问和等待外部内存。
这些活动在多核系统中由嗅探控制单元（SCU）处理。

多核技术的关键方面包括：

\paragraph*{嗅探控制单元}

嗅探控制单元（SCU）在每个核心的 L1 数据缓存之间维持一致性，并负责管理以下互连操作：

\begin{itemize}
\item
  仲裁。
\item
  通信。
\item
  缓存到缓存和系统内存的传输。
\end{itemize}

处理器还将这些功能暴露给其他系统加速器和非缓存 DMA 驱动的外设，以提高性能并减少整个系统的功耗。
这种系统一致性还减少了在每个操作系统驱动程序中维护软件一致性时涉及的软件复杂性。

每个核心可以被单独配置为参与或不参与数据缓存一致性管理方案。
处理器内部的 SCU 设备自动在集群内的核心之间维护级别 1 数据缓存的一致性。
有关更多信息，请参阅缓存一致性章节和集群内的多核缓存一致性章节。

由于可执行代码变化较少，因此这种功能不会扩展到 L1 指令缓存。
一致性管理使用基于 MOESI 协议的方式实现，通过优化以减少外部内存访问的次数。
为了使内存访问处于一致性管理状态，以下所有条件都必须为真：

\begin{itemize}
\item
  SCU 已启用，通过位于私有内存区域的控制寄存器。
  SCU 具有可配置的访问控制，限制了哪些处理器可以配置它。
\item
  MMU 已启用。
\item
  正在访问的页面标记为 Normal
  Shareable，并具有写回、写分配的缓存策略。
  然而，设备和强序内存不可缓存，并且写透缓存在核心的视角下的行为类似于无缓存内存。
\end{itemize}

\paragraph*{加速器一致性端口}

SCU 只能在单个集群内维护一致性。
如果系统中有其他处理器或其他总线主机，并且这些主机与 MP 块共享内存，则需要显式的软件同步。

SCU 上的这个 AMBA 4
AXI 兼容从设备接口提供了一个连接点，用于与 ARMv8 处理器直接接口的主设备：

\begin{itemize}
\item
  该接口支持所有标准的读写事务，无需额外的一致性要求。
  然而，对一致性内存区域的任何读事务都会与 SCU 进行交互，以检查信息是否已经存储在 L1 缓存中。
\item
  在将写操作转发到内存系统之前，SCU 会强制执行写一致性，并可能分配到 L2 缓存中，从而消除直接写入片外内存的功耗和性能影响。
\end{itemize}

\paragraph*{集群间的缓存一致性}

集群内的多核缓存一致性展示了硬件如何在同一集群中多个处理器缓存之间保持共享数据的一致性。
系统还可以包含硬件，通过处理可共享数据事务和广播屏障和维护操作来在集群之间维护一致性。
集群可以动态地添加或移除一致性管理，例如，当整个集群（包括 L2 缓存）被关闭时。
操作系统可以通过内置的性能监控单元（PMUs）监视一致性互连上的活动。

\paragraph*{域（domain）}

在 ARMv8-A 架构中，术语“域”用于指代一组主要的总线主控器。
域确定了哪些主控器会被监听，以进行一致性事务的处理。
监听是指检查主控器的缓存，看请求的位置是否存储在那里。
有四种定义好的域类型：

\begin{itemize}
\item
  非共享域。
\item
  内部共享域。
\item
  外部共享域。
\item
  系统域。
\end{itemize}

典型的系统使用是，运行在相同操作系统下的主控器属于同一个内部共享域。
共享可缓存数据但不是紧密耦合的主控器属于同一个外部共享域。
同一内部域中的主控器也必须属于同一个外部域。
内存访问的域选择通过页表中的条目来控制。

\Figure[caption={总线主控制器一致性域}, label={fig:bus-master-coherency-domains}, width=1]{bus-master-coherency-domains}

\subsubsection{总线协议和高速缓存一致性的互连}

将硬件一致性扩展到多个集群系统需要一个一致性的总线协议。
AMBA 4
ACE 规范包括 AXI 一致性扩展（ACE）。
完整的 ACE 接口使得集群之间可以实现硬件一致性，并使得 SMP 操作系统可以在多个核心上运行。

如果有多个集群，任何对一个集群内存的共享访问都可以侦听其他集群的缓存，看数据是否存在，或者是否必须从外部内存中加载。
AMBA 4 ACE-Lite 接口是完整接口的子集，设计用于单向 IO 一致性系统主控器，例如 DMA 引擎、网络接口和 GPU。

这些设备可能没有自己的缓存，但可以从 ACE 处理器读取共享数据。
非核心主控器的缓存通常不与核心缓存保持一致。
例如，在许多系统中，核心无法在从属端口上的 GPU 缓存内进行侦听。
但反过来未必如此。

ACE-Lite 允许其他主控器在其他集群的缓存中进行侦听。
这意味着对于共享位置，如果必要，读取将从一致性缓存中满足，并且共享写操作将与来自一致性缓存行的强制清理和失效合并。
ACE 规范使得 TLB 和 I-Cache 维护操作可以广播到所有能够接收它们的设备。
数据屏障被发送到从属接口以确保它们在程序上是完整的。

CoreLink CCI-400 Cache Coherent Interface 是 AMBA 4 ACE 的首批实现之一，支持最多两个 ACE 集群，使得最多八个核心可以看到相同的内存视图，并运行 SMP 操作系统，例如，一个 Cortex-A57 处理器和 Cortex-A53 处理器的 big.LITTLE 组合，如下图所示。

\Figure[caption={多簇系统}, label={fig:multi-cluster-system}, width=0.5]{multi-cluster-system}

它还具有三个可供 DMA 控制器或 GPU 使用的 ACE-lite 一致性接口。

下图显示了从 Cortex-A53 集群到 Cortex-A57 集群进行的一致性数据读取过程。

\begin{enumerate}
\item
  Cortex-A53 集群发出一致性读请求。
\item
  CCI-400 将请求传递给 Cortex-A53 处理器，以便侦听 Cortex-A57 集群的缓存。
\item
  当收到请求时，Cortex-A57 集群检查其数据缓存的可用性，并以所需的信息作出响应。
\item
  如果请求的数据在缓存中，CCI-400 将数据从 Cortex-A57 集群移动到 Cortex-A53 集群，从而在 Cortex-A53 集群中进行缓存行填充。
\end{enumerate}

\Figure[caption={CCI 嗅探请求}, label={fig:CCI-snoop-req}, width=0.4]{CCI-snoop-req}

CCI-400 和 ACE 协议使得 Cortex-A57 和 Cortex-A53 集群之间能够实现完全的一致性，从而实现数据共享，无需进行外部内存事务。

ARMCoreLink 互联和内存控制器系统 IP 解决了在 Cortex-A 系列处理器、高性能媒体处理器和动态内存之间高效移动和存储数据的关键挑战，以优化片上系统（SoC）的系统性能和功耗。
CoreLink 系统 IP 使 SoC 设计者能够最大程度地利用系统内存带宽，并减少静态和动态延迟。

\paragraph{计算机子系统和移动应用}

下图示展示了一个移动应用处理器的示例，其中包括 Cortex-A57 和 Cortex-A53 系列处理器、CoreLink MMU-500 系统内存管理单元，以及一系列的 CoreLink 400 系统 IP。

\Figure[caption={带有 CoreLink IP 的移动应用例子}, label={fig:exp-mobi-app-proc-with-corelink-ip}, width=0.95]{exp-mobi-app-proc-with-corelink-ip}

在这个系统中，ARM
Cortex-A57 和 Cortex-A53 处理器提供了一个 big.LITTLE 集群组合，并通过 AMBA 4
ACE 连接到 CCI-400，以提供完整的硬件一致性。
ARM Mali®-T628
GPU 和 IO 一致性主机通过 AMBA 4 ACE-Lite 接口连接到 CCI-400。

ARM 提供了不同的互连选项来维护跨集群的一致性：

\begin{description}
  \item [CoreLink CCI-400 高速缓存一致性互连] \hfill \\
    支持两个多核集群，并使用 AMBA
    4 和 AMBA 一致性扩展或 ACE。
    ACE 使用 MOESI 状态机进行跨集群的一致性维护。
  \item [CoreLink CCN-504 高速缓存一致性网络] \hfill \\
    支持最多四个多核集群，并包括集成的 L3 缓存和两通道 72 位 DDR。
  \item [CoreLink CCN-508 高速缓存一致性网络] \hfill \\
    支持最多八个多核集群，32 个核心，并包括集成的 L3 缓存和四通道 72 位 DDR。
  \item [CoreLink MMU-500 系统 MMU] \hfill \\
    为系统组件提供地址转换。
  \item [CoreLink TZC-400 TrustZone 地址空间控制器] \hfill \\
    对内存或外设事务进行安全检查，并允许将内存区域标记为安全区域。
  \item [CoreLink DMC-400 动态内存控制器] \hfill \\
    提供动态内存调度和与外部 DDR2/3 或 LPDDR2 内存的接口。
  \item [CoreLink NIC-400 网络互连] \hfill \\
    是一个高度可配置的组件，能够创建完整的高性能、优化的、符合 AMBA 标准的网络基础设施。

    CoreLink NIC-400 网络互连的可能配置范围从单个桥接组件（例如 AHB 到 AXI 协议转换桥）到一个复杂的互连，其中包括多达 128 个 AMBA 协议的主控和 64 个从控。
\end{description}
