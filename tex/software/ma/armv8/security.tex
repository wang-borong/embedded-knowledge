\subsection{安全}

提供一定级别安全性的系统，即可信系统，是保护资产的系统，例如密码和加密密钥，或信用卡详细信息，免受一系列可信攻击的影响，以防止它们被复制、损坏或变得不可用。

安全性通常由机密性、完整性和可用性原则定义。
机密性对于密码和加密密钥等资产是一个关键的安全问题。
防止修改并证明真实性对于安全软件和用于安全的芯片内部秘密至关重要。
可信系统的例子可能包括输入密码进行移动支付、数字版权管理和电子票务。
在开放系统的世界中，实现安全性更加困难，因为您可以将各种软件下载到平台上，无意中也可能下载到恶意或不受信任的代码，这可能会干扰您的系统。

移动设备可用于观看视频、听音乐、玩游戏，或用于浏览网页和访问金融服务。
这要求用户和银行或服务提供商都信任设备。
设备运行一个具有高级连接性的复杂操作系统，可能容易受到恶意软件的攻击。
通过软件系统设计可以实现一定程度的安全性，但通过 CPU 和系统级内存分区可以获得更高级别的保护。

ARM 处理器包括特定的硬件扩展，以便构建可信系统。
编写可信操作系统或可信执行环境（TEE）系统超出了本书的范围。
然而，如果将安全分数字段设置为实现 ARMv7 安全扩展，请注意，这会对操作系统和非特权代码施加一些限制，换句话说，这些代码不是可信系统的一部分。

软件和硬件攻击可以分为以下几类：

\begin{description}
  \item[软件攻击] \hfill \\
    恶意软件的攻击通常不需要对设备进行物理访问，并且可以利用操作系统或应用程序中的漏洞。
  \item[简单硬件攻击] \hfill \\
    这些通常是被动的，大多数是非破坏性的攻击，需要对设备进行访问并暴露于电子元件，使用常见的工具，如逻辑探针和 JTAG 运行控制单元。
  \item[实验室硬件攻击] \hfill \\
    这种类型的攻击需要复杂和昂贵的工具，如聚焦离子束（FIB）技术或功率分析技术，并且更常用于智能卡设备。
\end{description}

TrustZone 技术旨在保护免受软件和简单硬件攻击的侵害。

\subsubsection{TrustZone 硬件架构}

TrustZone 架构为系统设计者提供了一种帮助保护系统的手段，使用 TrustZone 安全扩展和安全外设。
低级程序员必须了解 TrustZone 架构对系统施加的限制，即使他们不使用安全功能。

ARM 安全模型将设备硬件和软件资源划分为安全子系统的安全世界和其他所有内容的普通世界。
系统硬件确保无法从普通世界访问安全世界的任何安全资产。
安全设计将所有敏感资源放置在安全世界中，并且理想情况下，具有能够保护资产免受各种可能的软件攻击的强大软件运行。

ARM 架构参考手册使用''安全''和''非安全''这两个术语来指代系统安全状态。
非安全状态并不自动意味着安全漏洞，而是指正常操作，因此与普通世界相同。
通常，非安全世界与安全世界之间存在主从关系，因此只有在普通世界执行安全监视器调用（SMC）时，安全世界才会被执行。
``世界''一词的使用实际上不仅用于描述执行状态，还用于描述只能在该状态下访问的所有内存和外设。

对架构的增强意味着单个物理核心可以以时间片的方式执行来自普通世界和安全世界的代码，尽管这取决于可以配置为仅由安全世界访问的中断生成外设的可用性。
例如，安全定时器中断可以用于保证安全世界的一些执行时间，类似于抢占式多任务处理。
这样的外设可能可用，也可能不可用，这取决于平台设计者打算支持的安全级别和用例。

另一种更接近协作多任务处理的执行模型也可以使用。
在这种情况下，尽管安全世界在每个世界可以访问的资源方面是独立的，但执行时间的调度通常在两个世界之间相互依赖。

与固件或系统软件一样，安全世界中的软件必须小心地将其对系统其他部分的影响降至最低。
例如，通常应避免消耗大量执行时间，除非执行某些由普通世界请求的操作，并且非安全中断应尽快通知普通世界。
这有助于确保普通世界软件的良好性能和响应能力，而无需进行大量的移植。

内存系统通过附加到外设和内存地址的附加位进行划分。
该位称为 NS 位，指示访问是安全的还是非安全的。
该位添加到所有内存系统事务中，包括缓存标签和对系统内存和外设的访问。
这个额外的地址位为安全世界提供了一个物理地址空间，并为普通世界提供了一个完全独立的物理地址空间。
运行在普通世界中的软件只能对内存进行非安全访问，因为核心始终在由普通世界生成的任何内存事务中将 NS 位设置为 1。
运行在安全世界中的软件通常只进行安全内存访问，但也可以使用其页表项中的 NS 和 NSTable 标志对特定内存映射进行非安全访问。

尝试对标记为安全的缓存数据进行非安全访问会导致缓存未命中。
试图对标记为安全的外部内存进行非安全访问会导致内存系统拒绝请求，并且从属设备返回错误响应。
对于非安全系统来说，没有迹象表明错误是由尝试访问安全内存引起的。

在 AArch64 架构中，EL3 拥有自己的转换表，由寄存器 TTBR0\_EL3 和 TCR\_EL3 管理。
在安全世界中只允许第一阶段的转换，因此没有 TTBR1\_EL3。
AArch64 EL1 转换表寄存器在安全状态之间不进行银行化，因此 TTBR0\_EL1、TTBR1\_EL1 和 TCR\_EL1 的值必须作为安全监视器的上下文切换操作的一部分保存和恢复。
这使得每个世界都可以拥有一组本地的转换表，其中安全世界的映射被隐藏并受到保护，不受普通世界的影响。
安全世界转换表中的条目包含 NS 和 NSTable 属性位，用于确定特定访问是否可以访问安全或非安全物理地址空间。

安全和非安全条目可以共存于缓存和转换后备缓冲区（TLB）中。
在切换世界时，无需使缓存数据失效。
普通世界只能生成非安全访问，因此只能命中标记为非安全的缓存行，而安全世界可以生成安全和非安全访问。
TLB 中的条目记录了生成特定条目的世界，尽管非安全状态永远无法操作安全数据，但安全世界可以将 NS 行分配到缓存中。
此外，对于每个异常级别，缓存是分别启用和禁用的。
缓存控制对于两个世界是独立的，但并不适用于所有异常级别，因此 EL0 永远无法直接启用或禁用缓存，EL2 可以覆盖非安全 EL1 的行为。

\subsubsection{通过中断切换安全世界}

当核心执行来自两个世界的代码时，它们之间的上下文切换通过执行安全监视器（SMC）指令或硬件异常机制（如中断）发生。
ARM 处理器有两种中断类型，FIQ 和 IRQ。

\Figure[caption={非安全中断}, label={fig:non-sec-int}, width=0.9]{non-sec-int}

有关将异常和中断重定向到 EL3 的控制的显式支持，独立于当前的 DAIF。
然而，这些控制只区分主要的中断类型：IRQ、FIQ 和异步中断。
更精细的控制需要将中断分为安全和非安全组。
要有效地实现这一点，需要 GIC 的支持，该支持具有明确的功能。

一个典型的用例是将 FIQ 用作安全中断，方法是将安全中断源映射为中断控制器内的 FIQ。
相关的外设和中断控制器寄存器必须标记为仅安全访问，以防止 Normal World 重新配置这些中断。

\Figure[caption={安全中断}, label={fig:sec-int}, width=0.9]{sec-int}

这些安全 FIQ 中断必须被路由到安全执行状态中的处理程序。
通常使用安全扩展的实现具有一个轻量级的受信任内核，它承载着安全服务，比如加密，在安全世界中。
一个完整的操作系统在普通世界中运行，并能够使用 SMC 指令访问安全服务。
通过这种方式，普通世界可以访问服务函数，而不会将受保护的资产，如密钥材料或其他受保护的数据，暴露给在普通世界执行的任意代码。

\subsubsection{多核系统中的安全}

多核系统中的每个核心都具有本章描述的相同安全功能。
在任何时候，群集中的任意数量核心都可以在安全世界中执行，并且核心能够独立于彼此之间在世界之间进行转换。
额外的寄存器控制普通世界代码是否可以修改 Snoop Control Unit（SCU）设置。
类似地，将优先级中断分配到多核集群的 GIC 必须配置为了解安全问题。

\paragraph*{正常世界和安全世界的交互}

如果您在包含某些安全服务的系统中编写代码，了解这些服务的使用方式是很有帮助的。
典型系统中有一个轻量级内核或 TEE（可信执行环境）托管服务，例如，在安全世界中进行加密。
它与普通世界中的完整操作系统进行交互，普通世界可以通过 SMC 调用访问安全服务。
这样，普通世界可以访问服务功能，而不会暴露密钥的风险。

一般来说，应用程序开发人员不会直接与安全扩展、TEEs 或可信服务进行交互。
相反，他们使用高级 API，例如由普通世界库提供的 \lstinline!authenticate()!。
这个库由与可信服务提供商相同的供应商提供，例如信用卡公司，并处理低级别的交互。
图17 - 3 展示了这种交互的流程，从用户应用程序调用 API 开始，该 API 进行适当的操作系统调用，然后传递到驱动程序代码，再通过安全监控器将执行传递到 TEE。

\Figure[caption={与安全扩展的交互}, label={fig:interaction-with-sec-ext}, width=0.7]{interaction-with-sec-ext}

在普通世界和安全世界之间传递数据是常见的。
例如，在安全世界中可能有一个签名检查器。
普通世界可以请求安全世界使用 SMC 调用验证下载更新的签名。
安全世界需要访问普通世界使用的内存。
安全世界可以在其转换表描述符中使用 NS 位，以确保它使用非安全访问来读取数据。
这很重要，因为与包裹相关的数据可能已经存在于缓存中，这是因为普通世界以标记为非安全的地址执行了访问。
可以将安全属性视为一个附加的地址位。
如果核心使用安全内存访问来尝试读取包裹，它不会命中缓存中已有的非安全数据。

如果您是普通世界的程序员，通常可以忽略在安全世界中发生的事情，因为它的操作对您是隐藏的。
一个副作用是，如果中断发生在安全世界中，中断延迟可能会略有增加，但与典型操作系统的总体延迟相比，这种增加很小。
需要注意的是，这类服务质量问题取决于安全世界操作系统的良好设计和实现。

创建安全世界操作系统和应用程序的详细内容超出了本书的范围。

\paragraph*{安全调试}

安全系统还控制调试功能的可用性。
您可以为普通软件世界和安全软件世界配置独立的硬件，通过完整的 JTAG 调试和跟踪控制，以确保没有关于可信系统的信息泄露。
您可以通过安全外设控制硬件配置选项，也可以通过硬连接并使用以下信号来控制它们：

\begin{itemize}
\item
  Secure Privileged Invasive Debug Enable (SPIDEN)：JTAG 调试。
\item
  Secure Privileged Non-Invasive Debug Enable (SPNIDEN)：跟踪和性能监视器。
\end{itemize}

\subsubsection{安全状态和非安全状态间的切换}

在 ARMv7 安全扩展中，监控模式（Monitor mode）被软件用来在安全（Secure）和非安全（Non-secure）状态之间切换。
这种模式与安全状态内的其他特权模式平级。

对于 ARMv8 架构，当 EL3 使用 AArch32 时，系统表现得像 ARMv7 一样，以确保完全兼容，结果是安全状态内的所有特权模式都被视为 EL3 的一部分。

AArch32 的安全模型如图~\ref{fig:sec-model-when-el3-a32} 所示。
在这种情况下，AArch32 使用 EL3 来提供安全操作系统和监控。

\Figure[caption={当 EL3 使用 A32 时的安全模型}, label={fig:sec-model-when-el3-a32}, width=0.7]{sec-model-when-el3-a32}

根据 ARMv7 架构，安全状态（Secure state）的 EL1 和 EL0 与非安全状态（Non-secure state）的 EL1 和 EL0 拥有不同的虚拟地址空间。
这允许在非安全侧运行 64 位操作系统或虚拟机管理程序的系统中使用 ARMv7 32 位架构的安全端代码。

图~\ref{fig:sec-model-when-el3-a64} 展示了当 AArch64 使用 EL3 来提供安全监控时的安全模型。
在这种模型中，AArch32 无法访问 EL3 状态，但可以在 EL1 使用安全操作系统。
当EL3 使用 AArch64 时，EL3 级别用于执行负责在非安全状态和安全状态之间切换的代码。

当 AArch64 使用 EL3 提供安全监控时：
\begin{itemize}
\item
  \textbf{EL3 状态}：主要用于切换安全状态和非安全状态的代码执行。
\item
  \textbf{EL1 和 EL0 状态}：在安全状态和非安全状态下都有各自独立的虚拟地址空间，确保在不同安全级别间的隔离。
\item
  \textbf{AArch32 与 AArch64 的结合}：系统可以在非安全侧运行 64 位操作系统，同时在安全侧运行 ARMv7 的 32 位安全代码，通过 EL3 的管理实现无缝切换和安全隔离。
\end{itemize}

这种架构设计允许在混合环境中使用，既能利用 64 位系统的优势，又能保证 32 位安全代码的执行和安全隔离。

\Figure[caption={当 EL3 使用 A64 时的安全模型}, label={fig:sec-model-when-el3-a64}, width=0.7]{sec-model-when-el3-a64}
