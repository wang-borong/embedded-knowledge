\chapter{OS 原理与 Linux}

\section{OS 原理}

\subsection{内存管理}

\subsection{进程与线程}

\subsubsection{调度}

调度算法：
\begin{itemize}
  \item Fist-Come, Fist-Served
  \item Shortest-Job-First
  \item Round-Robin
  \item Priority
  \item Multilevel Queue
  \item Multilevel Feedback Queue
\end{itemize}

\subsubsection{IPC}

\subsubsection{同步}

\subsection{网络}
\subsubsection{TCP/IP 协议栈总结}

\subsection{文件系统}

\subsection{安全管理}

\subsection{系统调用}

\section{Linux 内核}

\subsection{启动}
\subsubsection{启动流程分析}

\subsection{内存管理}

\subsection{task}

\subsection{网络}

\subsection{驱动架构及子系统}
\subsubsection{UART}

\subsubsection{Timer}

\subsubsection{WDT}

\subsubsection{DMA}

\paragraph{DMA 引擎控制器}

如果您要构建一个 DMA 控制器驱动，那么需要查阅这个文档
\url{https://www.kernel.org/doc/Documentation/dmaengine/provider.txt}。

\paragraph{DMA 客户端和接口使用}

如果您需要在设备驱动中使用 DMA，那么以下文档是您必须要理解的。

\begin{itemize}
  \item \href{https://www.kernel.org/doc/Documentation/DMA-API.txt}{DMA 映射接口介绍}
  \item \href{https://www.kernel.org/doc/Documentation/DMA-API-HOWTO.txt}{DMA 动态映射接口指南}
  \item \href{https://www.kernel.org/doc/Documentation/dmaengine/client.txt}{DMA 引擎 API 指南}
\end{itemize}

如果对上述的文档介绍比较迷糊，那么可以参考内核驱动代码的实际例子。
比如，可以参考 pl011 串口驱动中对 DMA 的使用（drivers/tty/serial/amba-pl011.c）。

根据 DMA 映射接口相关文档的介绍，一般 DMA 映射有：

\begin{enumerate}
  \item 使用大型 DMA-coherent 缓冲区。
    \begin{lstcode}
      void *
      dma_alloc_coherent(struct device *dev, size_t size,
          dma_addr_t *dma_handle, gfp_t flag);
      void
      dma_free_coherent(struct device *dev, size_t size, void *cpu_addr,
          dma_addr_t dma_handle);
    \end{lstcode}
  \item 使用小型 DMA-coherent 缓冲区。
    \begin{lstcode}
      struct dma_pool *
      dma_pool_create(const char *name, struct device *dev,
          size_t size, size_t align, size_t alloc);
      void *
      dma_pool_zalloc(struct dma_pool *pool, gfp_t mem_flags,
          dma_addr_t *handle);
      void *
      dma_pool_alloc(struct dma_pool *pool, gfp_t gfp_flags,
          dma_addr_t *dma_handle);
      void
      dma_pool_free(struct dma_pool *pool, void *vaddr,
          dma_addr_t addr);
      void
      dma_pool_destroy(struct dma_pool *pool);
    \end{lstcode}
  \item DMA 地址限制
    \begin{lstcode}
      int
      dma_set_mask_and_coherent(struct device *dev, u64 mask);
      int
      dma_set_mask(struct device *dev, u64 mask);
      int
      dma_set_coherent_mask(struct device *dev, u64 mask);
      u64
      dma_get_required_mask(struct device *dev);
      size_t
      dma_max_mapping_size(struct device *dev);
      unsigned long
      dma_get_merge_boundary(struct device *dev);
    \end{lstcode}
  \item 流式 DMA 映射
    \begin{lstcode}
      dma_addr_t
      dma_map_single(struct device *dev, void *cpu_addr, size_t size,
          enum dma_data_direction direction)
    \end{lstcode}
    以下是 direction 枚举类型：
    \begin{stblr}
      {direction 枚举类型说明}
      {dir-enum}
      {ll}
      \hline[1pt]
      方向 & 说明 \\
      \hline
      DMA\_NONE		        & no direction (used for debugging) \\
      DMA\_TO\_DEVICE		  & data is going from the memory to the device \\
      DMA\_FROM\_DEVICE		& data is coming from the device to the memory \\
      DMA\_BIDIRECTIONAL	& direction isn't known \\
      \hline[1pt]
    \end{stblr}
\end{enumerate}

根据 DMA 引擎 API 指南中的接口介绍，使用 DMA 传输功能我们需要完成以下步骤：

\begin{enumerate}
  \item 申请一个 DMA slave channel。
    使用到的接口为：

    \lstinline!struct dma_chan *dma_request_chan(struct device *dev, const char *name);!

  \item 向控制器和 slave 设置特定参数。
    接口为：

    \lstinline!int dmaengine_slave_config(struct dma_chan *chan, struct dma_slave_config *config);!

  \item 获取一个事务描述符。
    由于有三种不同的传输模式，所以有以下三种接口：
    \begin{lstlisting}
      struct dma_async_tx_descriptor *dmaengine_prep_slave_sg(
        struct dma_chan *chan, struct scatterlist *sgl,
        unsigned int sg_len, enum dma_data_direction direction,
        unsigned long flags);

      struct dma_async_tx_descriptor *dmaengine_prep_dma_cyclic(
        struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,
        size_t period_len, enum dma_data_direction direction);

      struct dma_async_tx_descriptor *dmaengine_prep_interleaved_dma(
        struct dma_chan *chan, struct dma_interleaved_template *xt,
        unsigned long flags);
    \end{lstlisting}
  \item 提交事务。
    描述符准备到位后将其提交给 DMA 引擎驱动的等待队列。

    \lstinline!dma_cookie_t dmaengine_submit(struct dma_async_tx_descriptor *desc);!

  \item 发起等待的 DMA 请求并且等待获取回调通知。
    接口为：

    \lstinline!void dma_async_issue_pending(struct dma_chan *chan);!
\end{enumerate}

以上只是简单的提炼，具体细节可以查阅相关文档。

\subsubsection{I2C/I3C}

\subsubsection{SPI/QSPI}

\subsubsection{RS232/RS422/RS485}

\subsubsection{CAN}

\subsubsection{Ethernet}

\subsubsection{USB}

\subsubsection{PCI/PCIe}

\subsection{文件系统}

\subsubsection{ext2 简介}

\section{Linux 应用开发}

\subsection{文件及 IO}

一切皆文件，所有在 Linux/UNIX 系统上打开的文件都用文件描述符表示，并且描述符是非零的。
当我们创建或打开一个文件，内核会返回一个文件描述符给到当前进程。
当我们读取或写入数据到一个文件中，我们便使用相应的文件描述符指定这个文件。

在类 UNIX 系统中约定俗成，文件描述符 0 代表一个进程的标准输入，1 代表标准输出，2 代表标准错误输出。
为了兼容性，应该使用 STDIN\_FILENO、STDOUT\_FILENO 和 STDERR\_FILENO 来代替 0、1 和 2。

文件描述符的范围从 0 到 OPEN\_MAX - 1。
Linux 系统对文件描述符的限制数量是 1024（soft limit），hard limit 为 524288。
然而我们可以通过修改 /etc/security/limits.conf 来修改类似的 limit。

\BlockDesc{打开文件}

\begin{lstlisting}[language=C]
  #include <fcntl.h>
  int open(const char *path, int oflag, ... /* mode_t mode */ );
  int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );
  /* Both return: file descriptor if OK, −1 on error */
\end{lstlisting}

\subsection{网络}

\subsection{进程}

\subsection{线程}

\subsection{异常处理}
