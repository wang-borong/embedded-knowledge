\chapter{微处理器体系架构}

如果暂时撇开硬件不谈，可以说微处理器体系架构属于嵌入式开发的最底层的硬件知识。
我暂时还说不清楚这部分知识属于 EE，还是 CS。
但是，可以肯定我们从处理器架构手册中获取的芯片运行原理等信息与处理器的开发有交集，
只是说处理器的开发需要更加详尽且完善的知识体系，而紧贴处理器硬件的软件开发也需要这部分原理知识以便正确且高效的使用相关的处理器。

微处理器体系架构方面的知识建立了处理器硬件与软件的桥梁，是嵌入式开发所绕不开的。
所以，我们从微处理器体系架构开始，逐步的完善并建立嵌入式开发的基础知识体系。

本章主要讲述两种微处理器架构，一种是目前占主导市场的 ARMv8 架构，两外一种则是开源的 RISC-V 指令集架构。

\section{ARMv8}

ARM 公司在 2013 年发布了它的 64-bit ARMv8 架构。
ARMv8 实现了 32-bit ARMv7 的兼容。
做出来以下重要升级：\footnote{该部分借鉴 \url{https://armv8-doc.readthedocs.io/en/latest/02.html\#armv8-a}，并且后续的整理也会借鉴该翻译成果，在此对付出精力的翻译人员予以感谢与尊重。
原版手册是 {ARM® Cortex®-A Series Programmer’s Guide for ARMv8-A}\cite{armpg}}

\begin{description}
    \item[Large physical address] 更大的物理内存，使处理器能够访问超过 4GB 的物理内存。
    \item[64-bit virtual addressing] 使虚拟内存突破 4GB 限制。
    这对于使用内存映射文件 I/O 或稀疏寻址的现代桌面和服务器软件很重要。
    \item[Automatic event signaling] 可以实现节能、高性能的自旋锁。
    \item[Larger register files] 31 个 64 位通用寄存器可提高性能并减少堆栈使用。
    \item[Efficient 64-bit immediate generation] 对 literal pool 的需求较少
    \item[Large PC-relative addressing range] 一个 +/‑4GB 的寻址范围，用于在共享库和与位置无关的可执行文件中进行有效的数据寻址。
    \item[Additional 16KB and 64KB translation granules] 降低了翻译后备缓冲区 (TLB) 未命中率和页面遍历深度。
    \item[New exception model] 降低了操作系统和管理程序软件的复杂性。
    \item[Efficient cache management] 用户空间缓存操作提高了动态代码生成效率。
    使用数据缓存零指令快速清除数据缓存。
    \item[Hardware-accelerated cryptography] 提供 3 到 10 倍更好的软件加密性能。
    这对于小粒度解密和加密非常有用，因为太小而无法有效地卸载到硬件加速器，例如 https。
    \item[Load-Acquire, Store-Release instructions] 专为 C++11、C11、Java 内存模型而设计。
    它们通过消除显式内存屏障指令来提高线程安全代码的性能。
    \item[NEON double-precision floating-point advanced SIMD] 使得 SIMD 矢量化能够应用于更广泛的算法集，例如科学计算、高性能计算 (HPC) 和超级计算机。
\end{description}

\subsection{Contex-A57 处理器}

目前 ARM 处理器已经更新到 X2，但是对于学习它的体系架构来说，A57 或 A53 已经足够适用，也足够经典。
我们将手册中的框架图拿过来感性的认识处理器的内部结构。

Cortex‑A57 处理器 Cortex‑A57 处理器面向移动和企业计算应用，包括计算密集型 64 位应用，例如高端计算机、平板电脑和服务器产品。
它可以与 Cortex‑A53 处理器一起使用到 ARM big.LITTLE 配置中，以实现可扩展的性能和更高效的能源使用。

Cortex‑A57 处理器具有与其他处理器的高速缓存一致性互操作性，包括用于 GPU 计算的 ARM Mali™ 系列图形处理单元 (GPU)，并为高性能企业应用程序提供可选的可靠性和可扩展性功能。
它提供了比 ARMv7 架构的 Cortex‑A15 处理器更高的性能，并具有更高的能效水平。
加密扩展的包含将加密算法的性能提高了 10 倍于上一代处理器。

\Figure[caption={Contex-A57}, label={fig:contex-a57}, width=0.8]{A57}

Cortex‑A57 处理器完全实现了 ARMv8‑A 架构。
它支持多核操作，在单个集群中具有一到四核多处理。
通过 AMBA5 CHI 或 AMBA 4 ACE 技术，可以实现多个一致的 SMP 集群。
可通过 CoreSight 技术进程调试和跟踪。

Cortex‑A57 处理器具有以下特性：

\begin{itemize}
  \item 乱序，15+阶段流水线。
  \item 省电功能包括路径预测、标记减少和缓存查找抑制。
  \item 通过重复执行资源增加峰值指令吞吐量。
  具有本地化解码、3 宽解码带宽的功率优化指令解码。
  \item 性能优化的 L2 缓存设计使集群中的多个核心可以同时访问 L2。
\end{itemize}

\subsection{ARMv8 异常级别}

在 ARMv8 中，执行发生在四个异常级别之一。
异常级别决定特权级别，因此在 $EL_n$ 执行对应于特权 $PL_n$。
更大的 n 值的异常级别处于更高的异常级别。

异常级别提供了适用于 ARMv8 架构的所有操作状态的软件执行权限的逻辑分离。
它类似于并支持计算机科学中常见的分层保护域的概念。

\begin{description}
    \item[EL0] Normal user applications.
    \item[EL1] Operating system kernel typically described as privileged.
    \item[EL2] Hypervisor.
    \item[EL3] Low-level firmware, including the Secure Monitor.
\end{description}

异常级别之间可以转换，但是要遵循以下规则：

\begin{itemize}
  \item 移动到更高的异常级别，例如从 EL0 到 EL1，表示软件增加执行特权。
  \item 不能将异常处理到较低的异常级别。
  \item EL0 级别没有异常处理，必须在更高的异常级别处理异常。
  \item 异常导致程序流程发生变化。
    异常处理程序的执行以高于 EL0 的异常级别从与所采取的异常相关的已定义向量开始。
    例外情况包括：IRQ 和 FIQ 等中断、内存系统中止、未定义的指令、系统调用。
    这些允许非特权软件对操作系统安全监视器或管理程序陷阱。
  \item 通过执行 ERET 指令来结束异常处理并返回到上一个异常级别。
  \item 从异常返回可以保持相同的异常级别或进入较低的异常级别。
    它不能移动到更高的异常级别。
  \item 安全状态确实会随着异常级别的变化而变化，除非从 EL3 重新调整到非安全状态。
\end{itemize}

\begin{probsolu}[title={Problem and Solution \theprob}]{
    如何切换 AArch64 EL？写个切换的实际例子？（课后作业）
  }\label{pb:el_changing}

  当处理异常时，会涉及几个寄存器的操作：
  \begin{enumerate}
    \item 处理器将当前正在执行的指令地址（PC 寄存器）存储在 ELR\_ELn（Exception link register）中。
    \item 将当前处理器的状态（PSTATE）存储在 SPSR\_ELn（Saved Program Status Register）中。
    \item 处理器根据异常向量表跳转到异常处理程序。
    异常处理程序可以修改 ELR 和 SPSR。
    \item 异常处理程序执行 eret 指令推出异常状态。
    这个指令会从 SPSR\_Eln 寄存器恢复处理器的状态，并且恢复 ELE\_Eln 中储存的指令的执行。
  \end{enumerate}
  据上所述，异常处理程序\textcolor{red}{可以修改 ELR\_ELn 和 SPSR\_ELn 寄存器}，所以异常处理程序能够间接的修改 EL 等参数，达到切换 EL 的目的。

  比如，想要从 EL3 异常级切换到 EL1，示例代码如下~\ref{lst:change_el}。
  那么需要配置一些系统寄存器，然后调用 eret 指令触发处理器切换异常运行级。

  \begin{enumerate}
    \item 配置 SCTLR\_EL1（System Control Register）。
      sctlr\_eln 寄存器被用来配置处理器的不同参数。
      存在 sctlr\_el1、sctlr\_el2 和 sctlr\_el3 分别对应 EL1、EL2 和 EL3 的寄存器。
      sctlr\_el1 寄存器能够配置 EL0 和 EL1 级别的内存等配置。
      通过修改 sctlr\_el1 某些位的值能达到配置处理器在 EL0 和 EL1 级别运行时的行为。
    \item 配置 HCR\_EL2（Hypervisor Configuration Register）。
      HCR\_EL2 寄存器提供了虚拟化的配置，包括定义是否将各种操作限制在 EL2 中。
      因为只有 EL2 支持 Hypervisor，所以只存在一个 HCR\_EL2 寄存器。
    \item 配置 SCR\_EL3（Secure Configuration Register）。
      SCR\_EL3 寄存器定义当前安全状态的配置:
      \begin{itemize}
        \item EL0，EL1 和 EL2 的安全状态为 Secure 或 Non-Secure
        \item EL2 的 Execution State
      \end{itemize}
    \item 配置 SPSR\_EL3（Saved Program Status Register）。
      EL3 发生异常时，SPSR\_EL3 寄存器用来保存处理器的状态。
    \item 配置 ELR\_EL3（Exception Link Register (EL3)）。
      在 EL3 进行异常处理时，ELR\_EL3 寄存器将用来指定即将要返回的地址。
  \end{enumerate}
  通过配置上述系统寄存器，然后调用 eret 触发处理器的执行状态的重恢复，就能将异常级别从 EL3 切换到 EL1。
\end{probsolu}
\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={切换异常级},
  label={lst:change_el}
]
  master:
  ldr    x0, =SCTLR_VALUE_MMU_DISABLED
  msr    sctlr_el1, x0

  ldr    x0, =HCR_VALUE
  msr    hcr_el2, x0

  ldr    x0, =SCR_VALUE
  msr    scr_el3, x0

  ldr    x0, =SPSR_VALUE
  msr    spsr_el3, x0

  adr    x0, el1_entry
  msr    elr_el3, x0

  eret
\end{lstlisting}

ARMv8 架构定义了两种执行状态，AArch64 和 AArch32。
每个状态分别用于描述使用 64 位宽通用寄存器或 32 位宽通用寄存器的执行。
虽然 ARMv8 AArch32 保留了 ARMv7 对特权的定义，但在 AArch64 中，特权级别由异常级别决定。
因此，在 $EL_n$ 的执行对应于特权 $PL_n$。

当处于 AArch64 状态时，处理器执行 A64 指令集。
当处于 AArch32 状态时，处理器可以执行 A32（在早期版本的架构中称为 ARM）或 T32 (Thumb) 指令集。

\begin{probsolu}[title={Problem and Solution \theprob}]{
    如何切换 AArch64 状态到 AArch32 状态？写个切换的实际例子？（课后作业）
  }\label{pb:state_changing}
  
  例如：在 EL3 下进行运行切换，EL3 为 AArch64，将 EL2 切换成 aarch32。
  在 EL3 异常级下，设置 EL2 的架构为 aarch32，设置好返回地址，通过 ERET 指令，即可将 EL2 状态切换成 EL2。
  设置中，主要涉及配置 elr\_el3 寄存器（保存下一异常级的指令地址）和 spsr\_el3 寄存器（保存下一异常级的 pstate 值）。
  对于 spsr\_el3，要设置正确，则要参考 AArch32 的 cpsr 寄存器值进行设置。

  如果需要将 A32 状态切换到 T32 状态，则使用 bx 指令，并且跳转地址的最低位要为 1；
  从 T32 状态切回 A32 状态同样使用 bx 指令，且跳转地址最低位为 0。
  
  总结：EL2 的 A64 和 A32 状态，由 EL3 决定，也就是 SCR\_EL3.RW 寄存器决定。

  EL1 的 A64 和 A32 状态，由 EL2 决定，也就是 HCR\_EL3.RW 寄存器决定。

  EL0 的 A64 和 A32 状态，由 EL1 决定，也就是 CPSR.M[4] 位决定。
\end{probsolu}

\subsection{Registers}

AArch64 64 位通用寄存器（X0-X30），也可以只使用低 32 位（W0-W30）用于 A32 状态。
从 W 寄存器读取时，忽略相应 X 寄存器高 32 位，并保持其它不变。
写入 W 寄存器时，将 X 寄存器的高 32 位设置为零。
也就是说，将 0xFFFFFFFF 写入 W0 会将 X0 设置为 0x00000000FFFFFFFF。

另外还有一些特殊寄存器：
\begin{itemize}
  \item Zero 寄存器，注意并没有所谓的 31 号寄存器（X31/W31），编号为 31 的寄存器就是零寄存器。
  当访问零寄存器时，所有写操作都被忽略，所有读操作返回 0。
  \item PC 寄存器（Program Counter）。
  \item SP 寄存器（SP/WSP）。
  注意 A64 下的 SP 并不加前缀 X。
  \item SPSR 寄存器（Program Status Register）。
  SPSR 保存着异常发生之前的 PSTATE 的值，用于在异常返回时恢复 PSTATE 的值。
  \item ELR 寄存器（Exception Link Register）。
  保存异常返回地址。
\end{itemize}
只有 EL1 和更高的异常级存在 SPSR 和 ELR。

在 ARMv8 体系结构中，要使用的栈指针的选择在一定程度上与异常级别是分开的。
默认情况下，发生异常时会选择目标异常级别的 SP\_ELn 作为栈指针。
例如，当触发到 EL1 的异常时，就会选择 SP\_EL1 作为栈指针。
每个异常级别都有自己的栈指针，SP\_EL0、SP\_EL1、SP\_EL2 和 SP\_EL3。
EL0 永远只能访问 SP\_EL0。

\begin{table}[H]
  \begin{center}
    \caption{AArch64 SP 选项}
    \label{tbl:a64_sp_opt}
    \begin{tblr}{cc}
      \hline[1pt]
      Exception Level & Options \\
      \hline
      EL0 & EL0t \\
      EL1 & EL1t, EL1h \\
      EL2 & EL2t, EL2h \\
      EL3 & EL3t, EL3h \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

后缀 t 表示选择 SP\_EL0，h 表示选择 SP\_ELn。

大多数指令无法使用 SP 寄存器，但是有一些形式的算术指令可以操作 SP，例如，ADD 指令可以读写当前的栈指针以调整函数中的栈指针。

原来的 ARMv7 指令集的一个特性是 R15 作为程序计数器（PC），并作为一个通用寄存器使用。
PC 寄存器的使用带来了一些编程技巧，但它为编译器和复杂的流水线的设计引入了复杂性。
在 ARMv8 中删除了对 PC 的直接访问，使返回预测更容易，并简化了 ABI 规范。

PC 永远不能作为一个命名的寄存器来访问。
但是，可以在某些指令中隐式的使用 PC，如 PC 相对加载和地址生成。
PC 不能被指定为数据处理或加载指令的目的操作数。

下表总结了 SPSR 各 bit 的含义：
\begin{table}[H]
  \begin{center}
    \caption{AArch64 SPSR bit 位含义}
    \label{tbl:a64_spsr}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      bit & 含义 \\
      \hline
      N & 负数标志位，如果结果为负数，则 N=1；
      如果结果为非负数，则 N=0。\\
      Z & 零标志位，如果结果为零，Z=1，否则 Z=0。\\
      C & 进位标志位\\
      V & 溢出标志位\\
      SS & 软件步进标志位，表示当一个异常发生时，软件步进是否开启\\
      IL & 非法执行状态位\\
      D & 程序状态调试掩码，在异常发生时的异常级别下，来自监视点、断点和软件单步调试事件中的调试异常是否被屏蔽。\\
      A & SError（系统错误）掩码位\\
      I & IRQ 掩码位\\
      F & FIQ 掩码位\\
      M$[4]$ & 异常发生时的执行状态，0 表示 AArch64\\
      M$[3:0]$ & 异常发生时的 mode 或异常级别\\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

AArch64 没有直接与 ARMv7 当前程序状态寄存器 (CPSR) 等价的寄存器。
在 AArch64 中，传统 CPSR 的组件作为可以独立访问的字段提供。
这些状态被统称为处理器状态 (PSTATE)。

\begin{table}[H]
  \begin{center}
    \caption{AArch64 PSTATE field}
    \label{tbl:a64_pstate}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      bit & 含义 \\
      \hline
      N & Negative condition flag. \\
      Z & Zero condition flag. \\
      C & Carry condition flag. \\
      V & oVerflow condition flag. \\
      D & Debug mask bit. \\
      A & SError mask bit. \\
      I & IRQ mask bit. \\
      F & FIQ mask bit. \\
      SS & Software Step bit. \\
      IL & Illegal execution state bit. \\
      EL (2) & Exception level. \\
      nRW & Execution state 
            0 = 64-bit
            1 = 32-bit \\
      SP & Stack Pointer selector.
            0 = SP\_EL0
            1 = SP\_ELn \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

在 AArch64 中，你可以通过执行 ERET 指令从一个异常中返回，那么 SPSR\_ELn 被复制到 PSTATE 中。
包括恢复 ALU 标志、执行状态、异常级别和处理器分支。
并将从 ELR\_ELn 中的地址开始继续执行。

PSTATE.\{N, Z, C, V\} 字段可以在 EL0 级别访问。
其他的字段可以在 EL1 或更高级别访问，但是这些字段在 EL0 级别未定义。

\subsubsection{系统寄存器}

在 AArch64 中，系统配置通过系统寄存器进行控制，并使用 MSR 和 MRS 指令进行访问。
简化了 ARMv7 架构通过协处理器 CP15 来操作系统寄存器的方式。

高异常级下可以访问本异常级和低异常级的系统寄存器。
EL0 异常级具有最低的权限，并且只有极少数的系统系统器可以在 EL0 下访问，例如：CTR\_EL0。

详细的系统寄存器列表请参见 Arm® Architecture Reference Manual for A-profile architecture \cite{armrefman}。

\BlockDesc{系统控制寄存器 SCTLR}

系统控制寄存器是一个很重要的系统寄存器，用于控制内存、配置系统能力和提供处理器核的状态信息。
这个寄存器在 EL0 下拥有更多的可获取 bit，更高的异常级则更少。

% npx bit-field -i <json> --fontsize=9 > figures/<bit_field>.svg
\Figure[caption={SCTLR BIT FIELD EL1}, label={fig:sctlr-bit-field-el1}, width=1]{sctlr-bit-field-el1}
\Figure[caption={SCTLR BIT FIELD EL2/3}, label={fig:sctlr-bit-field-el23}, width=1]{sctlr-bit-field-el23}

\begin{description}
  \item[UCI] 设置该域将使能 AArch64 下的 EL0 异常级对 DC CVAU、DC CIVAC、DC CVAC 和 IC IVAU 指令的访问权限。
  \item[EE] 控制异常 Endianness。
    \begin{description}
      \item[0] 小端 
      \item[1] 大端
    \end{description}
  \item[EOE] EL0 下 Explicit data 访问字节序
    \begin{description}
      \item[0] 小端 
      \item[1] 大端
    \end{description}
  \item[WXN] 写权限下应用不可执行权限 XN（eXecute Never）
    \begin{description}
      \item[0] 可写区域可执行
      \item[1] 可写区域强制不可执行
    \end{description}
  \item[nTWE] 不陷入 WFE，此标志为 1 表示 WFE 作为普通指令执行。
  \item[nTWI] 不陷入 WFI, 此标志为 1 表示 WFI 作为普通指令执行
  \item[UCT] 此标志为 1 时，开启 AArch64 的 EL0 下对 CTR\_EL0 寄存器访问权限。
  \item[DZE] EL0 下对 DC AVA 指令的访问权限。
    \begin{description}
      \item[0] 禁止访问
      \item[1] 允许访问
    \end{description}
  \item[I] 开启指令缓存，这是在 EL0 和 EL1 下的指令缓存的启用位。
    对可缓存的正常内存的指令访问被缓存。
  \item[UMA] 用户中断屏蔽控制，EL0 运行在 AArch64 状态下有效。
  \item[SED] 控制 AArch64 状态下的 EL0 是否可以使用 SETEND 指令。
    \begin{description}
      \item[0] 可用
      \item[1] 禁用
    \end{description}
  \item[ITD] 禁止 IT 指令
    \begin{description}
      \item[0] IT 指令有效
      \item[1] IT 指令被当作 16 位指令。
        仅另外 16 位指令或 32 位指令的头 16 位可以使用，这依赖于实现。
    \end{description}
  \item[CP15BEN] CP15 barrier 使能。
    如果实现了，它是 AArch32 CP15 DMB、DSB 和 ISB barrier 操作的使能位
  \item[SA0] EL0 的栈对齐检查使能位
  \item[SA] 栈对齐检查使能位
  \item[C] 数据 cache 使能。
    EL0 和 EL1 的数据访问使能位。
    cacheable 普通内存的数据访问都被缓存。
  \item[A] 对齐检查使能位。
  \item[M] 使能 MMU。
\end{description}

\begin{probsolu}[title={Problem and Solution \theprob}]{
    手册上写的 Explicit data access 怎么理解？（从 Linux 代码中找到答案）}

\end{probsolu}

\begin{remark}
  The caches in the processor must be invalidated before caching of data and instructions is
enabled in any of the Exception levels.
\end{remark}

\BlockDesc{大小端的设置}

每个异常级别的数据的大小端都被单独控制。
对于 EL3，EL2 和 EL1，通过 SCTLR\_ELn.EE 设置大小端。
EL1 中其他位，SCTLR\_EL1.E0E 控制 EL0 的数据大小端的设置。
在 AArch64 执行状态中，数据访问可以为 LE 或 BE，但指令的获取通常为 LE。

\subsubsection{NEON 和浮点}

除了通用寄存器之外，ARMv8 还有 32 个 128 位浮点寄存器，标记为 V0-V31。
32 个寄存器用于保存标量浮点指令的浮点操作数，以及 NEON 操作的标量操作数和向量操作数。

操作数使用 H (Half)、S (Single) 和 D (Double) 分别用来使用 V 寄存器的低 16、32 和 64 位。

\subsection{ISA 概述}

ARMv8 架构中引入的最重要的变化之一是增加了 64 位指令集。
该指令集补充了现有的 32 位指令集架构。
这一指令集提供了对 64 位宽整数寄存器和数据操作的访问，以及使用 64 位内存指针的能力。
新的指令集被称为 A64，并且在 AArch64 状态下执行。
ARMv8 架构还包括原始的 ARM 指令集（现称为 A32）和 Thumb（T32）指令集。
A32 和 T32 都以 AArch32 状态执行，并且向后与 ARMv7 架构兼容。

虽然 ARMv8-A 向后兼容了 32 位 ARM 架构的特性，但 A64 指令集与旧的 ISA 指令是独立且不同的，而且他们的编码方式也不同。
A64 增加了一些额外的功能，同时也删除了其他可能限制高性能实现速度或能效的功能。
ARMv8 架构还包括对 32 位指令集（A32 和 T32）的一些增强性功能。
然而，使用这些功能的代码与旧的 ARMv7 实现不兼容。
然而，A64 指令集中的指令操作码长度仍然是 32 位，而不是 64 位。

\subsubsection{ARMv8 指令集简介}

新的 A64 指令集与 A32 类似，都是 32 bit 宽度，并且语法类似。
该指令集使用通用的命名，原先的 32-bit 指令集则成为 A32 和 T32（16-bit 指令，以性能换空间）。
运行在 AArch64 新的指令集（64-bit 操作）则命名为 A64。

A64 指令集有两种整型指令形式，即通用寄存器保存 32-bit 或是 64-bit 值。
当查看指令中的寄存器名称时，如果是 X 开头则使用的是 64-bit 值；
W 开头则是 32-bit 值。
当使用 32-bit 形式时，会有以下体现：
\begin{itemize}
  \item 右移和旋转注入在 31 位，而非 63 位。
  \item 由指令设置的状态标志是从低 32 位里计算而来。
  \item 向 W 寄存器写入时，X 寄存器的 $[63:32]$ 位自动设为 0。
\end{itemize}

64-bit 指令集极大扩展了地址空间。
因此，在程序中访问大量内存变得更加简单。
在 32-bit 的 CPU 核上执行一个线程，会将内存的访问限制在 4G 空间。
大部分地址空间保留给 OS 内核、库代码和外设等方面使用。
所以，程序会面临内存不足的问题，那么程序在执行时可能需要将内存的一些数据映射出去或映射回来。
拥有更大的内存空间，更大的 64-bit 指针，便可以避免以上问题。
而且类似内存映射文件等技术将更加具有可用性和方便性。
在这种情况下，即使文件的内容大小超出了物理 RAM 的大小，文件内容也可以映射到线程的内存中。

其它改进包括：
\begin{description}
  \item[独占访问]
  \item[增加相对 PC 的偏移地址]
  \item[支持未对齐地址]
  \item[批量传输]
  \item[加载 / 存储]
  \item[对齐检查]
\end{description}

在问题~\ref{pb:state_changing} 中，我们分析了如何状态切换。
下面我们以手册中的切换图~\ref{fig:state_changing} 来直观感受切换方式。

\Figure[caption={Switching between instruction sets}, label={fig:state_changing}, width=0.8]{state_changing}

\subsection{A64 指令集}

一般情况下我们只需要记住指令的助记符即可，不需要在意更底层的指令编码，指令编码的事情留给汇编器来完成。

我们将指令集按照其功能分类，有如下几类指令：\footnote{关于指令集的快速参考可以使用 \url{https://courses.cs.washington.edu/courses/cse469/19wi/arm64.pdf}}

\begin{itemize}
  \item 数据处理指令
    % \begin{itemize}
    %   \item 算术与逻辑运算指令
    %   \item 乘法与除法指令
    %   \item 移位指令
    %   \item 位和字节操作指令
    %   \item 状态位操作指令
    % \end{itemize}
  \item 内存访问指令
  \item 流程控制指令
  \item 系统控制及其它指令
    % \begin{itemize}
    %   \item 异常处理指令
    %   \item 系统寄存器操作指令
    %   \item Debug 指令
    %   \item Hint 指令
    %   \item NEON 指令
    %   \item 浮点指令
    %   \item 加密算法指令
    % \end{itemize}
\end{itemize}

\subsubsection{数据处理指令}

\paragraph{算术与逻辑运算指令}

\begin{table}[H]
  \begin{center}
    \caption{算术和逻辑运算指令}
    \label{tbl:a64-isa-al}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      类型 & 指令 \\
      \hline
      算术 & ADD, SUB, ADC, SBC, NEG \\
      逻辑 & AND, BIC, ORR, ORN, EOR, EON \\
      比较 & CMP, CMN, TST \\
      转移 & MOV, MVN \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

另外，有些支持后缀带 S，已表明该指令会更新状态 flags。
可以配合跳转指令使用。
注意，CMP、CMN 和 TST 不带后缀 S。

\paragraph{乘法与除法指令}

\begin{table}[H]
  \begin{center}
    \caption{乘法与除法指令}
    \label{tbl:a64-isa-md}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      指令 & 说明 \\
      \hline
      & \textbf{乘法} \\
      MADD & Multiply add \\
      MNEG & Multiply negate \\
      MSUB & Multiply subtract \\
      MUL & Multiply \\
      SMADDL & Signed multiply-add long \\
      SMNEGL & Signed multiply-negate long \\
      SMSUBL & Signed multiply-subtract long \\
      SMULH & Signed multiply returning high half \\
      SMULL & Signed multiply long \\
      UMADDL & Unsigned multiply-add long \\
      UMNEGL & Unsigned multiply-negate long \\
      UMSUBL & Unsigned multiply-subtract long \\
      UMULH & Unsigned multiply returning high half \\
      UMULL & Unsigned multiply long \\
      \hline
      & \textbf{除法} \\
      SDIV & Signed divide \\
      UDIV & Unsigned divide \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

\paragraph{移位指令}

\begin{table}[H]
  \begin{center}
    \caption{移位指令}
    \label{tbl:a64-isa-so}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      指令 & 说明 \\
      \hline
      & \textbf{移位} \\
      ASR & Arithmetic shift right \\
      LSL & Logical shift left \\
      LSR & Logical shift right \\
      ROR & Rotate right \\
      \hline
      & \textbf{转移} \\
      MOV & Move \\
      MVN & Bitwise NOT \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

下图形象展示了移位指令的动作。

\Figure[caption={移位操作}, label={fig:shift-ops}, width=1]{shift-ops}

\paragraph{位和字节操作指令}

\begin{stblr}
  {位和字节操作指令}
  {a64-isa-bB}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  指令 & 说明 \\
  \hline
  BFI rd, rn, \#p, \#n & $rd_{p+n-1:p} = rn_{n-1:0}$ \\
  BFXIL rd, rn, \#p, \#n & $rd_{n−1:0} = rn_{p+n−1:p}$ \\
  CLS rd, rn & $rd = CountLeadingOnes(rn)$ \\
  CLZ rd, rn & $rd = CountLeadingZeros(rn)$ \\
  EXTR rd, rn, rm, \#p & $rd = rn_{p−1:0}:rm_{N0}$ \\
  RBIT rd, rn & $rd = ReverseBits(rn)$ \\
  REV rd, rn & $rd = BSwap(rn)$ \\
  REV16 rd, rn & $for(n=0..1|3) rd_{Hn}=BSwap(rn_{Hn})$ \\
  REV32 Xd, Xn & $Xd=BSwap(Xn_{63:32}):BSwap(Xn_{31:0})$ \\
  \{S,U\}BFIZ rd, rn, \#p, \#n & $rd = rn^?_{n−1:0} << p$ \\
  \{S,U\}BFX rd, rn, \#p, \#n & $rd = rn^?_{p+n−1:p}$ \\
  \{S,U\}XT\{B,H\} rd, Wn & $rd = Wn^?_{N0}$ \\
  SXTW Xd, Wn & $Xd = Wn^±$ \\
  \hline[1pt]
\end{stblr}

\paragraph{状态位操作指令}

A64 支持处理器状态位有 NZCV，分别位 Negative、Zero、Carry 和 Overflow。
C flag 在无符号数操作溢出时被设置，而 V 类似，但是是在有符号数操作溢出时被设置。

\begin{ltblr}[caption={Condition codes}, label={tbl:condcode}]
  {colspec={cc>{\centering\arraybackslash}X>{\centering\arraybackslash}Xc}, width=1\textwidth}
  \hline[1pt]
  Code & Encoding & Meaning (when set by CMP) & Meaning (when set by FCMP) & Condition flags \\
  \hline
  EQ & 0b0000 & Equal to. & Equal to. & Z =1 \\
  NE & 0b0001 & Not equal to. & Unordered, or not equal to. & Z = 0 \\
  CS & 0b0010 & Carry set (identical to HS). & Greater than, equal to, or unordered (identical to HS). & C = 1 \\
  HS & 0b0010 & Greater than, equal to (unsigned) (identical to CS). & Greater than, equal to, or unordered (identical to CS). & C = 1 \\
  CC & 0b0011 & Carry clear (identical to LO). & Less than (identical to LO). & C = 0 \\
  LO & 0b0011 & Unsigned less than (identical to CC). & Less than (identical to CC). & C = 0 \\
  MI & 0b0100 & Minus, Negative. & Less than. & N = 1 \\
  PL & 0b0101 & Positive or zero. & Greater than, equal to, or unordered. & N = 0 \\
  VS & 0b0110 & Signed overflow. & Unordered. (At least one argument was NaN). & V = 1 \\
  VC & 0b0111 & No signed overflow. & Not unordered. (No argument was NaN). & V = 0 \\
  HI & 0b1000 & Greater than (unsigned). & Greater than or unordered. & (C = 1) \&\& (Z = 0) \\
  LS & 0b1001 & Less than or equal to (unsigned). & Less than or equal to. & (C = 0) || (Z = 1) \\
  GE & 0b1010 & Greater than or equal to (signed). & Greater than or equal to. & N==V \\
  LT & 0b1011 & Less than (signed). & Less than or unordered. & N!=V \\
  GT & 0b1100 & Greater than (signed). & Greater than. & (Z==0) \&\& (N==V) \\
  LE & 0b1101 & Less than or equal to (signed). & Less than, equal to or unordered. & (Z==1) || (N!=V) \\
  AL & 0b1110 & Always executed. & Default. Always executed. & Any \\
  NV & 0b1111 & Always executed. & Always executed. & Any \\
  \hline[1pt]
\end{ltblr}

有一小部份的条件数据处理指令。
这些指令是无条件执行的，但使用条件标志作为指令的额外输入。
提供这组指令是为了取代 ARM 代码中条件执行的常见用法。

\BlockDesc{加 / 减}

例如，用于多精度算术和校验和的传统 ARM 指令。

\BlockDesc{带有可选增量、否定或反转的条件选择}

有条件地在一个源寄存器和第二个增量、否定、倒置或未修改的源寄存器之间进行选择。

这些是 A32 和 T32 中单个条件指令最常见的用途。
典型的用途包括有条件计数或计算有符号数量的绝对值。

\BlockDesc{条件操作}

有别于 A32 和 T32（大多数指令可以使用条件码预测），A64 只有流程控制类的跳转指令才会使用到条件码。
A64 中使用到条件码的指令，大致可以总结为：

\begin{description}
  \item[条件选择（移动）] 包括 CSEL、CSINC、CSINV 和 CSNEG。
    \begin{itemize}
      \item CSEL 根据一个条件在两个寄存器之间进行选择。
        无条件指令，然后是条件选择，可以取代简短的条件序列。
      \item CSINC 根据一个条件在两个寄存器之间进行选择。
        返回第一个源寄存器或第二个源寄存器增加一个。
      \item CSINV 根据条件在两个寄存器之间进行选择。
        返回第一个源寄存器或倒置的第二个源寄存器。
      \item CSNEG 根据条件在两个寄存器之间进行选择。
        返回第一个源寄存器或被否定的第二个源寄存器。
    \end{itemize}
  \item[条件设置] 有条件地在 0 和 1（CSET）或 0 和 -1（CSETM）之间进行选择。
    例如，用于在一般寄存器中将条件标志设置为布尔值或掩码。
  \item[条件比较]（CMP 和 CMN）如果原始条件为真，则将条件标志设置为比较结果。
    如果不是真，条件标志将设置为指定的条件标志状态。
    条件比较指令对于表示嵌套或复合比较非常有用。
\end{description}

\subsubsection{内存访问指令}

与之前的所有 ARM 处理器一样，ARMv8 架构是一个加载 / 存储架构。
这意味着没有数据处理指令直接对内存中的数据进行操作。
数据必须首先被加载到寄存器中，进行修改，然后存储到内存中。
必须在程序中指定一个地址，要传输的数据大小，以及一个源寄存器或目标寄存器。
还有一些额外的加载和存储指令，提供了更多的选择，如非时间性的加载 / 存储，加载 / 存储排他性，以及获取 / 释放。

内存指令可以以非对齐方式访问普通内存（见 Memory ordering 章节~\ref{sec:memory-ordering}）。
但是独占访问、加载获取或存储释放等变种访问方式不支持非对齐方式访问。
如果不需要非对齐访问，可以将上述变种访问方式配置为故障（非对齐访问时产生故障异常）。

\paragraph{Load}

Load 指令的一般形式如下：

\begin{lstcode}[numbers=none, language={[ARM]Assembler}]
  LDR Rt, <addr>
\end{lstcode}

程序员可以选择加载数据的大小到整数寄存器中。
例如，要加载一个比指定的寄存器值小的尺寸，可以在 LDR 指令中加入以下对应后缀：
\begin{itemize}
  \item LDRB (8-bit, zero extend)
  \item LDRSB (8-bit, sign extend)
  \item LDRH (16-bit, zero extend)
  \item LDRSH (16-bit, sign extend)
  \item LDRSW (32-bit, sign extend)
\end{itemize}

程序员无需指定 zero-extended（高位扩展为 0）加载指令将数据加载到 X 寄存器，因为向 W 寄存器写数据会自动 zero extend 整个寄存器宽度。

\paragraph{Store}

类似的，存储指令的一般形式如下：

\begin{lstcode}[numbers=none, language={[ARM]Assembler}]
  STR Rn, <addr>
\end{lstcode}

要存储的大小同样可能比寄存器小。
那么程序员可以添加类似 LDR 指令的后缀到 STR 来指定。
在这种情况下，存储的总是寄存器中的最低有效部分。

\paragraph{浮点和 NEON 向量的 Load 和 Store}

Load 和 Store 指令同样支持访问浮点 / NEON 寄存器。
此时，仅由所加载或存储的寄存器（B、H、S、D 或 Q 寄存器中的任意一个）来决定操作大小。
具体情况总结如下表：

加载指令：

\begin{stblr}
  {加载位数}
  {load-bits}
  {cccccccc}
  \hline[1pt]
  Load & Xt & Wt & Qt & Dt & St & Ht & Bt \\
  \hline
  LDR & 64 & 32 & 128 & 64 & 32 & 16 & 9 \\
  LDP & 128 & 64 & 256 & 128 & 64 & - & - \\
  LDRB & - & 8 & - & - & - & - & - \\
  LDRH & - & 16 & - & - & - & - & - \\
  LDRSB & 8 & 8 & - & - & - & - & - \\
  LDRSH & 16 & 16 & - & - & - & - & - \\
  LDRSW & 32 & - & - & - & - & - & - \\
  LDPSW & - & - & - & - & - & - & - \\
  \hline[1pt]
\end{stblr}

存储指令：

\begin{stblr}
  {存储位数}
  {store-bits}
  {cccccccc}
  \hline[1pt]
  Store & Xt & Wt & Qt & Dt & St & Ht & Bt \\
  \hline
  STR & 64 & 32 & 126 & 64 & 32 & 16 & 8 \\
  STP & 128 & 64 & 256 & 128 & 64 & - & - \\
  STRB & - & 8 & - & - & - & - & - \\
  STRH & - & 16 & - & - & - & - & - \\
  \hline[1pt]
\end{stblr}

加载数据到浮点或 NEON 寄存器的指令没有 sign-extension 选项。
并且，地址也是由通用寄存器指定的。

例如：

\begin{lstcode}[numbers=none, language={[ARM]Assembler}]
  LDR D0, [X0, X1]
\end{lstcode}

\begin{Tcbox}[title={注}]
  浮点或向量 NEON 加载和存储指令使用和整型加载和存储指令一样的寻址模式。
\end{Tcbox}

\paragraph{Load 和 Store 指令中的地址指定}

A64 可用的寻址模式与 A32 和 T32 中的相似。
有一些额外的限制以及一些新的功能，但是对于熟悉 A32 或 T32 的人来说，A64 可用的寻址模式并不新奇。

在 A64 中，一个地址操作数的基寄存器必须总是一个 X 寄存器。
但是，有几条零扩展或符号扩展的指令可以使用以满足通过 W 寄存器来提供 32 位偏移。

\subparagraph{偏移模式}

偏移寻址模式将一个立即数或一个可选择可修改的寄存器值添加到一个 64 位的基寄存器中以产生一个地址。

\begin{stblr}
  {偏移寻址}
  {offset-addressing}
  {cc}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1]} & Load from the address in X1 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, \#8]} & Load from address X1 + 8 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, X2]} & Load from address X1 + X2 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, X2, LSL, \#3]} & Load from address X1 + (X2 << 3) \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, W2, SXTW]} & Load from address X1 + sign\_extend(W2) \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, W2, SXTW, \#3]} & Load from address X1 + (sign\_extend(W2) << 3) \\
  \hline[1pt]
\end{stblr}

通常，当指定移位或扩展选项时，移位量可以是 0（默认值）或 $log_2(access\; size\; in\; bytes)$（因此，$Rn <<\; <shift>$ 即是 Rn 乘以访问大小）。
所以，偏移寻址支持常见的数组索引操作。

\begin{lstcode}[numbers=none, language=C]
// A C example showing accesses that a compiler is likely to generate.
void example_dup(int32_t a[], int32_t length) {
  int32_t first = a[0];  // LDR W3, [X0]
  for (int32_t i = 1; i < length; i++) {
    a[i] = first;  // STR W3, [X0, W2, SXTW, #2]
  }
}
\end{lstcode}

\subparagraph{索引模式}

索引模式与偏移模式类似，但它们还会更新基地址寄存器。
这里的语法与 A32 和 T32 相同，但操作集的限制性更强。
通常情况下，只能为索引模式提供立即数偏移。

索引模式有两种变体：
在访问内存之前施加偏移量的预索引模式；
以及在访问内存之后施加偏移量的后索引模式。

\begin{stblr}
  {索引寻址}
  {index-addressing}
  {cc}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1]} & Load from the address in X1 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, \#8]!} & Pre-index: Update X1 first (to X1 + \#8), then load from the new address \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1], \#8} & Post-index: Load from the unmodified address in X1 first, then update X1 (to X1 + \#8) \\
  \lstinline[language={[ARM]Assembler}]{STP X0, X1, [SP, #-16]!} & Push X0 and X1 to the stack. \\
  \lstinline[language={[ARM]Assembler}]{LDP X0, X1, [SP], \#16} & Pop X0 and X1 off the stack. \\
  \hline[1pt]
\end{stblr}

例如，这些选项准确地映射到一些常见的 C 操作上：

\begin{lstcode}[numbers=none, language=C]
// A C example showing accesses that a compiler is likely to generate.
void example_strcpy(char * dst, const char * src)
{
  char c;
  do {
    c = *(src++);  // LDRB W2, [X1], #1
    *(dst++) = c;  // STRB W2, [X0], #1
  } while (c != '\0');
}
\end{lstcode}

\subparagraph{相对 PC 模式（load-literal）}

A64 添加了另外一个专门用于获取 literal pool 的寻址模式。
Literal pool 是编码成一个指令流的数据块。
它们不会被执行，但是其数据可以通过周围的代码相对于 PC 的内存地址获取到。
Literal pool 经常用于编码常数，而这些常数不能被塞进一个简单的 move-immediate 指令（因为留给立即数的编码位数不足）中。
A32 和 T32 指令集中，PC 寄存器可以当作一个通用寄存器来读，所以可以通过指定 PC 作为基地址寄存器简单的访问 literal pool。

In A64, PC is not generally accessible, but instead there is a special addressing mode (for load
instructions only) that accesses a PC-relative address. This special-purpose addressing mode
also has a much greater range than the PC-relative loads in A32 and T32 could achieve, so literal
pools can be positioned more sparsely.

然而，在 A64 下，PC 寄存器不可以用通常的方式获取了，但是提供了一个特殊的寻址模式（只针对 load 指令）来获取 PC 相对地址。
这个特殊作用的寻址模式也极大扩展了 PC 相对加载的范围（相比于 A32 和 T32），所以 literal pool 可以更稀疏地定位。

\begin{stblr}
  {PC 相对寻址}
  {PC-relative-addressing}
  {cc}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]{LDR W0, <label>} & Load 4 bytes from <label> into W0 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, <label>} & Load 8 bytes from <label> into X0 \\
  \lstinline[language={[ARM]Assembler}]{LDRSW X0, <label>} & Load 4 bytes from <label> and sign-extend into X0 \\
  \lstinline[language={[ARM]Assembler}]{LDR S0, <label>} & Load 4 bytes from <label> into S0 \\
  \lstinline[language={[ARM]Assembler}]{LDR D0, <label>} & Load 8 bytes from <label> into D0 \\
  \lstinline[language={[ARM]Assembler}]{LDR Q0, <label>} & Load 16 bytes from <label> into Q0 \\
  \hline[1pt]
\end{stblr}

\begin{remark}
  对于所有变体而言，<label> 都必须 4-byte 对齐。
\end{remark}

\paragraph{获取多个地址位置}

A64 没有存在于 A32 和 T32 中的 Load Multiple (LDM) 或 Store Multiple (STM) 指令。

然而，在 A64 代码中，含有 Load Pair (LDP) 和 Store Pair (STP) 指令。
与 A32 LDRD 和 STRD 指令不同的是，LDP 和 STP 可以读写任何两个整型寄存器。
LDP 和 STP 指令从相邻的内存地址读写数据。
这两个指令的内存取址模式的选项比其它内存访问指令更加受限。
它们只能使用一个基地址寄存器附加一个成比例的 7-bit 的有符号立即数，另外一个可选的预地址或后地址增加操作。
与 32-bit 的 LDRD 和 STRD 不同，LDP 和 STP 也可以进行非对齐访问。

\paragraph{非特权访问}

The A64 LDTR and STTR instructions perform an unprivileged Load or Store (see LDTR and STTR in
ARMv8-A Architecture Reference Manual):

A64 的 LDTR 和 STTR 指令用于非特权级的数据加载和存储操作。

\lstinline!LDTR rt, [Xn{, #i9}]! 相当于 $rt = [Xn += i^{\pm}, <Unpriv>]_N$

\lstinline!STTR rt, [Xn{, #i9}]! 相当于 $[Xn += i^{\pm}, <Unpriv>]_N = rt$

\begin{itemize}
  \item 在 EL0、EL2 或 EL3 中，它们表现为一般的加载或存储指令。
  \item 在 EL1 下执行这些指令，则表现为就像在 EL0 中执行一样。
\end{itemize}
 
这些指令等效于 A32 的 LDRT 和 STRT 指令。

\paragraph{预取内存访问}

\textit{Prefetch from Memory} （PRFM）指令向代码提供了一个给内存系统暗示的功能，暗示内存系统一个特定的地址将很快就会被当前程序用到。
该功能的效果\textbf{由具体实现定义}，典型的实现是将数据或指令加载到 Cache 中。

该指令的语法为：

\lstinline!PRFM <prfop>, <addr> | label!

其中 prfop 是以下选项的拼接：

\begin{description}
  \item[Type] PLD 或 PST (prefetch for load or store)。
  \item[Target] L1、L2 或 L3（以那个 Cache 为目的）。
  \item[Policy] KEEP 或 STRM （保持在 cache 中，还是作为数据流）。
\end{description}

例如，PLDL1KEEP。
这些指令与 A32 的 PLD 和 PLI 指令类似。

\paragraph{Non-temporal load and store pair}

ARMv8 增加了一个关于 non-temporal 加载和存储的新概念。
相关指令是 LDNP 和 STNP，功能是读写一对寄存器的值。
并且，它们会给内存系统一个暗示，即缓存的数据不靠谱。
该暗示阻止内存系统激活诸如地址的缓存、预加载或合并等功能。
但是，这也无法获得缓存的加速。
一个典型的用例是生产数据流，但是注意高效使用这些指令需要一种微架构的特定方式。

Non-temporal 加载和存储缓解了内存序列化的需求。
在上述例子中，即使 LDNP 指令排在 LDR 指令之后，但是也可能先被观察到。
这种情况会导致从一个不确定的存储在 X0 中的地址读到数据。
例如：

\begin{lstcode}
  LDR X0, [X3]
  LDNP X2, X1, [X0] // X0 may not be loaded when the instruction executes!
\end{lstcode}

为了解决这个问题，程序员需要放置一个 load barrier 指令。

\begin{lstcode}
  LDR X0, [X3]
  DMB nshld
  LDNP X2, X1, [X0]
\end{lstcode}

\paragraph{内存访问的原子性}

使用单个通用寄存器进行的对齐内存访问是保证为原子性的。
使用一对通用寄存器的 Load pair 和 store pair 指令进行对齐内存地址访问保证为两个独立的原子访问。
非对齐访问不具有原子性，因为它们通常需要两个独立的访问。
另外，浮点和 SIMD 内存访问不保证是原子性的。

\paragraph{内存屏障和栅栏指令}

ARMv7 和 ARMv8 都提供了不同的 barrier 操作支持。
这些操作会在~\ref{sec:memory-ordering} 更加详尽的描述。

\begin{itemize}
  \item Data Memory Barrier (DMB)。该指令强制所有按照程序顺序的早期内存访问变成全局可见后才会执行后续的访问操作。
  \item Data Synchronization Barrier (DSB)。在程序运行之前，所有挂起的加载和存储指令、Cache 维护指令和所有 TLB 维护指令都必须先完成。
    DSB 类似 DMB，但是附加了其它属性。
  \item Instruction Synchronization Barrier (ISB)。这个指令刷新 CPU 的流水线和预取 buffer，致使 ISB 后续的指令需要从缓存或内存中预取（或重新预取）。
\end{itemize}

ARMv8 介绍了关于释放一致性模型的单侧 fence 操作。
包括 Load-Acquire (LDAR) 和 Store-Release (STLR) 并且都是基于地址的同步原语。
这两个操作可以作为完整的 fence 成对使用。
它们只支持基地址寄存器的寻址方式，偏移或其它类型的索引寻址都不支持。

\paragraph{同步原语}

ARMv7-A 和 ARMv8-A 架构都提供了独占的内存访问操作。
A64 下是由 Load/Store exclusive (LDXR/STXR) 对提供的。
LDXR 指令从一个内存地址加载一个值，并且尝试静默的给该地址上个互斥锁。
Store-Exclusive 指令只能在获取并持有锁的情况下才能向该地址写入新值。
组合使用 LDXR/STXR 能够构建标准的同步原语，如 spinlock。
LDXRP 和 STXRP 指令对提供以允许代码自动更新一个跨越两个寄存器的地址。
可用的选项有 byte、halfword、word 和 doubleword。
这对指令与 Load Acquire/Store Release 指令对一样，只支持基地址寄存器寻址方式。
不同于 ARMv7 异常入口或返回也能够清除 monitor，CLREX 指令在 ARMv8 下专门用于清除 monitor。
Monitor 也可能虚假的被清除，例如 cache 排除操作（evictions）或其它一些与该操作无关的原因。
软件必须要避免在LDXR 和 STXR 指令对之间含有内存访问、系统控制寄存器更新或缓存维护指令。

另外，还有一对 Acquire/Store Release 相关的互斥指令是 LDAXR 和 STLXR。
详见同步章节。

\subsubsection{流程控制指令}

\subsubsection{系统控制及其它指令}

    % \begin{itemize}
    %   \item 异常处理指令
    %   \item 系统寄存器操作指令
    %   \item Debug 指令
    %   \item Hint 指令
    %   \item NEON 指令
    %   \item 浮点指令
    %   \item 加密算法指令
    % \end{itemize}

\subsection{浮点与 NEON}

\subsection{ABI}

\subsection{异常处理}

\subsection{Caches}

\subsection{MMU}

\subsection{Memory ordering} \label{sec:memory-ordering}

\subsection{SMP}

\subsection{Others}

\section{RISC-V}

\subsection{Privileged Architecture}

\subsection{Unprivileged ISA}

\section{内存层级}

% vim:set ts=8 sts=2 sw=2 et:
