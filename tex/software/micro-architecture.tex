\chapter{微处理器体系架构}

如果暂时撇开硬件不谈，可以说微处理器体系架构属于嵌入式开发的最底层的硬件知识。
我暂时还说不清楚这部分知识属于 EE，还是 CS。
但是，可以肯定我们从处理器架构手册中获取的芯片运行原理等信息与处理器的开发有交集，
只是说处理器的开发需要更加详尽且完善的知识体系，而紧贴处理器硬件的软件开发也需要这部分原理知识以便正确且高效的使用相关的处理器。

微处理器体系架构方面的知识建立了处理器硬件与软件的桥梁，是嵌入式开发所绕不开的。
所以，我们从微处理器体系架构开始，逐步的完善并建立嵌入式开发的基础知识体系。

本章主要讲述两种微处理器架构，一种是目前占主导市场的 ARMv8 架构，两外一种则是开源的 RISC-V 指令集架构。

\section{ARMv8}

ARM 公司在 2013 年发布了它的 64-bit ARMv8 架构。
ARMv8 实现了 32-bit ARMv7 的兼容。
做出了以下重要升级：\footnote{
  该部分借鉴 \url{https://armv8-doc.readthedocs.io/en/latest/02.html\#armv8-a}，并且后续的整理也会借鉴该翻译成果，在此对付出精力的翻译人员予以感谢与尊重。
  但是必须要注意该翻译存在错误。
  原版手册是 {ARM® Cortex®-A Series Programmer’s Guide for ARMv8-A}\cite{armpg}
}

\begin{description}
    \item[Large physical address] 更大的物理内存，使处理器能够访问超过 4GB 的物理内存。
    \item[64-bit virtual addressing] 使虚拟内存突破 4GB 限制。
    这对于使用内存映射文件 I/O 或稀疏寻址的现代桌面和服务器软件很重要。
    \item[Automatic event signaling] 可以实现节能、高性能的自旋锁。
    \item[Larger register files] 31 个 64 位通用寄存器可提高性能并减少堆栈使用。
    \item[Efficient 64-bit immediate generation] 对 literal pool 的需求较少
    \item[Large PC-relative addressing range] 一个 +/‑4GB 的寻址范围，用于在共享库和与位置无关的可执行文件中进行有效的数据寻址。
    \item[Additional 16KB and 64KB translation granules] 降低了翻译后备缓冲区 (TLB) 未命中率和页面遍历深度。
    \item[New exception model] 降低了操作系统和管理程序软件的复杂性。
    \item[Efficient cache management] 用户空间缓存操作提高了动态代码生成效率。
    使用数据缓存零指令快速清除数据缓存。
    \item[Hardware-accelerated cryptography] 提供 3 到 10 倍更好的软件加密性能。
    这对于小粒度解密和加密非常有用，因为太小而无法有效地卸载到硬件加速器，例如 https。
    \item[Load-Acquire, Store-Release instructions] 专为 C++11、C11、Java 内存模型而设计。
    它们通过消除显式内存屏障指令来提高线程安全代码的性能。
    \item[NEON double-precision floating-point advanced SIMD] 使得 SIMD 矢量化能够应用于更广泛的算法集，例如科学计算、高性能计算 (HPC) 和超级计算机。
\end{description}

\subsection{Contex-A57 处理器}

目前 ARM 处理器已经更新到 X2，但是对于学习它的体系架构来说，A57 或 A53 已经足够适用，也足够经典。
我们将手册中的框架图拿过来感性的认识处理器的内部结构。

Cortex‑A57 处理器 Cortex‑A57 处理器面向移动和企业计算应用，包括计算密集型 64 位应用，例如高端计算机、平板电脑和服务器产品。
它可以与 Cortex‑A53 处理器一起使用到 ARM big.LITTLE 配置中，以实现可扩展的性能和更高效的能源使用。

Cortex‑A57 处理器具有与其他处理器的高速缓存一致性互操作性，包括用于 GPU 计算的 ARM Mali™ 系列图形处理单元 (GPU)，并为高性能企业应用程序提供可选的可靠性和可扩展性功能。
它提供了比 ARMv7 架构的 Cortex‑A15 处理器更高的性能，并具有更高的能效水平。
加密扩展的包含将加密算法的性能提高了 10 倍于上一代处理器。

\Figure[caption={Contex-A57}, label={fig:contex-a57}, width=0.7]{A57}

Cortex‑A57 处理器完全实现了 ARMv8‑A 架构。
它支持多核操作，在单个集群中具有一到四核多处理。
通过 AMBA5 CHI 或 AMBA 4 ACE 技术，可以实现多个一致的 SMP 集群。
可通过 CoreSight 技术进程调试和跟踪。

Cortex‑A57 处理器具有以下特性：

\begin{itemize}
  \item 乱序，15+阶段流水线。
  \item 省电功能包括路径预测、标记减少和缓存查找抑制。
  \item 通过重复执行资源增加峰值指令吞吐量。
  具有本地化解码、3 宽解码带宽的功率优化指令解码。
  \item 性能优化的 L2 缓存设计使集群中的多个核心可以同时访问 L2。
\end{itemize}

\subsection{ARMv8 异常级别}

在 ARMv8 中，执行发生在四个异常级别之一。
异常级别决定特权级别，因此在 $EL_n$ 执行对应于特权 $PL_n$。
更大的 n 值的异常级别处于更高的异常级别。

异常级别提供了适用于 ARMv8 架构的所有操作状态的软件执行权限的逻辑分离。
它类似于并支持计算机科学中常见的分层保护域的概念。

\begin{description}
    \item[EL0] Normal user applications.
    \item[EL1] Operating system kernel typically described as privileged.
    \item[EL2] Hypervisor.
    \item[EL3] Low-level firmware, including the Secure Monitor.
\end{description}

异常级别之间可以转换，但是要遵循以下规则：

\begin{itemize}
  \item 移动到更高的异常级别，例如从 EL0 到 EL1，表示软件增加执行特权。
  \item 不能将异常处理到较低的异常级别。
  \item EL0 级别没有异常处理，必须在更高的异常级别处理异常。
  \item 异常导致程序流程发生变化。
    异常处理程序的执行以高于 EL0 的异常级别从与所采取的异常相关的已定义向量开始。
    例外情况包括：IRQ 和 FIQ 等中断、内存系统中止、未定义的指令、系统调用。
    这些允许非特权软件对操作系统安全监视器或管理程序陷阱。
  \item 通过执行 ERET 指令来结束异常处理并返回到上一个异常级别。
  \item 从异常返回可以保持相同的异常级别或进入较低的异常级别。
    它不能移动到更高的异常级别。
  \item 安全状态确实会随着异常级别的变化而变化，除非从 EL3 重新调整到非安全状态。
\end{itemize}

\begin{probsolu}[title={Problem and Solution \theprob}]{
    如何切换 AArch64 EL？写个切换的实际例子？（课后作业）
  }\label{pb:el_changing}

  当处理异常时，会涉及几个寄存器的操作：
  \begin{enumerate}
    \item 处理器将当前正在执行的指令地址（PC 寄存器）存储在 ELR\_ELn（Exception link register）中。
    \item 将当前处理器的状态（PSTATE）存储在 SPSR\_ELn（Saved Program Status Register）中。
    \item 处理器根据异常向量表跳转到异常处理程序。
    异常处理程序可以修改 ELR 和 SPSR。
    \item 异常处理程序执行 eret 指令推出异常状态。
    这个指令会从 SPSR\_Eln 寄存器恢复处理器的状态，并且恢复 ELE\_Eln 中储存的指令的执行。
  \end{enumerate}
  据上所述，异常处理程序\textcolor{red}{可以修改 ELR\_ELn 和 SPSR\_ELn 寄存器}，所以异常处理程序能够间接的修改 EL 等参数，达到切换 EL 的目的。

  比如，想要从 EL3 异常级切换到 EL1，示例代码如下~\ref{lst:change_el}。
  那么需要配置一些系统寄存器，然后调用 eret 指令触发处理器切换异常运行级。

  \begin{enumerate}
    \item 配置 SCTLR\_EL1（System Control Register）。
      sctlr\_eln 寄存器被用来配置处理器的不同参数。
      存在 sctlr\_el1、sctlr\_el2 和 sctlr\_el3 分别对应 EL1、EL2 和 EL3 的寄存器。
      sctlr\_el1 寄存器能够配置 EL0 和 EL1 级别的内存等配置。
      通过修改 sctlr\_el1 某些位的值能达到配置处理器在 EL0 和 EL1 级别运行时的行为。
    \item 配置 HCR\_EL2（Hypervisor Configuration Register）。
      HCR\_EL2 寄存器提供了虚拟化的配置，包括定义是否将各种操作限制在 EL2 中。
      因为只有 EL2 支持 Hypervisor，所以只存在一个 HCR\_EL2 寄存器。
    \item 配置 SCR\_EL3（Secure Configuration Register）。
      SCR\_EL3 寄存器定义当前安全状态的配置:
      \begin{itemize}
        \item EL0，EL1 和 EL2 的安全状态为 Secure 或 Non-Secure
        \item EL2 的 Execution State
      \end{itemize}
    \item 配置 SPSR\_EL3（Saved Program Status Register）。
      EL3 发生异常时，SPSR\_EL3 寄存器用来保存处理器的状态。
    \item 配置 ELR\_EL3（Exception Link Register (EL3)）。
      在 EL3 进行异常处理时，ELR\_EL3 寄存器将用来指定即将要返回的地址。
  \end{enumerate}
  通过配置上述系统寄存器，然后调用 eret 触发处理器的执行状态的重恢复，就能将异常级别从 EL3 切换到 EL1。
\end{probsolu}
\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={切换异常级},
  label={lst:change_el}
]
  master:
  ldr    x0, =SCTLR_VALUE_MMU_DISABLED
  msr    sctlr_el1, x0

  ldr    x0, =HCR_VALUE
  msr    hcr_el2, x0

  ldr    x0, =SCR_VALUE
  msr    scr_el3, x0

  ldr    x0, =SPSR_VALUE
  msr    spsr_el3, x0

  adr    x0, el1_entry
  msr    elr_el3, x0

  eret
\end{lstlisting}

ARMv8 架构定义了两种执行状态，AArch64 和 AArch32。
每个状态分别用于描述使用 64 位宽通用寄存器或 32 位宽通用寄存器的执行。
虽然 ARMv8 AArch32 保留了 ARMv7 对特权的定义，但在 AArch64 中，特权级别由异常级别决定。
因此，在 $EL_n$ 的执行对应于特权 $PL_n$。

当处于 AArch64 状态时，处理器执行 A64 指令集。
当处于 AArch32 状态时，处理器可以执行 A32（在早期版本的架构中称为 ARM）或 T32 (Thumb) 指令集。

\begin{probsolu}[title={Problem and Solution \theprob}]{
    如何切换 AArch64 状态到 AArch32 状态？写个切换的实际例子？（课后作业）
  }\label{pb:state_changing}
  
  例如：在 EL3 下进行运行切换，EL3 为 AArch64，将 EL2 切换成 aarch32。
  在 EL3 异常级下，设置 EL2 的架构为 aarch32，设置好返回地址，通过 ERET 指令，即可将 EL2 状态切换成 EL2。
  设置中，主要涉及配置 elr\_el3 寄存器（保存下一异常级的指令地址）和 spsr\_el3 寄存器（保存下一异常级的 pstate 值）。
  对于 spsr\_el3，要设置正确，则要参考 AArch32 的 cpsr 寄存器值进行设置。

  如果需要将 A32 状态切换到 T32 状态，则使用 bx 指令，并且跳转地址的最低位要为 1；
  从 T32 状态切回 A32 状态同样使用 bx 指令，且跳转地址最低位为 0。
  
  总结：EL2 的 A64 和 A32 状态，由 EL3 决定，也就是 SCR\_EL3.RW 寄存器决定。

  EL1 的 A64 和 A32 状态，由 EL2 决定，也就是 HCR\_EL3.RW 寄存器决定。

  EL0 的 A64 和 A32 状态，由 EL1 决定，也就是 CPSR.M[4] 位决定。
\end{probsolu}

\subsection{Registers}

AArch64 64 位通用寄存器（X0-X30），也可以只使用低 32 位（W0-W30）用于 A32 状态。
从 W 寄存器读取时，忽略相应 X 寄存器高 32 位，并保持其它不变。
写入 W 寄存器时，将 X 寄存器的高 32 位设置为零。
也就是说，将 0xFFFFFFFF 写入 W0 会将 X0 设置为 0x00000000FFFFFFFF。

另外还有一些特殊寄存器：
\begin{itemize}
  \item Zero 寄存器，注意并没有所谓的 31 号寄存器（X31/W31），编号为 31 的寄存器就是零寄存器。
  当访问零寄存器时，所有写操作都被忽略，所有读操作返回 0。
  \item PC 寄存器（Program Counter）。
  \item SP 寄存器（SP/WSP）。
  注意 A64 下的 SP 并不加前缀 X。
  \item SPSR 寄存器（Program Status Register）。
  SPSR 保存着异常发生之前的 PSTATE 的值，用于在异常返回时恢复 PSTATE 的值。
  \item ELR 寄存器（Exception Link Register）。
  保存异常返回地址。
\end{itemize}
只有 EL1 和更高的异常级存在 SPSR 和 ELR。

在 ARMv8 体系结构中，要使用的栈指针的选择在一定程度上与异常级别是分开的。
默认情况下，发生异常时会选择目标异常级别的 SP\_ELn 作为栈指针。
例如，当触发到 EL1 的异常时，就会选择 SP\_EL1 作为栈指针。
每个异常级别都有自己的栈指针，SP\_EL0、SP\_EL1、SP\_EL2 和 SP\_EL3。
EL0 永远只能访问 SP\_EL0。

\begin{table}[H]
  \begin{center}
    \caption{AArch64 SP 选项}
    \label{tbl:a64_sp_opt}
    \begin{tblr}{cc}
      \hline[1pt]
      Exception Level & Options \\
      \hline
      EL0 & EL0t \\
      EL1 & EL1t, EL1h \\
      EL2 & EL2t, EL2h \\
      EL3 & EL3t, EL3h \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

后缀 t 表示选择 SP\_EL0，h 表示选择 SP\_ELn。

大多数指令无法使用 SP 寄存器，但是有一些形式的算术指令可以操作 SP，例如，ADD 指令可以读写当前的栈指针以调整函数中的栈指针。

原来的 ARMv7 指令集的一个特性是 R15 作为程序计数器（PC），并作为一个通用寄存器使用。
PC 寄存器的使用带来了一些编程技巧，但它为编译器和复杂的流水线的设计引入了复杂性。
在 ARMv8 中删除了对 PC 的直接访问，使返回预测更容易，并简化了 ABI 规范。

PC 永远不能作为一个命名的寄存器来访问。
但是，可以在某些指令中隐式的使用 PC，如 PC 相对加载和地址生成。
PC 不能被指定为数据处理或加载指令的目的操作数。

下表总结了 SPSR 各 bit 的含义：
\begin{table}[H]
  \begin{center}
    \caption{AArch64 SPSR bit 位含义}
    \label{tbl:a64_spsr}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      bit & 含义 \\
      \hline
      N & 负数标志位，如果结果为负数，则 N=1；
      如果结果为非负数，则 N=0。\\
      Z & 零标志位，如果结果为零，Z=1，否则 Z=0。\\
      C & 进位标志位\\
      V & 溢出标志位\\
      SS & 软件步进标志位，表示当一个异常发生时，软件步进是否开启\\
      IL & 非法执行状态位\\
      D & 程序状态调试掩码，在异常发生时的异常级别下，来自监视点、断点和软件单步调试事件中的调试异常是否被屏蔽。\\
      A & SError（系统错误）掩码位\\
      I & IRQ 掩码位\\
      F & FIQ 掩码位\\
      M$[4]$ & 异常发生时的执行状态，0 表示 AArch64\\
      M$[3:0]$ & 异常发生时的 mode 或异常级别\\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

AArch64 没有直接与 ARMv7 当前程序状态寄存器 (CPSR) 等价的寄存器。
在 AArch64 中，传统 CPSR 的组件作为可以独立访问的字段提供。
这些状态被统称为处理器状态 (PSTATE)。

\begin{table}[H]
  \begin{center}
    \caption{AArch64 PSTATE field}
    \label{tbl:a64_pstate}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      bit & 含义 \\
      \hline
      N & Negative condition flag. \\
      Z & Zero condition flag. \\
      C & Carry condition flag. \\
      V & oVerflow condition flag. \\
      D & Debug mask bit. \\
      A & SError mask bit. \\
      I & IRQ mask bit. \\
      F & FIQ mask bit. \\
      SS & Software Step bit. \\
      IL & Illegal execution state bit. \\
      EL (2) & Exception level. \\
      nRW & Execution state 
            0 = 64-bit
            1 = 32-bit \\
      SP & Stack Pointer selector.
            0 = SP\_EL0
            1 = SP\_ELn \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

在 AArch64 中，你可以通过执行 ERET 指令从一个异常中返回，那么 SPSR\_ELn 被复制到 PSTATE 中。
包括恢复 ALU 标志、执行状态、异常级别和处理器分支。
并将从 ELR\_ELn 中的地址开始继续执行。

PSTATE.\{N, Z, C, V\} 字段可以在 EL0 级别访问。
其他的字段可以在 EL1 或更高级别访问，但是这些字段在 EL0 级别未定义。

\subsubsection{系统寄存器}

在 AArch64 中，系统配置通过系统寄存器进行控制，并使用 MSR 和 MRS 指令进行访问。
简化了 ARMv7 架构通过协处理器 CP15 来操作系统寄存器的方式。

高异常级下可以访问本异常级和低异常级的系统寄存器。
EL0 异常级具有最低的权限，并且只有极少数的系统系统器可以在 EL0 下访问，例如：CTR\_EL0。

详细的系统寄存器列表请参见 Arm® Architecture Reference Manual for A-profile architecture \cite{armrefman}。

\BlockDesc{系统控制寄存器 SCTLR}

系统控制寄存器是一个很重要的系统寄存器，用于控制内存、配置系统能力和提供处理器核的状态信息。
这个寄存器在 EL0 下拥有更多的可获取 bit，更高的异常级则更少。

% npx bit-field -i <json> --fontsize=9 > figures/<bit_field>.svg
\Figure[caption={SCTLR BIT FIELD EL1}, label={fig:sctlr-bit-field-el1}, width=1]{sctlr-bit-field-el1}
\Figure[caption={SCTLR BIT FIELD EL2/3}, label={fig:sctlr-bit-field-el23}, width=1]{sctlr-bit-field-el23}

\begin{description}
  \item[UCI] 设置该域将使能 AArch64 下的 EL0 异常级对 DC CVAU、DC CIVAC、DC CVAC 和 IC IVAU 指令的访问权限。
  \item[EE] 控制异常 Endianness。
    \begin{description}
      \item[0] 小端 
      \item[1] 大端
    \end{description}
  \item[EOE] EL0 下 Explicit data 访问字节序
    \begin{description}
      \item[0] 小端 
      \item[1] 大端
    \end{description}
  \item[WXN] 写权限下应用不可执行权限 XN（eXecute Never）
    \begin{description}
      \item[0] 可写区域可执行
      \item[1] 可写区域强制不可执行
    \end{description}
  \item[nTWE] 不陷入 WFE，此标志为 1 表示 WFE 作为普通指令执行。
  \item[nTWI] 不陷入 WFI, 此标志为 1 表示 WFI 作为普通指令执行
  \item[UCT] 此标志为 1 时，开启 AArch64 的 EL0 下对 CTR\_EL0 寄存器访问权限。
  \item[DZE] EL0 下对 DC AVA 指令的访问权限。
    \begin{description}
      \item[0] 禁止访问
      \item[1] 允许访问
    \end{description}
  \item[I] 开启指令缓存，这是在 EL0 和 EL1 下的指令缓存的启用位。
    对可缓存的正常内存的指令访问被缓存。
  \item[UMA] 用户中断屏蔽控制，EL0 运行在 AArch64 状态下有效。
  \item[SED] 控制 AArch64 状态下的 EL0 是否可以使用 SETEND 指令。
    \begin{description}
      \item[0] 可用
      \item[1] 禁用
    \end{description}
  \item[ITD] 禁止 IT 指令
    \begin{description}
      \item[0] IT 指令有效
      \item[1] IT 指令被当作 16 位指令。
        仅另外 16 位指令或 32 位指令的头 16 位可以使用，这依赖于实现。
    \end{description}
  \item[CP15BEN] CP15 barrier 使能。
    如果实现了，它是 AArch32 CP15 DMB、DSB 和 ISB barrier 操作的使能位
  \item[SA0] EL0 的栈对齐检查使能位
  \item[SA] 栈对齐检查使能位
  \item[C] 数据 cache 使能。
    EL0 和 EL1 的数据访问使能位。
    cacheable 普通内存的数据访问都被缓存。
  \item[A] 对齐检查使能位。
  \item[M] 使能 MMU。
\end{description}

\begin{probsolu}[title={Problem and Solution \theprob}]{
    手册上写的 Explicit data access 怎么理解？}

  “Explicit data access” 是指在编程中明确地访问数据的操作。
  这意味着程序员直接指定要访问的数据和操作，而不依赖于编译器或运行时系统的隐式处理。

  这种方式通常用于对内存中的数据进行读取、写入或者其他操作。
  与之相对应的是隐式访问方式，其中编译器或者运行时系统负责管理数据的访问。
  在隐式访问中，程序员通常只需指定数据的名称，而无需关心数据的存储位置或者具体的访问方式。

\end{probsolu}

\begin{remark}
  The caches in the processor must be invalidated before caching of data and instructions is
enabled in any of the Exception levels.
\end{remark}

\BlockDesc{大小端的设置}

每个异常级别的数据的大小端都被单独控制。
对于 EL3，EL2 和 EL1，通过 SCTLR\_ELn.EE 设置大小端。
EL1 中其他位，SCTLR\_EL1.E0E 控制 EL0 的数据大小端的设置。
在 AArch64 执行状态中，数据访问可以为 LE 或 BE，但指令的获取通常为 LE。

\subsubsection{NEON 和浮点}

除了通用寄存器之外，ARMv8 还有 32 个 128 位浮点寄存器，标记为 V0-V31。
32 个寄存器用于保存标量浮点指令的浮点操作数，以及 NEON 操作的标量操作数和向量操作数。

操作数使用 H (Half)、S (Single) 和 D (Double) 分别用来指定 V 寄存器的低 16、32 和 64 位。

\subsection{ISA 概述}

ARMv8 架构中引入的最重要的变化之一是增加了 64 位指令集。
该指令集补充了现有的 32 位指令集架构。
这一指令集提供了对 64 位宽整数寄存器和数据操作的访问，以及使用 64 位内存指针的能力。
新的指令集被称为 A64，并且在 AArch64 状态下执行。
ARMv8 架构还包括原始的 ARM 指令集（现称为 A32）和 Thumb（T32）指令集。
A32 和 T32 都以 AArch32 状态执行，并且向后与 ARMv7 架构兼容。

虽然 ARMv8-A 向后兼容了 32 位 ARM 架构的特性，但 A64 指令集与旧的 ISA 指令是独立且不同的，而且他们的编码方式也不同。
A64 增加了一些额外的功能，同时也删除了其他可能限制高性能实现速度或能效的功能。
ARMv8 架构还包括对 32 位指令集（A32 和 T32）的一些增强性功能。
然而，使用这些功能的代码与旧的 ARMv7 实现不兼容。
然而，A64 指令集中的指令操作码长度仍然是 32 位，而不是 64 位。

\subsubsection{ARMv8 指令集简介}

新的 A64 指令集与 A32 类似，都是 32 bit 宽度，并且语法类似。
该指令集使用通用的命名，原先的 32-bit 指令集则成为 A32 和 T32（16-bit 指令，以性能换空间）。
运行在 AArch64 新的指令集（64-bit 操作）则命名为 A64。

A64 指令集有两种整型指令形式，即通用寄存器保存 32-bit 或是 64-bit 值。
当查看指令中的寄存器名称时，如果是 X 开头则使用的是 64-bit 值；
W 开头则是 32-bit 值。
当使用 32-bit 形式时，会有以下体现：
\begin{itemize}
  \item 右移和旋转注入在 31 位，而非 63 位。
  \item 由指令设置的状态标志是从低 32 位里计算而来。
  \item 向 W 寄存器写入时，X 寄存器的 $[63:32]$ 位自动设为 0。
\end{itemize}

64-bit 指令集极大扩展了地址空间。
因此，在程序中访问大量内存变得更加简单。
在 32-bit 的 CPU 核上执行一个线程，会将内存的访问限制在 4G 空间。
大部分地址空间保留给 OS 内核、库代码和外设等方面使用。
所以，程序会面临内存不足的问题，那么程序在执行时可能需要将内存的一些数据映射出去或映射回来。
拥有更大的内存空间，更大的 64-bit 指针，便可以避免以上问题。
而且类似内存映射文件等技术将更加具有可用性和方便性。
在这种情况下，即使文件的内容大小超出了物理 RAM 的大小，文件内容也可以映射到线程的内存中。

其它改进包括：
\begin{description}
  \item[独占访问]
  \item[增加相对 PC 的偏移地址]
  \item[支持未对齐地址]
  \item[批量传输]
  \item[加载 / 存储]
  \item[对齐检查]
\end{description}

在问题~\ref{pb:state_changing} 中，我们分析了如何状态切换。
下面我们以手册中的切换图~\ref{fig:state_changing} 来直观感受切换方式。

\Figure[caption={Switching between instruction sets}, label={fig:state_changing}, width=0.8]{state_changing}

\subsection{A64 指令集}

一般情况下我们只需要记住指令的助记符即可，不需要在意更底层的指令编码，指令编码的事情留给汇编器来完成。

我们将指令集按照其功能分类，有如下几类指令：\footnote{
  关于指令集的快速参考可以使用 \url{
    https://courses.cs.washington.edu/courses/cse469/19wi/arm64.pdf
  }
}

\begin{itemize}
  \item 数据处理指令
    % \begin{itemize}
    %   \item 算术与逻辑运算指令
    %   \item 乘法与除法指令
    %   \item 移位指令
    %   \item 位和字节操作指令
    %   \item 状态位操作指令
    % \end{itemize}
  \item 内存访问指令
  \item 流程控制指令
  \item 系统控制及其它指令
    % \begin{itemize}
    %   \item 异常处理指令
    %   \item 系统寄存器操作指令
    %   \item Debug 指令
    %   \item Hint 指令
    %   \item NEON 指令
    %   \item 浮点指令
    %   \item 加密算法指令
    % \end{itemize}
\end{itemize}

\subsubsection{数据处理指令}

\paragraph{算术与逻辑运算指令}

\begin{table}[H]
  \begin{center}
    \caption{算术和逻辑运算指令}
    \label{tbl:a64-isa-al}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      类型 & 指令 \\
      \hline
      算术 & ADD, SUB, ADC, SBC, NEG \\
      逻辑 & AND, BIC, ORR, ORN, EOR, EON \\
      比较 & CMP, CMN, TST \\
      转移 & MOV, MVN \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

另外，有些支持后缀带 S，已表明该指令会更新状态 flags。
可以配合跳转指令使用。
注意，CMP、CMN 和 TST 不带后缀 S。

\paragraph{乘法与除法指令}

\begin{table}[H]
  \begin{center}
    \caption{乘法与除法指令}
    \label{tbl:a64-isa-md}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      指令 & 说明 \\
      \hline
      & \textbf{乘法} \\
      MADD & Multiply add \\
      MNEG & Multiply negate \\
      MSUB & Multiply subtract \\
      MUL & Multiply \\
      SMADDL & Signed multiply-add long \\
      SMNEGL & Signed multiply-negate long \\
      SMSUBL & Signed multiply-subtract long \\
      SMULH & Signed multiply returning high half \\
      SMULL & Signed multiply long \\
      UMADDL & Unsigned multiply-add long \\
      UMNEGL & Unsigned multiply-negate long \\
      UMSUBL & Unsigned multiply-subtract long \\
      UMULH & Unsigned multiply returning high half \\
      UMULL & Unsigned multiply long \\
      \hline
      & \textbf{除法} \\
      SDIV & Signed divide \\
      UDIV & Unsigned divide \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

\paragraph{移位指令}

\begin{table}[H]
  \begin{center}
    \caption{移位指令}
    \label{tbl:a64-isa-so}
    \begin{tblr}{c>{\centering\arraybackslash}X}
      \hline[1pt]
      指令 & 说明 \\
      \hline
      & \textbf{移位} \\
      ASR & Arithmetic shift right \\
      LSL & Logical shift left \\
      LSR & Logical shift right \\
      ROR & Rotate right \\
      \hline
      & \textbf{转移} \\
      MOV & Move \\
      MVN & Bitwise NOT \\
      \hline[1pt]
    \end{tblr}
  \end{center}
\end{table}

下图形象展示了移位指令的动作。

\Figure[caption={移位操作}, label={fig:shift-ops}, width=1]{shift-ops}

\paragraph{位和字节操作指令}

\begin{stblr}
  {位和字节操作指令}
  {a64-isa-bB}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  指令 & 说明 \\
  \hline
  BFI rd, rn, \#p, \#n & $rd_{p+n-1:p} = rn_{n-1:0}$ \\
  BFXIL rd, rn, \#p, \#n & $rd_{n−1:0} = rn_{p+n−1:p}$ \\
  CLS rd, rn & $rd = CountLeadingOnes(rn)$ \\
  CLZ rd, rn & $rd = CountLeadingZeros(rn)$ \\
  EXTR rd, rn, rm, \#p & $rd = rn_{p−1:0}:rm_{N0}$ \\
  RBIT rd, rn & $rd = ReverseBits(rn)$ \\
  REV rd, rn & $rd = BSwap(rn)$ \\
  REV16 rd, rn & $for(n=0..1|3) rd_{Hn}=BSwap(rn_{Hn})$ \\
  REV32 Xd, Xn & $Xd=BSwap(Xn_{63:32}):BSwap(Xn_{31:0})$ \\
  \{S,U\}BFIZ rd, rn, \#p, \#n & $rd = rn^?_{n−1:0} << p$ \\
  \{S,U\}BFX rd, rn, \#p, \#n & $rd = rn^?_{p+n−1:p}$ \\
  \{S,U\}XT\{B,H\} rd, Wn & $rd = Wn^?_{N0}$ \\
  SXTW Xd, Wn & $Xd = Wn^±$ \\
  \hline[1pt]
\end{stblr}

\paragraph{状态位操作指令}

A64 支持处理器状态位有 NZCV，分别位 Negative、Zero、Carry 和 Overflow。
C flag 在无符号数操作溢出时被设置，而 V 类似，但是是在有符号数操作溢出时被设置。

\begin{ltblr}[caption={Condition codes}, label={tbl:condcode}]
  {colspec={cc>{\centering\arraybackslash}X>{\centering\arraybackslash}Xc}, width=1\textwidth}
  \hline[1pt]
  Code & Encoding & Meaning (when set by CMP) & Meaning (when set by FCMP) & Condition flags \\
  \hline
  EQ & 0b0000 & Equal to. & Equal to. & Z =1 \\
  NE & 0b0001 & Not equal to. & Unordered, or not equal to. & Z = 0 \\
  CS & 0b0010 & Carry set (identical to HS). & Greater than, equal to, or unordered (identical to HS). & C = 1 \\
  HS & 0b0010 & Greater than, equal to (unsigned) (identical to CS). & Greater than, equal to, or unordered (identical to CS). & C = 1 \\
  CC & 0b0011 & Carry clear (identical to LO). & Less than (identical to LO). & C = 0 \\
  LO & 0b0011 & Unsigned less than (identical to CC). & Less than (identical to CC). & C = 0 \\
  MI & 0b0100 & Minus, Negative. & Less than. & N = 1 \\
  PL & 0b0101 & Positive or zero. & Greater than, equal to, or unordered. & N = 0 \\
  VS & 0b0110 & Signed overflow. & Unordered. (At least one argument was NaN). & V = 1 \\
  VC & 0b0111 & No signed overflow. & Not unordered. (No argument was NaN). & V = 0 \\
  HI & 0b1000 & Greater than (unsigned). & Greater than or unordered. & (C = 1) \&\& (Z = 0) \\
  LS & 0b1001 & Less than or equal to (unsigned). & Less than or equal to. & (C = 0) || (Z = 1) \\
  GE & 0b1010 & Greater than or equal to (signed). & Greater than or equal to. & N==V \\
  LT & 0b1011 & Less than (signed). & Less than or unordered. & N!=V \\
  GT & 0b1100 & Greater than (signed). & Greater than. & (Z==0) \&\& (N==V) \\
  LE & 0b1101 & Less than or equal to (signed). & Less than, equal to or unordered. & (Z==1) || (N!=V) \\
  AL & 0b1110 & Always executed. & Default. Always executed. & Any \\
  NV & 0b1111 & Always executed. & Always executed. & Any \\
  \hline[1pt]
\end{ltblr}

有一小部份的条件数据处理指令。
这些指令是无条件执行的，但使用条件标志作为指令的额外输入。
提供这组指令是为了取代 ARM 代码中条件执行的常见用法。

\BlockDesc{加 / 减}

例如，用于多精度算术和校验和的传统 ARM 指令。

\BlockDesc{带有可选增量、否定或反转的条件选择}

有条件地在一个源寄存器和第二个增量、否定、倒置或未修改的源寄存器之间进行选择。

这些是 A32 和 T32 中单个条件指令最常见的用途。
典型的用途包括有条件计数或计算有符号数量的绝对值。

\BlockDesc{条件操作}

有别于 A32 和 T32（大多数指令可以使用条件码预测），A64 只有流程控制类的跳转指令才会使用到条件码。
A64 中使用到条件码的指令，大致可以总结为：

\begin{description}
  \item[条件选择（移动）] 包括 CSEL、CSINC、CSINV 和 CSNEG。
    \begin{itemize}
      \item CSEL 根据一个条件在两个寄存器之间进行选择。
        无条件指令，然后是条件选择，可以取代简短的条件序列。
      \item CSINC 根据一个条件在两个寄存器之间进行选择。
        返回第一个源寄存器或第二个源寄存器增加一个。
      \item CSINV 根据条件在两个寄存器之间进行选择。
        返回第一个源寄存器或倒置的第二个源寄存器。
      \item CSNEG 根据条件在两个寄存器之间进行选择。
        返回第一个源寄存器或被否定的第二个源寄存器。
    \end{itemize}
  \item[条件设置] 有条件地在 0 和 1（CSET）或 0 和 -1（CSETM）之间进行选择。
    例如，用于在一般寄存器中将条件标志设置为布尔值或掩码。
  \item[条件比较]（CMP 和 CMN）如果原始条件为真，则将条件标志设置为比较结果。
    如果不是真，条件标志将设置为指定的条件标志状态。
    条件比较指令对于表示嵌套或复合比较非常有用。
\end{description}

\subsubsection{内存访问指令}

与之前的所有 ARM 处理器一样，ARMv8 架构是一个加载 / 存储架构。
这意味着没有数据处理指令直接对内存中的数据进行操作。
数据必须首先被加载到寄存器中，进行修改，然后存储到内存中。
必须在程序中指定一个地址，要传输的数据大小，以及一个源寄存器或目标寄存器。
还有一些额外的加载和存储指令，提供了更多的选择，如非时间性的加载 / 存储，加载 / 存储排他性，以及获取 / 释放。

内存指令可以以非对齐方式访问普通内存（见 Memory ordering 章节~\ref{sec:memory-ordering}）。
但是独占访问、加载获取或存储释放等变种访问方式不支持非对齐方式访问。
如果不需要非对齐访问，可以将上述变种访问方式配置为故障（非对齐访问时产生故障异常）。

\paragraph{Load}

Load 指令的一般形式如下：

\begin{lstcode}[numbers=none, language={[ARM]Assembler}]
  LDR Rt, <addr>
\end{lstcode}

程序员可以选择加载数据的大小到整数寄存器中。
例如，要加载一个比指定的寄存器值小的尺寸，可以在 LDR 指令中加入以下对应后缀：
\begin{itemize}
  \item LDRB (8-bit, zero extend)
  \item LDRSB (8-bit, sign extend)
  \item LDRH (16-bit, zero extend)
  \item LDRSH (16-bit, sign extend)
  \item LDRSW (32-bit, sign extend)
\end{itemize}

程序员无需指定 zero-extended（高位扩展为 0）加载指令将数据加载到 X 寄存器，因为向 W 寄存器写数据会自动 zero extend 整个寄存器宽度。

\paragraph{Store}

类似的，存储指令的一般形式如下：

\begin{lstcode}[numbers=none, language={[ARM]Assembler}]
  STR Rn, <addr>
\end{lstcode}

要存储的大小同样可能比寄存器小。
那么程序员可以添加类似 LDR 指令的后缀到 STR 来指定。
在这种情况下，存储的总是寄存器中的最低有效部分。

\paragraph{浮点和 NEON 向量的 Load 和 Store}

Load 和 Store 指令同样支持访问浮点 / NEON 寄存器。
此时，仅由所加载或存储的寄存器（B、H、S、D 或 Q 寄存器中的任意一个）来决定操作大小。
具体情况总结如下表：

加载指令：

\begin{stblr}
  {加载位数}
  {load-bits}
  {cccccccc}
  \hline[1pt]
  Load & Xt & Wt & Qt & Dt & St & Ht & Bt \\
  \hline
  LDR & 64 & 32 & 128 & 64 & 32 & 16 & 9 \\
  LDP & 128 & 64 & 256 & 128 & 64 & - & - \\
  LDRB & - & 8 & - & - & - & - & - \\
  LDRH & - & 16 & - & - & - & - & - \\
  LDRSB & 8 & 8 & - & - & - & - & - \\
  LDRSH & 16 & 16 & - & - & - & - & - \\
  LDRSW & 32 & - & - & - & - & - & - \\
  LDPSW & - & - & - & - & - & - & - \\
  \hline[1pt]
\end{stblr}

存储指令：

\begin{stblr}
  {存储位数}
  {store-bits}
  {cccccccc}
  \hline[1pt]
  Store & Xt & Wt & Qt & Dt & St & Ht & Bt \\
  \hline
  STR & 64 & 32 & 126 & 64 & 32 & 16 & 8 \\
  STP & 128 & 64 & 256 & 128 & 64 & - & - \\
  STRB & - & 8 & - & - & - & - & - \\
  STRH & - & 16 & - & - & - & - & - \\
  \hline[1pt]
\end{stblr}

加载数据到浮点或 NEON 寄存器的指令没有 sign-extension 选项。
并且，地址也是由通用寄存器指定的。

例如：

\begin{lstcode}[numbers=none, language={[ARM]Assembler}]
  LDR D0, [X0, X1]
\end{lstcode}

\begin{Tcbox}[title={注}]
  浮点或向量 NEON 加载和存储指令使用和整型加载和存储指令一样的寻址模式。
\end{Tcbox}

\paragraph{Load 和 Store 指令中的地址指定}

A64 可用的寻址模式与 A32 和 T32 中的相似。
有一些额外的限制以及一些新的功能，但是对于熟悉 A32 或 T32 的人来说，A64 可用的寻址模式并不新奇。

在 A64 中，一个地址操作数的基寄存器必须总是一个 X 寄存器。
但是，有几条零扩展或符号扩展的指令可以使用以满足通过 W 寄存器来提供 32 位偏移。

\subparagraph{偏移模式}

偏移寻址模式将一个立即数或一个可选择可修改的寄存器值添加到一个 64 位的基寄存器中以产生一个地址。

\begin{stblr}
  {偏移寻址}
  {offset-addressing}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1]} & Load from the address in X1 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, \#8]} & Load from address X1 + 8 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, X2]} & Load from address X1 + X2 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, X2, LSL, \#3]} & Load from address X1 + (X2 << 3) \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, W2, SXTW]} & Load from address X1 + sign\_extend(W2) \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, W2, SXTW, \#3]} & Load from address X1 + (sign\_extend(W2) << 3) \\
  \hline[1pt]
\end{stblr}

通常，当指定移位或扩展选项时，移位量可以是 0（默认值）或 $log_2(access\; size\; in\; bytes)$（因此，$Rn <<\; <shift>$ 即是 Rn 乘以访问大小）。
所以，偏移寻址支持常见的数组索引操作。

\begin{lstcode}[numbers=none, language=C]
// A C example showing accesses that a compiler is likely to generate.
void example_dup(int32_t a[], int32_t length) {
  int32_t first = a[0];  // LDR W3, [X0]
  for (int32_t i = 1; i < length; i++) {
    a[i] = first;  // STR W3, [X0, W2, SXTW, #2]
  }
}
\end{lstcode}

\subparagraph{索引模式}

索引模式与偏移模式类似，但它们还会更新基地址寄存器。
这里的语法与 A32 和 T32 相同，但操作集的限制性更强。
通常情况下，只能为索引模式提供立即数偏移。

索引模式有两种变体：
在访问内存之前施加偏移量的预索引模式；
以及在访问内存之后施加偏移量的后索引模式。

\begin{stblr}
  {索引寻址}
  {index-addressing}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1]} & Load from the address in X1 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, \#8]!} & Pre-index: Update X1 first (to X1 + \#8), then load from the new address \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1], \#8} & Post-index: Load from the unmodified address in X1 first, then update X1 (to X1 + \#8) \\
  \lstinline[language={[ARM]Assembler}]{STP X0, X1, [SP, #-16]!} & Push X0 and X1 to the stack. \\
  \lstinline[language={[ARM]Assembler}]{LDP X0, X1, [SP], \#16} & Pop X0 and X1 off the stack. \\
  \hline[1pt]
\end{stblr}

例如，这些选项准确地映射到一些常见的 C 操作上：

\begin{lstcode}[numbers=none, language=C]
// A C example showing accesses that a compiler is likely to generate.
void example_strcpy(char * dst, const char * src)
{
  char c;
  do {
    c = *(src++);  // LDRB W2, [X1], #1
    *(dst++) = c;  // STRB W2, [X0], #1
  } while (c != '\0');
}
\end{lstcode}

\subparagraph{相对 PC 模式（load-literal）}

A64 添加了另外一个专门用于获取 literal pool 的寻址模式。
Literal pool 是编码成一个指令流的数据块。
它们不会被执行，但是其数据可以通过周围的代码相对于 PC 的内存地址获取到。
Literal pool 经常用于编码常数，而这些常数不能被塞进一个简单的 move-immediate 指令（因为留给立即数的编码位数不足）中。
A32 和 T32 指令集中，PC 寄存器可以当作一个通用寄存器来读，所以可以通过指定 PC 作为基地址寄存器简单的访问 literal pool。

In A64, PC is not generally accessible, but instead there is a special addressing mode (for load
instructions only) that accesses a PC-relative address. This special-purpose addressing mode
also has a much greater range than the PC-relative loads in A32 and T32 could achieve, so literal
pools can be positioned more sparsely.

然而，在 A64 下，PC 寄存器不可以用通常的方式获取了，但是提供了一个特殊的寻址模式（只针对 load 指令）来获取 PC 相对地址。
这个特殊作用的寻址模式也极大扩展了 PC 相对加载的范围（相比于 A32 和 T32），所以 literal pool 可以更稀疏地定位。

\begin{stblr}
  {PC 相对寻址}
  {PC-relative-addressing}
  {cc}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]{LDR W0, <label>} & Load 4 bytes from <label> into W0 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, <label>} & Load 8 bytes from <label> into X0 \\
  \lstinline[language={[ARM]Assembler}]{LDRSW X0, <label>} & Load 4 bytes from <label> and sign-extend into X0 \\
  \lstinline[language={[ARM]Assembler}]{LDR S0, <label>} & Load 4 bytes from <label> into S0 \\
  \lstinline[language={[ARM]Assembler}]{LDR D0, <label>} & Load 8 bytes from <label> into D0 \\
  \lstinline[language={[ARM]Assembler}]{LDR Q0, <label>} & Load 16 bytes from <label> into Q0 \\
  \hline[1pt]
\end{stblr}

\begin{remark}
  对于所有变体而言，<label> 都必须 4-byte 对齐。
\end{remark}

\paragraph{获取多个地址位置}

A64 没有存在于 A32 和 T32 中的 Load Multiple (LDM) 或 Store Multiple (STM) 指令。

然而，在 A64 代码中，含有 Load Pair (LDP) 和 Store Pair (STP) 指令。
与 A32 LDRD 和 STRD 指令不同的是，LDP 和 STP 可以读写任何两个整型寄存器。
LDP 和 STP 指令从相邻的内存地址读写数据。
这两个指令的内存取址模式的选项比其它内存访问指令更加受限。
它们只能使用一个基地址寄存器附加一个成比例的 7-bit 的有符号立即数，另外一个可选的预地址或后地址增加操作。
与 32-bit 的 LDRD 和 STRD 不同，LDP 和 STP 也可以进行非对齐访问。

\paragraph{非特权访问}

The A64 LDTR and STTR instructions perform an unprivileged Load or Store (see LDTR and STTR in
ARMv8-A Architecture Reference Manual):

A64 的 LDTR 和 STTR 指令用于非特权级的数据加载和存储操作。

\lstinline!LDTR rt, [Xn{, #i9}]! 相当于 $rt = [Xn += i^{\pm}, <Unpriv>]_N$

\lstinline!STTR rt, [Xn{, #i9}]! 相当于 $[Xn += i^{\pm}, <Unpriv>]_N = rt$

\begin{itemize}
  \item 在 EL0、EL2 或 EL3 中，它们表现为一般的加载或存储指令。
  \item 在 EL1 下执行这些指令，则表现为就像在 EL0 中执行一样。
\end{itemize}
 
这些指令等效于 A32 的 LDRT 和 STRT 指令。

\paragraph{预取内存访问}

\textit{Prefetch from Memory}（PRFM）指令向代码提供了一个给内存系统暗示的功能，暗示内存系统一个特定的地址将很快就会被当前程序用到。
该功能的效果\textbf{由具体实现定义}，典型的实现是将数据或指令加载到 Cache 中。

该指令的语法为：

\lstinline!PRFM <prfop>, <addr> | label!

其中 prfop 是以下选项的拼接：

\begin{description}
  \item[Type] PLD 或 PST (prefetch for load or store)。
  \item[Target] L1、L2 或 L3（以那个 Cache 为目的）。
  \item[Policy] KEEP 或 STRM（保持在 cache 中，还是作为数据流）。
\end{description}

例如，PLDL1KEEP。
这些指令与 A32 的 PLD 和 PLI 指令类似。

\paragraph{Non-temporal load and store pair}

ARMv8 增加了一个关于 non-temporal 加载和存储的新概念。
相关指令是 LDNP 和 STNP，功能是读写一对寄存器的值。
并且，它们会给内存系统一个暗示，即缓存的数据不靠谱。
该暗示阻止内存系统激活诸如地址的缓存、预加载或合并等功能。
但是，这也无法获得缓存的加速。
一个典型的用例是生产数据流，但是注意高效使用这些指令需要一种微架构的特定方式。

Non-temporal 加载和存储缓解了内存序列化的需求。
在上述例子中，即使 LDNP 指令排在 LDR 指令之后，但是也可能先被观察到。
这种情况会导致从一个不确定的存储在 X0 中的地址读到数据。
例如：

\begin{lstcode}
  LDR X0, [X3]
  LDNP X2, X1, [X0] // X0 may not be loaded when the instruction executes!
\end{lstcode}

为了解决这个问题，程序员需要放置一个 load barrier 指令。

\begin{lstcode}
  LDR X0, [X3]
  DMB nshld
  LDNP X2, X1, [X0]
\end{lstcode}

\paragraph{内存访问的原子性}

使用单个通用寄存器进行的对齐内存访问是保证为原子性的。
使用一对通用寄存器的 Load pair 和 store pair 指令进行对齐内存地址访问保证为两个独立的原子访问。
非对齐访问不具有原子性，因为它们通常需要两个独立的访问。
另外，浮点和 SIMD 内存访问不保证是原子性的。

\paragraph{内存屏障和栅栏指令}

ARMv7 和 ARMv8 都提供了不同的 barrier 操作支持。
这些操作会在~\ref{sec:memory-ordering} 更加详尽的描述。

\begin{itemize}
  \item Data Memory Barrier (DMB)。
  该指令强制所有按照程序顺序的早期内存访问变成全局可见后才会执行后续的访问操作。
  \item Data Synchronization Barrier (DSB)。
    在程序运行之前，所有挂起的加载和存储指令、Cache 维护指令和所有 TLB 维护指令都必须先完成。
    DSB 类似 DMB，但是附加了其它属性。
  \item Instruction Synchronization Barrier (ISB)。
    这个指令刷新 CPU 的流水线和预取 buffer，致使 ISB 后续的指令需要从缓存或内存中预取（或重新预取）。
\end{itemize}

ARMv8 介绍了关于释放一致性模型的单侧 fence 操作。
包括 Load-Acquire (LDAR) 和 Store-Release (STLR) 并且都是基于地址的同步原语。
这两个操作可以作为完整的 fence 成对使用。
它们只支持基地址寄存器的寻址方式，偏移或其它类型的索引寻址都不支持。

\paragraph{同步原语}

ARMv7-A 和 ARMv8-A 架构都提供了独占的内存访问操作。
A64 下是由 Load/Store exclusive (LDXR/STXR) 对提供的。
LDXR 指令从一个内存地址加载一个值，并且尝试静默的给该地址上个互斥锁。
Store-Exclusive 指令只能在获取并持有锁的情况下才能向该地址写入新值。
组合使用 LDXR/STXR 能够构建标准的同步原语，如 spinlock。
LDXRP 和 STXRP 指令对提供以允许代码自动更新一个跨越两个寄存器的地址。
可用的选项有 byte、halfword、word 和 doubleword。
这对指令与 Load Acquire/Store Release 指令对一样，只支持基地址寄存器寻址方式。
不同于 ARMv7 异常入口或返回也能够清除 monitor，CLREX 指令在 ARMv8 下专门用于清除 monitor。
Monitor 也可能虚假的被清除，例如 cache 排除操作（evictions）或其它一些与该操作无关的原因。
软件必须要避免在 LDXR 和 STXR 指令对之间含有内存访问、系统控制寄存器更新或缓存维护指令。

另外，还有一对 Acquire/Store Release 相关的互斥指令是 LDAXR 和 STLXR。
详见同步章节。

\subsubsection{流程控制指令}

A64 指令集提供一些不同类型的跳转指令（见下表~\ref{tbl:a64-isa-branch}）。
相对于当前地址偏移的简单跳转指令则使用 B 指令。
简单的无条件相对跳转指令可以基于当前地址前后跳跃 128MB。
含有条件码后缀的简单的有条件相对跳转指令的跳转范围只有 $\pm1MB$。
当函数（subroutine）调用时，则需要使用 BL 指令保存返回地址到 link 寄存器（X30）。
这个指令则没有有条件的跳转类型。
除了会保存返回地址（BL 指令的下一条指令）到寄存器（X30）外，BL 指令功能类似 B 指令。

\begin{stblr}
  {流程控制指令}
  {a64-isa-branch}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  & Branch 指令 \\
  \hline
  \lstinline!B (offset)! & Program relative branch forward or back 128MB. A conditional version, for example B.EQ, has a 1MB range. \\
  \lstinline!BL (offset)! & As B but store the return address in X30, and hint to branch prediction logic that this is a function call. \\
  \lstinline!BR Xn! & Absolute branch to address in Xn. \\
  \lstinline!BLR Xn! & As BR but store the return address in X30, and hint to branch prediction logic that this is a function call. \\
  \lstinline!RET{Xn}! & As BR, but hint to branch prediction logic that this is a function return. Returns to the address in X30 by default, but a different register can be specified. \\
  \hline
  & Conditional branch 指令 \\
  \hline
  \lstinline!CBZ Rt, label! & Compare and branch if zero. If Rt is zero, branch forward or back up to 1MB. \\
  \lstinline!CBNZ Rt, label! & Compare and branch if non-zero. If Rt is not zero, branch forward or back up to 1MB. \\
  \lstinline!TBNZ Rt, bit, label! & Test and branch if zero. Branch forward or back up to 32kB. \\
  \lstinline!TBNZ Rt, bit, label! & Test and branch if non-zero. Branch forward or back up to 32kB. \\
  \hline[1pt]
\end{stblr}

除了相对 PC 的跳转指令外，A64 指令集也包含了两个绝对跳转指令。
\lstinline!BR Xn! 指令执行一个到 Xn 寄存器的绝对跳转。
同时，\lstinline!BLR Xn! 也是类似的绝对跳转功能，但是它会保存返回地址到 link 寄存器 X30 中。
\lstinline!RET! 指令行为上类似 \lstinline!BR Xn!，但是它会暗示跳转预测逻辑它执行的是一个函数返回。
尽管 \lstinline!RET! 指令可以指定其它跳转目的寄存器，但是它默认使用 X30 所保存的跳转目的地址。

A64 指令集还包括一些特别的条件跳转指令。
这些指令能在一些情况下提高代码的密度，因为在这些情况下没必要做明确的比较。

\begin{itemize}
  \item \lstinline!CBZ Rt, label! \quad Compare and branch if zero
  \item \lstinline!CBNZ Rt, label! \quad Compare and branch if not zero
\end{itemize}

这些指令先将 32-bit 或 64-bit 源寄存器与 0 进行比较，然后执行条件跳转。
跳转的偏移范围是 $\pm1MB$。
这些指令不会读或写状态码（NZCV）。

有两个类似的检测并跳转的指令：

\begin{itemize}
  \item \lstinline!TBZ Rt, bit, label! \quad Test and branch if Rt<bit> zero
  \item \lstinline!TBNZ Rt, bit, label! \quad Test and branch if Rt<bit> is not zero
\end{itemize}

这些指令检测由立即数指定的 bit 位与源寄存器中的 bit 位是否满足条件（Z 或 NZ），然后通过检测结果跳转。
这个跳转指令的偏移范围是 $\pm32KB$。
这两个指令与 CBZ/CBNZ 一样不会读写状态码（NZCV）。

\subsubsection{系统控制及其它指令}

\BlockDesc{异常处理指令}

A64 有三个异常处理指令用于产生一个异常。
这些指令用于产生一个高异常级的代码调用，分别是 OS（EL1）、Hypervisor（EL2）和 Secure Monitor（EL3）：

\begin{itemize}
  \item \lstinline!SVC \#imm16! \quad Supervisor 调用，允许应用程序调用内核代码。
  \item \lstinline!HVC \#imm16! \quad Hypervisor 调用，允许 OS 代码 调用 hypervisor (EL2)。
  \item \lstinline!SMC \#imm16! \quad Secure Monitor 调用，允许 OS 或 hypervisor 调用 Secure Monitor (EL3)。
\end{itemize}

立即数存放 \textit{Exception Syndrome Register} 里的 handler 中。
这是一个从 ARMv7 的改动，ARMv7 的立即数需要由所调用指令的 opcode 确定。
详情请看章节~\ref{sec:exception}。

若要从异常返回，则使用 \lstinline!ERET! 指令。
该指令从过将 SPSR\_ELn 寄存器复制到 PSTATE 来恢复处理器状态，并且跳转到保存在 ELR\_ELn 中的地址继续运行。

\BlockDesc{系统寄存器访问指令}

有两条可以访问系统寄存器的指令：
\begin{itemize}
  \item \lstinline!MRS Xt, <system register>! \quad 读取系统寄存器的值到通用寄存器。

    例如 \lstinline!MRS X4, ELR_EL1 // Copies ELR_EL1 to X4!
  \item \lstinline!MSR <system register>, Xt! \quad 写入通用寄存器中的配置值到系统寄存器。

    例如 \lstinline!MSR SPSR_EL1, X0 // Copies X0 to SPSR_EL1!
\end{itemize}

MSR 或 MRS 也可以单独获取 PSTATE 寄存器中的 field。
例如，选择关联于 EL0 的 Stack Pointer 或当前的异常级：

\begin{lstcode}[numbers=none]
  // A value of 0 or 1 in this register is used to select
  // between using EL0 stack pointer or the current exception
  // level stack pointer
  MSR SPSel, #imm
\end{lstcode}

这两个指令有一些特殊的形式可以用于清除或设置独立的异常掩码位：

\begin{lstcode}[numbers=none]
  MSR DAIFClr, #imm4
  MSR DAIFSet, #imm4
\end{lstcode}

\BlockDesc{Debug 指令}

A64 有两个调试相关的指令：

\begin{lstcode}[numbers=none]
  // Enters monitor mode debug, where there is on-chip debug monitor
  // code
  BRK #imm16
  // Enters halt mode debug, where external debug hardware is connected
  HLT #imm16
\end{lstcode}

\BlockDesc{Hint 指令}

HINT 指令可以被合理的视作 NOP，但是注意这些指令受特定实现的影响。


\begin{stblr}
  {Hint 指令}
  {a64-isa-hint}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  指令 & 说明 \\
  \hline
  NOP & No operation - not guaranteed to take time to execute \\
  YIELD & Hint that the current thread is performing a task that can be swapped out \\
  WFE & Wait for Event \\
  WFI & Wait for interrupt \\
  SEV & Send Event \\
  SEVL & Send Event Local \\
  \hline[1pt]
\end{stblr}

\BlockDesc{NEON 指令}

NEON 指令在 A64 下也有很大加强，有些加强至关重要。
章节~\ref{sec:floating-neon} 有更多的说明细节，下面简单列出 NEON 在 A64 下的改进：

\begin{itemize}
  \item 支持双精度浮点类型，向量化 C 代码下的双精度浮点类型。
  \item 新增将标量数据存储到 NEON 寄存器的指令。
  \item 新增插入和提取向量元素的指令。
  \item 新增类型转换和饱和整型算术运算指令。
  \item 新增浮点数值正规化（normalization）指令。
  \item 新增向量 reduction、summation 和获取最大最小值的 cross-lane 指令。
\end{itemize}

已经扩展了诸如比较、加法、查找绝对值和否定（negate）等指令，得以操作 64-bit 元素。

\BlockDesc{浮点指令}

A64 提供了一些类似 ARMv7 VFPv4 扩展的浮点指令，这些指令提供了对标量浮点值之间的单精度和双精度数学运算。
以下列举了一些改进和新特性：

\begin{itemize}
  \item 浮点比较直接设置状态码（NZCV）。
    A64 下不用在特意转换浮点 flag 为整型 flag。
  \item 添增了关于 IEEE754 - 2008 标准的指令，例如计算一对数字的最小值和最大值。
  \item 转换整型数据到浮点型时，可以明确指定为 rounding 模式。
    在特别的 rounding 模式下进行的简单转换，已不再需要设置全局 FPCR flag。
    ARMv8 的 A32 和 T32 也支持其中一些选项。
  \item 新增 64-bit 整型到浮点型格式转换指令。
  \item A64 下，直接在整型寄存器中进行涉及整型的浮点操作。
    进行转换操作时，已不再需要手动转换整型值和浮点值以及整型寄存器。
\end{itemize}

\BlockDesc{加密算法指令}

可以通过添加可选的加密算法指令扩展来极大的提升关于 AES 加密、SHA1 和 SHA256 hashing 等任务的效率。

\subsection{浮点与 NEON} \label{sec:floating-neon}

ARM 架构下，软件支持的高级 SIMD 架构的关联实现称为 NEON 技术。
AArch32（相当于 ARMv7 NEON 指令）和 AArch64 都含有 NEON 指令集。
AArch32 和 AArch64 下的 NEON 指令都可以加速大数据量的重复操作。
经典的应用是多媒体数字信号编解码。

AArch64 的 NEON 架构使用 32 个 128-bit 寄存器，是 ARMv7 的两倍。
浮点指令也使用同样的寄存器。
所有编译的代码和子程序都遵循 EABI，EABI 定义了在特殊的子程序中哪些寄存器可以被写入使用（corrupt，可以被破坏意为能被写入使用），哪些寄存器需要保留。
编译器可以自由的在代码任意点使用 NEON/VFP 寄存器保存浮点数和 NEON 数据。
所有的标准的 ARMv8 实现都需要包括浮点和 NEON。
但是，面向特殊用途的实现中可以采取以下组合：
\begin{itemize}
  \item 不实现 NEON 或浮点
  \item 完全实现包含异常的浮点和 SIMD。
  \item 实现不包含异常的浮点和 SIMD。
\end{itemize}

\BlockDesc{NEON 和浮点新特性}

AArch64 NEON 是基于 AArch32 NEON，包括以下改动：
\begin{itemize}
  \item 从 16 个寄存器增加到 32 个。
  \item 长度大的寄存器不再是通过长度小的寄存器组合而成，而是将 128-bit 的寄存器的低有效位映射为长度较小的寄存器。
    单精度的浮点数使用 128-bit 寄存器的低 32 位，双精度数使用用低 64 位。
  \item 去掉 V 前缀。
  \item 向向量寄存器中写入小于等于 64 bit 的数据，寄存器的高位则被清零。
  \item AArch64 下不存在使用通用寄存器的 SIMD 或饱和运算指令\footnote{
      饱和指令（Saturating instructions）是一类特殊的指令，用于执行饱和运算。
      饱和运算是一种数学运算，它限制结果在一个特定的范围内，超出范围的值将被截断或限制在范围边界上。

      例如，在使用 8 位无符号整数表示的情况下，如果一个运算结果大于 255（即超出了 8 位无符号整数的范围），则饱和运算将结果限制为 255。
      类似地，如果结果小于 0，则饱和运算将结果限制为 0。

      饱和指令通常用于数字信号处理（DSP）和媒体处理等应用中，这些应用对数据精度和动态范围有严格的要求。
      使用饱和指令可以确保结果不会溢出，并且可以避免由于溢出而引起的意外行为或失真。
    }。
    这些操作全部使用 NEON 寄存器。
  \item 新增 lane 插入和提取指令以支持新的寄存器 pack 模式。
  \item 添加额外的指令用于生产或消费 128-bit 向量寄存器的高 64 bit。
    会产生多于一个寄存器的结果（扩展到 256-bit 向量）或者消耗两个源（收缩成一个向量）的数据处理指令已经划分成不同的指令。
  \item 新增向量 reduction 操作集，提供 across-lane 加法、最小值和最大值操作。
  \item 扩展一些已有的指令以支持 64-bit 整数。
    例如：比较、加法、取绝对值和否定等指令，并且包括 staturating 版本。
  \item 扩展饱和指令，以便在无符号累加和有符号累加之间进行转换（to include Unsigned Accumulate into Signed, and Signed into Unsigned Accumulate）。\footnote{
      表明饱和指令现在具有更多的灵活性，可以在有符号累加和无符号累加之间进行转换，并在结果溢出时执行饱和处理，以确保结果在指定的范围内。
    }
  \item AArch64 NEON 现已支持双精度类型的浮点数和完整的 IEEE754 操作，包括 rounding 模式、非规范化数字和 NaN 处理。
\end{itemize}

AArch64 加强了浮点功能，改动如下（相对于 ARMv7）：

\begin{itemize}
  \item 前缀 V 替换成 F。
  \item 先已支持 IEEE754 浮点标准定义的单精度（32-bit）和双精度（64-bit）浮点向量数据类型和运算。
    遵循 FPCR 寄存器中指定的舍入模式来执行浮点数运算\footnote{
      “Honoring the FPCR Rounding Mode field” 表示处理器或者软件库遵循浮点控制寄存器（Floating Point Control Register，FPCR）中的舍入模式字段（Rounding Mode field）。

      在 IEEE 754 浮点数标准中，舍入模式指定了在进行浮点数运算时如何处理结果的舍入方式。
      常见的舍入模式包括向最接近的偶数舍入、向正无穷大舍入、向负无穷大舍入、向零舍入等。
    }
    、默认的 NaN 控制、Flush-to-Zero 控制\footnote{
      Flush-to-Zero 控制允许在执行浮点数运算时将非常小的结果舍入为零。
      当启用 Flush-to-Zero 模式时，如果计算得到的结果小于一个设定的阈值（通常是一个非常小的正数，例如 IEEE 754 中的 subnormal number），则结果将被直接截断为零，而不是保留非常小的非零值。
    }
    和异常 trap 使能位（由具体实现所支持）。
  \item FP/NEON 寄存器的 Load/Store 寻址模式与整型的 Load/Store 相统一，包括加载或存储一对浮点寄存器的操作。
  \item 添加与整型 CSEL 和 CCMP 指令等效的浮点 FCSEL 和 选择并比较指令。

    类似 ARMv7，浮点 FCMP、FCMPE、FCCMP 和 FCCMP 指令根据浮点比较结果设置 PSTATE.\{N, Z, C, V\} 标志，但是不会更改 FPSR 寄存器中的状态标志。
  \item 合并所有浮点乘加（Multiply-Add）和乘减（Multiply-Subtract）指令\footnote{
      “Fused Multiply-Add (FMA)” 指的是在单个指令中执行乘加运算的能力。
      这意味着指令可以同时进行乘法和加法操作，并且结果是精确的。
      这样可以提高性能，并且在一些情况下可以提高数值计算的精度。

      该变化意味着所有的浮点数乘加和乘减指令都支持 FMA 功能。
      也就是说，这些指令在执行乘加或乘减运算时，都能够同时进行乘法和加法（或减法），而不需要将乘法结果存储到临时变量中再进行加法或减法操作。

      使用 FMA 指令可以提高性能，因为它可以将乘法和加法操作合并为一个指令，并且可以在硬件级别上并行执行这两个操作。
      这样可以减少指令的数量，降低了指令调度和执行的开销，并且可以提高代码的并行性。
    }。

    VFPv4 首次介绍了 Fused multiply，这个功能意味着在执行加法运算前不会近似乘法运算的结果。
    早期的 ARM 浮点架构乘法累加操作对中间结果和最终结果都会进行近似，导致潜在的精度丢失。

  \item 新增转换操作，例如：64-bit 整型和单精度及双精度浮点型数据转换。
    转换浮点到整型数据（FCVTxU、FCVTxS）的指令有如下的有向舍入编码模式：

    \begin{itemize}
      \item[-] 到 0。
      \item[-] 到 $+\inf$。
      \item[-] 到 $-\inf$。
      \item[-] 到一个接近的偶数。
      \item[-] 到更远离零的那个整数\footnote{在 “Nearest with ties to away” 这种舍入模式下，如果一个值恰好处于两个整数的中间，它会舍入到远离零的整数。
          换句话说，如果一个值恰好处于两个整数的中间，它会舍入到更远离零的那个整数。
        }。
    \end{itemize}
  \item 新增包含相同有向舍入模式并且可根据当前环境进行舍入的浮点向邻近整型舍入的指令（FRINTx）。
  \item 新增不精确的舍入到奇数的双精度到单精度向下转换指令，适合通过正确的近似（FCVTXN）进行现场向下转换到半精度类型。
  \item 添加了 FMINNM 和 FMAXNM 指令，这两个指令用来实现 IEEE754 - 2008 中的操作 minNum() 和 maxNum()。
  如果其中一个操作数是静态 NaN，则返回数值。
  \item 新增浮点向量规范化加速指令（FRECPX 和 FMULX）。
\end{itemize}

\subsubsection{NEON 和 Floating-Point 架构}

NEON 寄存器保存有相同数据类型的元素组成的向量。
一个向量被分成许多 lane，每个 lane 含有一个成为元素（element）的数据值。

NEON 向量的 lane 数量取决于向量的大小和向量中的数据元素。

通常，每个 NEON 指令会产生 n 个并行操作，n 是输入向量分成的 lane 数量。
从一个 lane 到另外一个 lane 不能涉及进位或溢出。
向量的元素顺序是从最低有效位开始，说明元素 0 使用寄存器的最低有效位。

NEON 和 浮点指令操作适用于以下类型的元素：

\begin{itemize}
  \item 32-bit 单精度和 64-bit 双精度浮点类型。
    \begin{Tcbox}[title={Note}]
      16-bit 浮点类型也是支持的，但是只能作为一种被转换的类型，而不能被直接处理。
    \end{Tcbox}
  \item 8-bit、16-bit、32-bit 或 64-bit 的无符号和有符号整型。
  \item 8-bit 和 16-bit 多项式。

    多项式类型用于代码，例如使用 2 的幂有限域\footnote{
      有限域（Finite Field）算术是一种在有限域上进行的数学运算。
      有限域也称为 Galois 域，是一个包含有限数量元素的数学结构。
      在有限域中，加法和乘法运算满足特定的性质，类似于实数域或复数域中的运算。

      有限域中的元素可以是整数模素数的余数，也可以是多项式系数模一个不可约多项式的余数。
      在密码学、编码理论、数字通信等领域，有限域的理论和运算被广泛应用。
    }
    或者在 \{0, 1\} 上的简单多项式的错误纠正。
    通常的 ARM 整型代码一般使用查表的方式进行有限域运算。
    而 AArch64 NEON 则提供了使用巨大查找表的指令。

  \item 多项式运算很难从其他运算中合成出来，因此拥有一个基本的乘法运算非常有用，可以从中合成其他更大的运算。
\end{itemize}

NEON 单元将寄存器文件视作：

分别视作 32 个 128-bit 四字寄存器 V0-V31 为：

\Figure[caption={V 寄存器拆分}, label={fig:v-reg-div}, width=0.95]{divisions-of-the-v-regs}

分别视作 32 个 64-bit 双字寄存器 D0-D31 为：

\Figure[caption={D 寄存器拆分}, label={fig:d-reg-div}, width=0.95]{divisions-of-the-d-regs}

可以在任意时间访问这些寄存器。
由于所使用的指令决定了合适的视角（view），所以软件不需要明确地调整当前该使用哪种寄存器。

\paragraph{Floating-Point}

AArch64 的浮点单元将 NEON 寄存器文件视作：

\begin{itemize}
  \item 32 个 64-bit D 寄存器 D0-D31。
    D 寄存器称为双精度寄存器，可以保存双精度浮点数。
  \item 32 个 32-bit S 寄存器 S0-S31。
    S 寄存器称为单精度寄存器，可以保存单精度浮点数。
  \item 32 个 16-bit H 寄存器 H0-H31。
    H 寄存器称为半精度寄存器，可以保存半精度浮点数。
  \item 以上视角的寄存器合并。
\end{itemize}

\Figure[caption={浮点寄存器的拆分}, label={fig:fp-reg-div}, width=0.95]{fp-reg-div}

\paragraph{标量数据和 NEON}

The general array notation to access individual elements of a vector is:

标量数据是一个单一值，而非包含在向量中的多个值。
一些 NEON 指令使用标量操作数。
寄存器中的标量的获取通过向量的索引。

以通用的数组形式访问向量中的单个元素的格式如下：

\lstinline!<Instruction> Vd.Ts[index1], Vn.Ts[index2]!

其中，

\begin{itemize}
  \item[] Vd 是目的寄存器。
  \item[] Vn 是第一个源寄存器。
  \item[] Ts 用于指定元素的大小。
  \item[] index 是元素的索引。
\end{itemize}

例如：

\lstinline[language={[ARM]Assembler}]!INS V0.S[1], V1.S[0]!

\Figure[caption={插入一个元素到向量}, label={fig:insert-an-element-into-a-vector}, width=0.95]{insert-an-element-into-a-vector}

\lstinline!MOV V0.B[3], W0! 指令操作是将 W0 寄存器中的最低有效 byte 拷贝到 V0 寄存器的第四个 byte 位置中。

\Figure[caption={移动一个标量数到一个 lane}, label={fig:moving-a-scalar-to-a-lane}, width=0.95]{moving-a-scalar-to-a-lane}

NEON 标量可以是 8-bit、16-bit、32-bit 或是 64-bit 数值。
除了乘法指令外，其它指令都可以从寄存器文件中获取任意元素做为标量。

乘法指令只允许 16-bit 或 32-bit 标量，并且只能获取到寄存器文件中的前 128 个标量：

\begin{itemize}
  \item 16-bit 标量限制在寄存器 \lstinline!Vn.H[x]!，其中 $0 \leq n \leq 15$。
  \item 32-bit 标量限制为寄存器 \lstinline!Vn.S[x]!。
\end{itemize}

\paragraph{Floating-Point 参数}

浮点数值通过浮点寄存器传输给函数（或者返回来）。
可以同时使用整型（通用）和浮点寄存器。
也就是说，浮点参数则以 H、S 或 D 寄存器传输，其它参数则通过 X 或 W 寄存器。
AArch64 调用标准强制规定只要使用到浮点运算的地方就必须使用硬件浮点运算，所以没有软件相关的浮点运算库。

详细的指令参考《ARMv8-A Architecture Reference Manual》，下面列举了一些浮点数据处理操作：

\begin{ltblr}
  {colspec={c>{\centering\arraybackslash}X}, width=1\textwidth}
  \hline[1pt]
  \lstinline!FABS Sd, Sn! & Calculates the absolute value. \\
  \lstinline!FNEG Sd, Sn! & Negates the value. \\
  \lstinline!FSQRT Sd, Sn! & Calculates the square root. \\
  \lstinline!FADD Sd, Sn, Sm! & Adds values. \\
  \lstinline!FSUB Sd, Sn, Sm! & Subtracts values. \\
  \lstinline!FDIV Sd, Sn, Sm! & Divides one value by another. \\
  \lstinline!FMUL Sd, Sn, Sm! & Multiplies two values. \\
  \lstinline!FNMUL Sd, Sn, Sm! & Multiplies and negates. \\
  \lstinline!FMADD Sd, Sn, Sm, Sa! & Multiplies and adds (fused). \\
  \lstinline!FMSUB Sd, Sn, Sm, Sa! & Multiplies, negates and subtracts (fused). \\
  \lstinline!FNMADD Sd, Sn, Sm, Sa! & Multiplies, negates and adds (fused). \\
  \lstinline!FNMSUB Sd, Sn, Sm, Sa! & Multiplies, negates and subtracts (fused). \\
  \lstinline!FPINTy Sd, Sn! & Rounds to an integral in floating-point format (where y is one of a number of rounding mode options) \\
  \lstinline!FCMP Sn, Sm! & Performs a floating-point compare. \\
  \lstinline!FCCMP Sn, Sm, \#uimm4, cond! & Performs a floating-point conditional compare. \\
  \lstinline!FCSEL Sd, Sn, Sm, cond! & Floating-point conditional select if (cond) Sd = Sn else Sd = Sm. \\
  \lstinline!FCVTSty Rn, Sm! & Converts a floating-point value to an integer value (ty specifies type of rounding). \\
  \lstinline!SCVTF Sm, Ro! & Converts an integer value to a floating-point value. \\
  \hline[1pt]
\end{ltblr}

\subsubsection{AArch64 NEON 指令格式}

AArch64 改动了 NEON 和浮点指令的语法以协调核心整型和标量浮点指令集语法。
这些指令的助记符和 ARMv7 NEON 非常接近。

\begin{itemize}
  \item 移除 ARMv7 NEON 指令中存在的前缀 V。

    重命名了与核心指令集冲突的助记符，并且移除 V 前缀。

    这意味相同名字的指令会做相同的事情，并且可以是核心指令、NEON 指令或者浮点指令，而只是语法上有区别。
    例如：

    \lstinline!ADD W0, W1, W2{, shift #amount}!
    和
    \lstinline!ADD X0, X1, X2{, shift #amount}!

    都是 A64 基础指令。

    \lstinline!ADD D0, D1, D2!

    是一个标量浮点指令，并且

    \lstinline!ADD V0.4H, V1.4H, V2.4H!

    是一个 NEON 向量指令。

  \item 指令的前缀上添加了 S、U、F 或 P 前缀，用以表示 Signed、Unsigned、Floating-point 或 Polynomial 数据类型。
    指令根据该助记符来选择相应数据类型的操作。
    例如：

    \lstinline!PMULL V0.8B, V1.8B, V2.8B!

  \item 寄存器修饰符描述向量寄存器的组织形式（元素大小和 lane 数量）。
    例如：

    \lstinline!ADD Vd.T, Vn.T, Vm.T!

    其中，Vd、Vn 和 Vm 都是寄存器的名字，而 T 则是将被使用到的寄存器细分。
    就此例而言，T 是做为排列说明符 8B、16B、4H、8H、2S、4S 或 2D 中的一个。
    任意上述的排列说明符都可以使用，取决于数据类型的宽度（64、32、16 或 8-bit）以及寄存器的位宽（64 bit 或 128 bit）。

    若要对 2 个 64-bit 的 lane 相加，则是用

    \lstinline!ADD V0.2D, V1.2D, V2.2D!

  \item ARMv7 中，一些 NEON 数据处理指令存在 Normal、Long、Wide、Narrow 和 Staturating 变种。
    Long、Wide 和 Narrow 变种以后缀标识：

    \begin{itemize}
      \item[-] \textit{Normal 指令}可以对任何向量类型进行操作，并生成与操作数向量相同大小且通常相同类型的结果向量。
      \item[-] \textit{Long 指令}或 \textit{Lengthening 指令}对双字向量操作数进行操作并产生四字向量结果。
        结果元素的宽度是操作数的两倍。
        长指令使用附加到指令的 L 来指定。
        例如：

        \lstinline!SADDL V0.4S, V1.4H, V2.4H!

        下图展示了该操作，输入操作数在运算之前被提升。

        \Figure[caption={NEON Long 指令}, label={fig:NEON-long-insts}, width=0.6]{NEON-long-insts}

    \end{itemize}

  \item \textit{Wide} 或 \textit{Widening 指令}对双字和四字向量操作数进行操作，产生四字向量。
    产生的结果元素（第一个操作数）的长度是第二个操作数元素长度的两倍。
    Wide 指令含有一个 W 后缀。例如，

    \lstinline!SADDW V0.4S, V1.4H, V2.4S!

    下图展示该操作，输入的双字操作数在运算前被提升。

    \Figure[caption={NEON Wide 指令}, label={fig:NEON-wide-insts}, width=0.6]{NEON-wide-insts}

  \item \textit{Narrow} 或 \textit{Narrowing 指令}对四字向量进行操作，并且生成双字向量。
    生产的元素通常为操作数元素长度的一半。
    Narrow 指令用 N 后缀指定。例如，

    \lstinline!SUBHN V0.4H, V1.4S, V2.4S!

    下图展示该操作，输入操作数在运算前被降级。

    \Figure[caption={NEON Narrow 指令}, label={fig:NEON-narrow-insts}, width=0.6]{NEON-narrow-insts}

  \item 一些指令存在 Signed 和 unsigned staturating 变种（以 SQ 或 UQ 前缀标识），比如 SQADD 和 UQADD。
    如果结果超出了数据类型的最大值或最小值，那么 saturating 指令则返回其最大值或最小值。
    Saturation 的限制取决于指令所用的数据类型。

    \begin{stblr}
      {Saturation ranges}
      {NEON-saturation-ranges}
      {cc}
      \hline[1pt]
      Data type & Saturation range of x \\
      \hline
      Signed byte (S8) & $-27 \leq x < 27$ \\
      Signed halfword (S16) & $-215 \leq x < 215$ \\
      Signed word (S32) & $-231 \leq x < 231$ \\
      Signed doubleword (S64) & $-263 \leq x < 263$ \\
      Unsigned byte (U8) & $0 \leq x < 28$ \\
      Unsigned halfword (U16) & $0 \leq x < 216$ \\
      Unsigned word (U32) & $0 \leq x < 232$ \\
      Unsigned doubleword (U64) & $0 \leq x < 264$ \\
      \hline[1pt]
    \end{stblr}

  \item ARMv7 中示意为 pairwise 操作的 P 前缀现已在 ARMv8 中改成后缀，比如 ADDP。
    Pairwise 指令操作相邻的双字或四字操作数对。
    例如：

    \lstinline!ADDP V0.4S, V1.4S, V2.4S!

    \Figure[caption={Pairwise 操作}, label={fig:pairwise-op}, width=0.6]{pairwise-op}

  \item 添加 V 后缀到 across-all-lanes（整个寄存器）操作，比如 ADDV。
    例如：

    \lstinline!ADDV S0, V1.4S!

    \Figure[caption={Across all lanes 操作}, label={fig:across-all-lanes-op}, width=0.6]{across-all-lanes-op}

  \item 为新的加宽、缩小或加长的第二部分指令添加了 2 后缀，称为第二和上半部分说明符。
    如果存在该后缀，那么相应的操作会保持较窄元素的寄存器的高 64 位上执行操作。

    \begin{itemize}
      \item[-] 带有 2 后缀的加宽指令从包含较窄值的向量的高编号通道获取输入数据，并将扩展结果写入 128 位目标。
        例如：

        \lstinline!SADDW2 V0.2D, V1.2D, V2.4S!

        \Figure[caption={SADDW2}, label={fig:saddw2-inst}, width=0.6]{saddw2-inst}

      \item[-] 带有 2 后缀的 Narrowing 指令从 128-bit 的源操作数获取它们的输入数据，并且将缩小后的结果插入到 128-bit 目的寄存器的高序 lane 中，低序 lane 保持不变。
        例如：

        \lstinline!XTN2 V0.4S, V1.2D!

        \Figure[caption={XTN2}, label={fig:xtn2-inst}, width=0.6]{xtn2-inst}

      \item[-] 带有 2 后缀的 Lengthening 指令从 128-bit 源向量寄存器的高序 lane 中获取它们的输入数据，并将加长的结果保存到 128-bit 目的寄存器中。
        例如：

        \lstinline!SADDL2 V0.2D, V1.4S, V2.4S!

        \Figure[caption={SADDL2}, label={fig:saddl2-inst}, width=0.6]{saddl2-inst}
    \end{itemize}

  \item 比较指令已通过使用状态码来表明当前状态，以及当前状态是有符号的还是无符号的。
    例如，CMGT 和 CMHI、CMGE 和 CMHS。

\end{itemize}

\subsubsection{NEON 编码替代方案}

NEON 编码有很多种形式。
本节只是简单的列举以下（详细内容可查看《ARM NEON Programmers Guide》）。
其中包括内部函数的使用、C 代码的自动矢量化、库的使用，当然还有直接用汇编语言编写。
内在函数是编译器用适当的 NEON 指令替换的 C 或 C++ 伪函数调用。
这允许您使用 NEON 实现中可用的数据类型和操作，同时允许编译器处理指令调度和寄存器分配。
这些 intrinsic 函数定义在 ARM C 语言扩展文档里。
ARM 编译器 6 下，Auto-vectorization 由 \lstinline!-fvectorize! 选项配置，然而高级优化中该选项是自动打开的（\lstinline!-O2! 和更高）。
只要 \lstinline!-O0! 选项开启，无论指不指定 \lstinline!-fvectorize! Auto-vectorization 都是关闭的。
因此您需要在 \lstinline!-O1! 优化下通过以下命令开启 auto-vectorization：

\lstinline!armclang --target=armv8a-arm-none-eabi -fvectorize -O1 -c file.c!

有多个支持 NEON 代码的软件库。
这些库随时间动态更新，因此其状态也无法把控，所以当前的支持情况并没有列举到该文档中。
虽然技术上而言，手动优化 NEON 汇编代码是可行的，但是由于流水线和内存访问时序的内部复杂依赖，手动优化是非常困难的。
ARM 强烈推荐直接使用 intrinsic 调用函数，而不是手写汇编。

\begin{itemize}
  \item 使用 instrinsic 函数比使用汇编助记符更简单。
  \item Instrinsic 函数提供了很好的跨平台可移植性。
  \item 使用 instrinsic 不需要关心内部流水线和内存访问时序。
  \item 大多数情况下能够或得很好的性能。
\end{itemize}

如果您不是一个经验丰富的汇编开发者，那么使用 intrinsic 通常能获得更好的性能。
Intrinsic 提供了和直接用汇编编写代码一样丰富的控制，但是把分配寄存器的任务分配给了编译器，因此您可以专注与算法。
这样会比汇编语言具有更好的代码维护性。

\subsection{ABI}

\subsection{异常处理} \label{sec:exception}

\BlockDesc{The Exception Syndrome Register}

% The Exception Syndrome Register, ESR_ELn, contains information which allows the exception handler to determine the reason for the exception. It is updated only for synchronous exceptions and SError. It is not updated for IRQ or FIQ as these interrupt handlers typically obtain status information from registers in the Generic Interrupt Controller (GIC). (See The Generic Interrupt Controller.) The bit coding for the register is:
%
% Bits [31:26] of ESR_ELn indicate the exception class which allows the handler to distinguish between the various possible exception causes (such as unallocated instruction, exceptions from MCR/MRC to CP15, exception from FP operation, SVC, HVC or SMC executed, Data Aborts, and alignment exceptions).
%
% Bit [25] indicates the length of the trapped instruction (0 for a 16-bit instruction or 1 for a 32-bit instruction) and is also set for certain exception classes.
%
% Bits [24:0] form the Instruction Specific Syndrome (ISS) field containing information specific to that exception type. For example, when a system call instruction (SVC, HVC or SMC) is executed, the field contains the immediate value associated with the opcode such as 0x123456 for SVC 0x123456.

\subsection{Caches}

\subsection{MMU}

\subsection{Memory ordering} \label{sec:memory-ordering}

\subsection{SMP}

\subsection{Others}

\section{RISC-V}

\subsection{Privileged Architecture}

\subsection{Unprivileged ISA}

\section{内存层级}

% vim:set ts=8 sts=2 sw=2 et:
