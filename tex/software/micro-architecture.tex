\chapter{微处理器体系架构}

如果暂时撇开硬件不谈，可以说微处理器体系架构属于嵌入式开发的最底层的硬件知识。
我暂时还说不清楚这部分知识属于 EE，还是 CS。
但是，可以肯定我们从处理器架构手册中获取的芯片运行原理等信息与处理器的开发有交集，
只是说处理器的开发需要更加详尽且完善的知识体系，而紧贴处理器硬件的软件开发也需要这部分原理知识以便正确且高效的使用相关的处理器。

微处理器体系架构方面的知识建立了处理器硬件与软件的桥梁，是嵌入式开发所绕不开的话题。
所以，我们从微处理器体系架构开始，逐步的完善并建立嵌入式开发的基础知识体系。

本章主要根据相关的编程和架构手册来讲述两种微处理器架构，一种是目前占市场主导地位的 ARMv8 架构，另外一种则是开源的 RISC-V 指令集架构。
之所以选择这两种指令集架构进行学习，是因为它们的流行度和潜力。

下面让我们从 ARMv8 开始。

\section{ARMv8}

ARM 公司在 2013 年发布了它的 64-bit ARMv8 架构。
ARMv8 实现了 32-bit ARMv7 的兼容。
做出了以下重要升级：\footnote{
  这里翻译或讲述的原版手册是 {ARM® Cortex®-A Series Programmer’s Guide for ARMv8-A}\cite{armpg}
}

\begin{description}
    \item[Large physical address] 更大的物理内存，使处理器能够访问超过 4GB 的物理内存。
    \item[64-bit virtual addressing] 使虚拟内存突破 4GB 限制。
    这对于使用内存映射文件 I/O 或稀疏寻址的现代桌面和服务器软件很重要。
    \item[Automatic event signaling] 可以实现节能、高性能的自旋锁。
    \item[Larger register files] 31 个 64 位通用寄存器可提高性能并减少堆栈使用。
    \item[Efficient 64-bit immediate generation] 降低对 literal pool 的需求。
    \item[Large PC-relative addressing range] 一个 +/‑4GB 的寻址范围，用于在共享库和与位置无关的可执行文件中进行有效的数据寻址。
    \item[Additional 16KB and 64KB translation granules] 降低了翻译后备缓冲区 (TLB) 未命中率和页面遍历深度。
    \item[New exception model] 降低了操作系统和管理程序软件的复杂性。
    \item[Efficient cache management] 用户空间缓存操作提高了动态代码生成效率。
    使用数据缓存零指令快速清除数据缓存。
    \item[Hardware-accelerated cryptography] 软件加密性能提高 3 到 10 倍。
      这对于小粒度解密和加密非常有用，因为太小而无法有效地卸载到硬件加速器（too small to offload to a hardware accelerator），例如 https。
    \item[Load-Acquire, Store-Release instructions] 专为 C++11、C11、Java 内存模型而设计。
    它们通过消除显式内存屏障指令来提高线程安全代码的性能。
    \item[NEON double-precision floating-point advanced SIMD] 使得 SIMD 矢量化能够应用于更广泛的算法集，例如科学计算、高性能计算 (HPC) 和超级计算机。
\end{description}

\subsection{Contex-A57 处理器}

目前 ARM 处理器已经更新到 X2，但是对于学习它的体系架构来说，A57 或 A53 已经足够适用，也足够经典。
我们将手册中的框架图拿过来感性的认识处理器的内部结构。

Cortex‑A57 处理器 Cortex‑A57 处理器面向移动和企业计算应用，包括计算密集型 64 位应用，例如高端计算机、平板电脑和服务器产品。
它可以与 Cortex‑A53 处理器一起使用到 ARM big.LITTLE 配置中，兼顾性能和功耗。

Cortex‑A57 处理器具有与其他处理器的高速缓存一致性互操作性，包括用于 GPU 计算的 ARM Mali™ 系列图形处理单元 (GPU)，并为高性能企业应用程序提供可选的可靠性和可扩展性功能。
它提供了比 ARMv7 架构的 Cortex‑A15 处理器更高的性能，并具有更高的能效水平。
加密扩展使加密算法的性能比上一代处理器提高 10 倍以上。

\Figure[caption={Contex-A57}, label={fig:contex-a57}, width=0.7]{A57}

Cortex‑A57 处理器完全实现了 ARMv8‑A 架构。
它支持多核操作，在单个集群中具有一到四核多处理器。
通过 AMBA5 CHI 或 AMBA 4 ACE 技术，可以实现多个一致的 SMP 集群。
可通过 CoreSight 技术进程调试和跟踪。

Cortex‑A57 处理器具有以下特性：

\begin{itemize}
  \item 乱序，多于 15 级流水线。
  \item 省电功能包括路径预测、标记缩减和缓存查找抑制。
  \item 通过重复执行资源增加峰值指令吞吐量。
    具有本地化解码、3 个宽解码带宽的功率优化指令解码。
  \item 性能优化的 L2 缓存设计使集群中的多个核心可以同时访问 L2。
\end{itemize}

\subsection{ARMv8 基础}

在 ARMv8 中，代码执行在四个异常级之一。
异常级别决定特权级别，因此在 $EL_n$ 执行对应于特权 $PL_n$。
更大的 n 值的异常级别处于更高的异常级别。

异常级别提供了软件执行权限的逻辑分离，适用于ARMv8架构的所有操作状态。
它类似并支持计算机科学中常见的分层保护域的概念。

\begin{description}
    \item[EL0] Normal user applications.
    \item[EL1] Operating system kernel typically described as privileged.
    \item[EL2] Hypervisor.
    \item[EL3] Low-level firmware, including the Secure Monitor.
\end{description}

\BlockDesc{异常级切换}

异常级别之间可以转换，但是要遵循以下规则：

\begin{itemize}
  \item 移动到更高的异常级别，例如从 EL0 到 EL1，表示软件增加执行特权。
  \item 不能在较低的异常级别下进行异常处理。
  \item EL0 级别没有异常处理，必须在更高的异常级别处理异常。
  \item 异常导致程序流程发生变化。
    异常处理程序的执行从高于EL0的异常级别开始，起始于与所发生的异常相关的定义向量。
    异常包括：IRQ 和 FIQ 等中断、内存系统中止、未定义的指令、系统调用和安全监视器或虚拟机管理程序 trap。
  \item 通过执行 ERET 指令来结束异常处理并返回到上一个异常级别。
  \item 从异常返回可以保持相同的异常级别或进入较低的异常级别，但不能移动到更高的异常级别。
  \item 安全状态确实会随着异常级别的变化而变化，除非从 EL3 重新调整到非安全状态。
\end{itemize}

\begin{probsolu}[title={Problem and Solution \theprob}]{
    如何切换 AArch64 EL？写个切换的实际例子？（课后作业）
  }\label{pb:el_changing}

  当处理异常时，会涉及几个寄存器的操作：
  \begin{enumerate}
    \item 处理器将当前正在执行的指令地址（PC 寄存器）存储在 ELR\_ELn（Exception link register）中。
    \item 将当前处理器的状态（PSTATE）存储在 SPSR\_ELn（Saved Program Status Register）中。
    \item 处理器根据异常向量表跳转到异常处理程序。
    异常处理程序可以修改 ELR 和 SPSR。
    \item 异常处理程序执行 eret 指令推出异常状态。
    这个指令会从 SPSR\_Eln 寄存器恢复处理器的状态，并且恢复 ELE\_Eln 中储存的指令的执行。
  \end{enumerate}
  据上所述，异常处理程序\textcolor{red}{可以修改 ELR\_ELn 和 SPSR\_ELn 寄存器}，所以异常处理程序能够间接的修改 EL 等参数，达到切换 EL 的目的。

  比如，想要从 EL3 异常级切换到 EL1，示例代码如下~\ref{lst:change_el}。
  那么需要配置一些系统寄存器，然后调用 eret 指令触发处理器切换异常运行级。

  \begin{enumerate}
    \item 配置 SCTLR\_EL1（System Control Register）。
      sctlr\_eln 寄存器被用来配置处理器的不同参数。
      存在 sctlr\_el1、sctlr\_el2 和 sctlr\_el3 分别对应 EL1、EL2 和 EL3 的寄存器。
      sctlr\_el1 寄存器能够配置 EL0 和 EL1 级别的内存等配置。
      通过修改 sctlr\_el1 某些位的值能达到配置处理器在 EL0 和 EL1 级别运行时的行为。
    \item 配置 HCR\_EL2（Hypervisor Configuration Register）。
      HCR\_EL2 寄存器提供了虚拟化的配置，包括定义是否将各种操作限制在 EL2 中。
      因为只有 EL2 支持 Hypervisor，所以只存在一个 HCR\_EL2 寄存器。
    \item 配置 SCR\_EL3（Secure Configuration Register）。
      SCR\_EL3 寄存器定义当前安全状态的配置:
      \begin{itemize}
        \item EL0，EL1 和 EL2 的安全状态为 Secure 或 Non-Secure
        \item EL2 的 Execution State
      \end{itemize}
    \item 配置 SPSR\_EL3（Saved Program Status Register）。
      EL3 发生异常时，SPSR\_EL3 寄存器用来保存处理器的状态。
    \item 配置 ELR\_EL3（Exception Link Register (EL3)）。
      在 EL3 进行异常处理时，ELR\_EL3 寄存器将用来指定即将要返回的地址。
  \end{enumerate}
  通过配置上述系统寄存器，然后调用 eret 触发处理器的执行状态的重恢复，就能将异常级别从 EL3 切换到 EL1。
\end{probsolu}
\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={切换异常级},
  label={lst:change_el}
]
  master:
  ldr    x0, =SCTLR_VALUE_MMU_DISABLED
  msr    sctlr_el1, x0

  ldr    x0, =HCR_VALUE
  msr    hcr_el2, x0

  ldr    x0, =SCR_VALUE
  msr    scr_el3, x0

  ldr    x0, =SPSR_VALUE
  msr    spsr_el3, x0

  adr    x0, el1_entry
  msr    elr_el3, x0

  eret
\end{lstlisting}

\BlockDesc{运行状态切换}

ARMv8 架构定义了两种执行状态，AArch64 和 AArch32。
每个状态分别用于描述使用 64 位宽通用寄存器或 32 位宽通用寄存器的执行。
虽然 ARMv8 AArch32 保留了 ARMv7 对特权的定义，但在 AArch64 中，特权级别由异常级别决定。
因此，在 $EL_n$ 的执行对应于特权 $PL_n$。

当处于 AArch64 状态时，处理器执行 A64 指令集。
当处于 AArch32 状态时，处理器可以执行 A32（在早期版本的架构中称为 ARM）或 T32 (Thumb) 指令集。

\begin{probsolu}[title={Problem and Solution \theprob}]{
    如何切换 AArch64 状态到 AArch32 状态？写个切换的实际例子？（课后作业）
  }\label{pb:state_changing}
  
  例如：在 EL3 下进行运行切换，EL3 为 AArch64，将 EL2 切换成 aarch32。
  在 EL3 异常级下，设置 EL2 的架构为 aarch32，设置好返回地址，通过 ERET 指令，即可将 EL2 状态切换成 EL2。
  设置中，主要涉及配置 elr\_el3 寄存器（保存下一异常级的指令地址）和 spsr\_el3 寄存器（保存下一异常级的 pstate 值）。
  对于 spsr\_el3，要设置正确，则要参考 AArch32 的 cpsr 寄存器值进行设置。

  如果需要将 A32 状态切换到 T32 状态，则使用 bx 指令，并且跳转地址的最低位要为 1；
  从 T32 状态切回 A32 状态同样使用 bx 指令，且跳转地址最低位为 0。
  
  总结：EL2 的 A64 和 A32 状态，由 EL3 决定，也就是 SCR\_EL3.RW 寄存器决定。

  EL1 的 A64 和 A32 状态，由 EL2 决定，也就是 HCR\_EL3.RW 寄存器决定。

  EL0 的 A64 和 A32 状态，由 EL1 决定，也就是 CPSR.M[4] 位决定。
\end{probsolu}

\subsection{寄存器}

AArch64 64 位通用寄存器（X0-X30），也可以只使用低 32 位（W0-W30）用于 A32 状态。
从 W 寄存器读取时，忽略相应 X 寄存器高 32 位，并保持其它不变。
写入 W 寄存器时，将 X 寄存器的高 32 位设置为零。
也就是说，将 0xFFFFFFFF 写入 W0 会将 X0 设置为 0x00000000FFFFFFFF。

另外还有一些特殊寄存器：
\begin{itemize}
  \item Zero 寄存器，注意并没有所谓的 31 号寄存器（X31/W31），编号为 31 的寄存器就是零寄存器。
    当访问零寄存器时，所有写操作都被忽略，所有读操作返回 0。
  \item PC 寄存器（Program Counter）。
  \item SP 寄存器（SP/WSP）。
    注意 A64 下的 SP 并不加前缀 X。
  \item SPSR 寄存器（Program Status Register）。
    SPSR 保存着异常发生之前的 PSTATE 的值，用于在异常返回时恢复 PSTATE 的值。
  \item ELR 寄存器（Exception Link Register）。
    保存异常返回地址。
\end{itemize}

只有 EL1 和更高的异常级存在 SPSR 和 ELR。

在 ARMv8 体系结构中，选择使用栈指针寄存器在一定程度上与异常级别是分开的。
默认情况下，发生异常时会选择目标异常级别的 SP\_ELn 作为栈指针。
例如，当触发到 EL1 的异常时，就会选择 SP\_EL1 作为栈指针。
每个异常级别都有自己的栈指针，SP\_EL0、SP\_EL1、SP\_EL2 和 SP\_EL3。
EL0 永远只能访问 SP\_EL0。

\begin{stblr}
  {AArch64 SP 选项}
  {a64-sp-opt}
  {cc}
  \hline[1pt]
  Exception Level & Options \\
  \hline
  EL0 & EL0t \\
  EL1 & EL1t, EL1h \\
  EL2 & EL2t, EL2h \\
  EL3 & EL3t, EL3h \\
  \hline[1pt]
\end{stblr}

后缀 t 表示选择 SP\_EL0，h 表示选择 SP\_ELn。

大多数指令无法使用 SP 寄存器，但是有一些形式的算术指令可以操作 SP，例如，ADD 指令可以读写当前的栈指针以调整函数中的栈指针。

原来的 ARMv7 指令集的一个特性是 R15 作为程序计数器（PC），并作为一个通用寄存器使用。
PC 寄存器的使用带来了一些编程技巧，但它为编译器和复杂的流水线的设计引入了复杂性。
在 ARMv8 中删除了对 PC 的直接访问，使返回预测更容易，并简化了 ABI 规范。

PC 永远不能作为一个命名的寄存器来访问。
但是，可以在某些指令中隐式的使用 PC，如 PC 相对加载和地址生成。
PC 不能被指定为数据处理或加载指令的目的操作数。

下表总结了 SPSR 各 bit 的含义：
\begin{ltblr}[caption={AArch64 SPSR bit 位含义}, label={tbl:a64_spsr}]
  {colspec={c>{\centering\arraybackslash}X}}
    \hline[1pt]
    bit & 含义 \\
    \hline
    N & 负数标志位，如果结果为负数，则 N=1；
    如果结果为非负数，则 N=0。\\
    Z & 零标志位，如果结果为零，Z=1，否则 Z=0。\\
    C & 进位标志位\\
    V & 溢出标志位\\
    SS & 软件步进标志位，表示当一个异常发生时，软件步进是否开启\\
    IL & 非法执行状态位\\
    D & 程序状态调试掩码，在异常发生时的异常级别下，来自监视点、断点和软件单步调试事件中的调试异常是否被屏蔽。\\
    A & SError（系统错误）掩码位\\
    I & IRQ 掩码位\\
    F & FIQ 掩码位\\
    M$[4]$ & 异常发生时的执行状态，0 表示 AArch64\\
    M$[3:0]$ & 异常发生时的 mode 或异常级别\\
    \hline[1pt]
\end{ltblr}

AArch64 没有直接与 ARMv7 当前程序状态寄存器 (CPSR) 等价的寄存器。
在 AArch64 中，传统 CPSR 的组件作为可以独立访问的字段提供。
这些状态被统称为处理器状态 (PSTATE)。

\begin{ltblr}[caption={AArch64 PSTATE field}, label={tbl:a64_pstate}]
  {colspec={c>{\centering\arraybackslash}X}}
    \hline[1pt]
    bit & 含义 \\
    \hline
    N & Negative condition flag. \\
    Z & Zero condition flag. \\
    C & Carry condition flag. \\
    V & oVerflow condition flag. \\
    D & Debug mask bit. \\
    A & SError mask bit. \\
    I & IRQ mask bit. \\
    F & FIQ mask bit. \\
    SS & Software Step bit. \\
    IL & Illegal execution state bit. \\
    EL (2) & Exception level. \\
    nRW & Execution state 
          0 = 64-bit
          1 = 32-bit \\
    SP & Stack Pointer selector.
          0 = SP\_EL0
          1 = SP\_ELn \\
    \hline[1pt]
\end{ltblr}

在 AArch64 中，您可以通过执行 ERET 指令从一个异常中返回，那么 SPSR\_ELn 被复制到 PSTATE 中。
包括恢复 ALU 标志、执行状态、异常级别和处理器分支。
并将从 ELR\_ELn 中的地址开始继续执行。

PSTATE.\{N, Z, C, V\} 字段可以在 EL0 级别访问。
其他的字段可以在 EL1 或更高级别访问，但是这些字段在 EL0 级别未定义。

\subsubsection{系统寄存器}

在 AArch64 中，系统配置通过系统寄存器进行控制，并使用 MSR 和 MRS 指令进行访问。
简化了 ARMv7 架构通过协处理器 CP15 来操作系统寄存器的方式。

高异常级下可以访问本异常级和低异常级的系统寄存器。
EL0 异常级具有最低的权限，并且只有极少数的系统系统器可以在 EL0 下访问，例如：CTR\_EL0。

详细的系统寄存器列表请参见 Arm® Architecture Reference Manual for A-profile architecture \cite{armrefman}。

\BlockDesc{系统控制寄存器 SCTLR}

系统控制寄存器是一个很重要的系统寄存器，用于控制内存、配置系统能力和提供处理器核的状态信息。
这个寄存器在 EL0 下拥有更多的可获取 bit，更高的异常级则更少。

% npx bit-field -i <json> --fontsize=9 > figures/<bit_field>.svg
\Figure[caption={SCTLR BIT FIELD EL1}, label={fig:sctlr-bit-field-el1}, width=1]{sctlr-bit-field-el1}
\Figure[caption={SCTLR BIT FIELD EL2/3}, label={fig:sctlr-bit-field-el23}, width=1]{sctlr-bit-field-el23}

\begin{description}
  \item[UCI] 设置该域将使能 AArch64 下的 EL0 异常级对 DC CVAU、DC CIVAC、DC CVAC 和 IC IVAU 指令的访问权限。
  \item[EE] 控制异常 Endianness。
    \begin{description}
      \item[0] 小端 
      \item[1] 大端
    \end{description}
  \item[EOE] EL0 下 Explicit data 访问字节序
    \begin{description}
      \item[0] 小端 
      \item[1] 大端
    \end{description}
  \item[WXN] 写权限下应用不可执行权限 XN（eXecute Never）
    \begin{description}
      \item[0] 可写区域可执行
      \item[1] 可写区域强制不可执行
    \end{description}
  \item[nTWE] 不陷入 WFE，此标志为 1 表示 WFE 作为普通指令执行。
  \item[nTWI] 不陷入 WFI, 此标志为 1 表示 WFI 作为普通指令执行
  \item[UCT] 此标志为 1 时，开启 AArch64 的 EL0 下对 CTR\_EL0 寄存器访问权限。
  \item[DZE] EL0 下对 DC AVA 指令的访问权限。
    \begin{description}
      \item[0] 禁止访问
      \item[1] 允许访问
    \end{description}
  \item[I] 开启指令缓存，这是在 EL0 和 EL1 下的指令缓存的启用位。
    对可缓存的正常内存的指令访问被缓存。
  \item[UMA] 用户中断屏蔽控制，EL0 运行在 AArch64 状态下有效。
  \item[SED] 控制 AArch64 状态下的 EL0 是否可以使用 SETEND 指令。
    \begin{description}
      \item[0] 可用
      \item[1] 禁用
    \end{description}
  \item[ITD] 禁止 IT 指令
    \begin{description}
      \item[0] IT 指令有效
      \item[1] IT 指令被当作 16 位指令。
        仅另外 16 位指令或 32 位指令的头 16 位可以使用，这依赖于实现。
    \end{description}
  \item[CP15BEN] CP15 barrier 使能。
    如果实现了，它是 AArch32 CP15 DMB、DSB 和 ISB barrier 操作的使能位
  \item[SA0] EL0 的栈对齐检查使能位
  \item[SA] 栈对齐检查使能位
  \item[C] 数据 cache 使能。
    EL0 和 EL1 的数据访问使能位。
    cacheable 普通内存的数据访问都被缓存。
  \item[A] 对齐检查使能位。
  \item[M] 使能 MMU。
\end{description}

\begin{probsolu}[title={Problem and Solution \theprob}]{
    手册上写的 Explicit data access 怎么理解？}

  “Explicit data access”是指在编程中明确地访问数据的操作。
  这意味着程序员直接指定要访问的数据和操作，而不依赖于编译器或运行时系统的隐式处理。

  这种方式通常用于对内存中的数据进行读取、写入或者其他操作。
  与之相对应的是隐式访问方式，其中编译器或者运行时系统负责管理数据的访问。
  在隐式访问中，程序员通常只需指定数据的名称，而无需关心数据的存储位置或者具体的访问方式。

\end{probsolu}

\begin{remark}
  The caches in the processor must be invalidated before caching of data and instructions is
enabled in any of the Exception levels.
\end{remark}

\BlockDesc{大小端的设置}

每个异常级别的数据的大小端都被单独控制。
对于 EL3，EL2 和 EL1，通过 SCTLR\_ELn.EE 设置大小端。
EL1 中其他位，SCTLR\_EL1.E0E 控制 EL0 的数据大小端的设置。
在 AArch64 执行状态中，数据访问可以为 LE 或 BE，但指令的获取通常为 LE。

\subsubsection{NEON 和浮点}

除了通用寄存器之外，ARMv8 还有 32 个 128 位浮点寄存器，标记为 V0-V31。
32 个寄存器用于保存标量浮点指令的浮点操作数，以及 NEON 操作的标量操作数和向量操作数。

操作数使用 H (Half)、S (Single) 和 D (Double) 分别用来指定 V 寄存器的低 16、32 和 64 位。

\begin{itemize}
  \item
    \textbf{v0-v7}: 用于传递浮点参数和返回值。
  \item
    \textbf{v8-v15}: 临时寄存器，用于浮点和SIMD操作。
  \item
    \textbf{v16-v31}: 被调用者保存的寄存器，需要在函数调用之间保持其值。
\end{itemize}

\subsection{ISA 概述}

ARMv8 架构中引入的最重要的变化之一是增加了 64 位指令集。
该指令集补充了现有的 32 位指令集架构。
这一指令集提供了对 64 位宽整数寄存器和数据操作的访问，以及使用 64 位内存指针的能力。
新的指令集被称为 A64，并且在 AArch64 状态下执行。
ARMv8 架构还包括原始的 ARM 指令集（现称为 A32）和 Thumb（T32）指令集。
A32 和 T32 都以 AArch32 状态执行，并且向后与 ARMv7 架构兼容。

虽然 ARMv8-A 向后兼容了 32 位 ARM 架构的特性，但 A64 指令集与旧的 ISA 指令是独立且不同的，而且他们的编码方式也不同。
A64 增加了一些额外的功能，同时也删除了影响高性能或功耗的功能。
ARMv8 架构还包括对 32 位指令集（A32 和 T32）的一些增强性功能。
然而，使用这些功能的代码与旧的 ARMv7 不兼容。
需要注意的是，A64 指令集中的指令操作码长度仍然是 32 位，而不是 64 位。

\subsubsection{ARMv8 指令集简介}

新的 A64 指令集与 A32 类似，都是 32 bit 宽度，并且语法类似。
该指令集使用通用的命名，原先的 32-bit 指令集则称为 A32 和 T32（16-bit 指令，以性能换空间）。
运行在 AArch64 新的指令集（64-bit 操作）则命名为 A64。

A64 指令集有两种整型指令形式，即通用寄存器保存 32-bit 或是 64-bit 值。
当查看指令中的寄存器名称时，如果是 X 开头则使用的是 64-bit 值；
W 开头则是 32-bit 值。
当使用 32-bit 形式时，会有以下体现：
\begin{itemize}
  \item 右移和旋转操作止于 31 位，而非 63 位。
  \item 由指令设置的状态标志是从低 32 位里计算而来。
  \item 向 W 寄存器写入时，X 寄存器的 $[63:32]$ 位自动设为 0。
\end{itemize}

64-bit 指令集极大扩展了地址空间。
因此，在程序中访问大量内存变得更加简单。
在 32-bit 的 CPU 核上执行一个线程，会将内存的访问限制在 4GB 空间。
大部分地址空间保留给 OS 内核、库代码和外设等成员使用。
所以，程序会面临内存不足的问题，那么程序在执行时可能需要将内存的一些数据映射出去或再映射回来。
拥有更大的内存空间，更大的 64-bit 指针，便可以避免以上问题。
而且类似文件内存映射等技术将更加具有可用性和方便性。
在这种情况下，即使文件的内容大小超出了物理 RAM 的大小，文件内容也可以映射到线程的内存中。

其它改进包括：独占访问、增加相对 PC 的偏移地址、支持未对齐地址、批量传输、加载 / 存储和对齐检查。

在问题~\ref{pb:state_changing} 中，我们分析了如何状态切换。
下面是手册中给出的切换图。

\Figure[caption={Switching between instruction sets}, label={fig:state_changing}, width=0.8]{state_changing}

\subsection{A64 指令集}

一般情况下我们只需要记住指令的助记符即可，不需要在意更底层的指令编码，指令编码的事情留给汇编器来完成。

我们将指令集按照其功能分类，有如下几类指令：\footnote{
  关于指令集的快速参考可以使用 \url{
    https://courses.cs.washington.edu/courses/cse469/19wi/arm64.pdf
  }
}

\begin{itemize}
  \item 数据处理指令
    % \begin{itemize}
    %   \item 算术与逻辑运算指令
    %   \item 乘法与除法指令
    %   \item 移位指令
    %   \item 位和字节操作指令
    %   \item 状态位操作指令
    % \end{itemize}
  \item 内存访问指令
  \item 流程控制指令
  \item 系统控制及其它指令
    % \begin{itemize}
    %   \item 异常处理指令
    %   \item 系统寄存器操作指令
    %   \item Debug 指令
    %   \item Hint 指令
    %   \item NEON 指令
    %   \item 浮点指令
    %   \item 加密算法指令
    % \end{itemize}
\end{itemize}

\subsubsection{数据处理指令}

\paragraph{算术与逻辑运算指令}

\begin{stblr}
  {算术和逻辑运算指令}
  {a64-isa-al}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  类型 & 指令 \\
  \hline
  算术 & ADD, SUB, ADC, SBC, NEG \\
  逻辑 & AND, BIC, ORR, ORN, EOR, EON \\
  比较 & CMP, CMN, TST \\
  转移 & MOV, MVN \\
  \hline[1pt]
\end{stblr}

另外，有些指令的后缀带 S，表明该指令会更新状态 flags。
这些指令可以配合跳转指令使用。
注意，CMP、CMN 和 TST 不带后缀 S。

\paragraph{乘法与除法指令}

\begin{ltblr}[caption={乘法与除法指令}, label={tbl:a64-isa-md}]
  {colspec={c>{\centering\arraybackslash}X}}
    \hline[1pt]
    指令 & 说明 \\
    \hline
    \textbf{乘法} & \\
    MADD & Multiply add \\
    MNEG & Multiply negate \\
    MSUB & Multiply subtract \\
    MUL & Multiply \\
    SMADDL & Signed multiply-add long \\
    SMNEGL & Signed multiply-negate long \\
    SMSUBL & Signed multiply-subtract long \\
    SMULH & Signed multiply returning high half \\
    SMULL & Signed multiply long \\
    UMADDL & Unsigned multiply-add long \\
    UMNEGL & Unsigned multiply-negate long \\
    UMSUBL & Unsigned multiply-subtract long \\
    UMULH & Unsigned multiply returning high half \\
    UMULL & Unsigned multiply long \\
    \hline
    \textbf{除法} & \\
    SDIV & Signed divide \\
    UDIV & Unsigned divide \\
    \hline[1pt]
\end{ltblr}

\paragraph{移位指令}

\begin{ltblr}[caption={移位指令}, label={tbl:a64-isa-so}]
  {colspec={c>{\centering\arraybackslash}X}}
    \hline[1pt]
    指令 & 说明 \\
    \hline
    \textbf{移位} & \\
    ASR & Arithmetic shift right \\
    LSL & Logical shift left \\
    LSR & Logical shift right \\
    ROR & Rotate right \\
    \hline
    \textbf{转移} & \\
    MOV & Move \\
    MVN & Bitwise NOT \\
    \hline[1pt]
\end{ltblr}

下图形象展示了移位指令的执行。

\Figure[caption={移位操作}, label={fig:shift-ops}, width=1]{shift-ops}

\paragraph{位和字节操作指令}

\begin{ltblr}[caption={位和字节操作指令}, label={tbl:a64-isa-bB}]
  {colspec={c>{\centering\arraybackslash}X}, width=1\textwidth}
  \hline[1pt]
  指令 & 说明 \\
  \hline
  BFI rd, rn, \#p, \#n & $rd_{p+n-1:p} = rn_{n-1:0}$ \\
  BFXIL rd, rn, \#p, \#n & $rd_{n−1:0} = rn_{p+n−1:p}$ \\
  CLS rd, rn & $rd = CountLeadingOnes(rn)$ \\
  CLZ rd, rn & $rd = CountLeadingZeros(rn)$ \\
  EXTR rd, rn, rm, \#p & $rd = rn_{p−1:0}:rm_{N0}$ \\
  RBIT rd, rn & $rd = ReverseBits(rn)$ \\
  REV rd, rn & $rd = BSwap(rn)$ \\
  REV16 rd, rn & $for(n=0..1|3) rd_{Hn}=BSwap(rn_{Hn})$ \\
  REV32 Xd, Xn & $Xd=BSwap(Xn_{63:32}):BSwap(Xn_{31:0})$ \\
  \{S,U\}BFIZ rd, rn, \#p, \#n & $rd = rn^?_{n−1:0} << p$ \\
  \{S,U\}BFX rd, rn, \#p, \#n & $rd = rn^?_{p+n−1:p}$ \\
  \{S,U\}XT\{B,H\} rd, Wn & $rd = Wn^?_{N0}$ \\
  SXTW Xd, Wn & $Xd = Wn^±$ \\
  \hline[1pt]
\end{ltblr}

\paragraph{状态位操作指令}

A64 支持处理器状态位有 NZCV，分别位 Negative、Zero、Carry 和 Overflow。
C flag 在无符号数操作溢出时被设置，而 V 类似，但是是在有符号数操作溢出时被设置。

\begin{ltblr}[caption={Condition codes}, label={tbl:condcode}]
  {colspec={cc>{\centering\arraybackslash}X>{\centering\arraybackslash}Xc}, width=1\textwidth}
  \hline[1pt]
  Code & Encoding & Meaning (when set by CMP) & Meaning (when set by FCMP) & Condition flags \\
  \hline
  EQ & 0b0000 & Equal to. & Equal to. & Z =1 \\
  NE & 0b0001 & Not equal to. & Unordered, or not equal to. & Z = 0 \\
  CS & 0b0010 & Carry set (identical to HS). & Greater than, equal to, or unordered (identical to HS). & C = 1 \\
  HS & 0b0010 & Greater than, equal to (unsigned) (identical to CS). & Greater than, equal to, or unordered (identical to CS). & C = 1 \\
  CC & 0b0011 & Carry clear (identical to LO). & Less than (identical to LO). & C = 0 \\
  LO & 0b0011 & Unsigned less than (identical to CC). & Less than (identical to CC). & C = 0 \\
  MI & 0b0100 & Minus, Negative. & Less than. & N = 1 \\
  PL & 0b0101 & Positive or zero. & Greater than, equal to, or unordered. & N = 0 \\
  VS & 0b0110 & Signed overflow. & Unordered. (At least one argument was NaN). & V = 1 \\
  VC & 0b0111 & No signed overflow. & Not unordered. (No argument was NaN). & V = 0 \\
  HI & 0b1000 & Greater than (unsigned). & Greater than or unordered. & (C = 1) \&\& (Z = 0) \\
  LS & 0b1001 & Less than or equal to (unsigned). & Less than or equal to. & (C = 0) || (Z = 1) \\
  GE & 0b1010 & Greater than or equal to (signed). & Greater than or equal to. & N==V \\
  LT & 0b1011 & Less than (signed). & Less than or unordered. & N!=V \\
  GT & 0b1100 & Greater than (signed). & Greater than. & (Z==0) \&\& (N==V) \\
  LE & 0b1101 & Less than or equal to (signed). & Less than, equal to or unordered. & (Z==1) || (N!=V) \\
  AL & 0b1110 & Always executed. & Default. Always executed. & Any \\
  NV & 0b1111 & Always executed. & Always executed. & Any \\
  \hline[1pt]
\end{ltblr}

有一小部份的条件数据处理指令是无条件执行的，但使用条件标志作为指令的额外输入。
提供这组指令是为了取代 ARM 代码中条件执行的常见用法。

\BlockDesc{加 / 减}

例如，用于多精度算术和校验和的传统 ARM 指令。

\BlockDesc{带有可选增量、否定或反转的条件选择}

有条件地在一个源寄存器和第二个增量、否定、倒置或未修改的源寄存器之间进行选择。

这些是 A32 和 T32 中单个条件指令最常见的用途。
典型的用途包括有条件计数或计算有符号数量的绝对值。

\BlockDesc{条件操作}

有别于 A32 和 T32（大多数指令可以使用条件码预测），A64 只有流程控制类的跳转指令才会使用到条件码。
A64 中使用到条件码的指令，大致可以总结为：

\begin{description}
  \item[条件选择（移动）] 包括 CSEL、CSINC、CSINV 和 CSNEG。
    \begin{itemize}
      \item CSEL 根据一个条件在两个寄存器之间进行选择。
        无条件指令，然后是条件选择，可以取代简短的条件序列。
      \item CSINC 根据一个条件在两个寄存器之间进行选择。
        返回第一个源寄存器或第二个源寄存器增加一个。
      \item CSINV 根据条件在两个寄存器之间进行选择。
        返回第一个源寄存器或倒置的第二个源寄存器。
      \item CSNEG 根据条件在两个寄存器之间进行选择。
        返回第一个源寄存器或被否定的第二个源寄存器。
    \end{itemize}
  \item[条件设置] 有条件地在 0 和 1（CSET）或 0 和 -1（CSETM）之间进行选择。
    例如，用于在一般寄存器中将条件标志设置为布尔值或掩码。
  \item[条件比较]（CMP 和 CMN）如果原始条件为真，则将条件标志设置为比较结果。
    如果不是真，条件标志将设置为指定的条件标志状态。
    条件比较指令对于表示嵌套或复合比较非常有用。
\end{description}

\subsubsection{内存访问指令}

与之前的所有 ARM 处理器一样，ARMv8 架构是一个加载 / 存储架构。
这意味着没有数据处理指令直接对内存中的数据进行操作。
数据必须首先被加载到寄存器中，进行修改，然后存储到内存中。
必须在程序中指定一个地址，要传输的数据大小，以及一个源寄存器或目标寄存器。
还有一些额外的加载和存储指令，提供了更多的选择，如非时间性的加载 / 存储，加载 / 存储排他性，以及获取 / 释放。

内存指令可以以非对齐方式访问普通内存（见 Memory ordering 章节~\ref{sec:memory-ordering}）。
但是独占访问、加载获取或存储释放等变种访问方式不支持非对齐方式访问。
如果不需要非对齐访问，可以将上述变种访问方式配置为故障（非对齐访问时产生故障异常）。

\paragraph{Load}

Load 指令的一般形式如下：

\begin{lstcode}[language={[ARM]Assembler}]
  LDR Rt, <addr>
\end{lstcode}

您可以选择加载数据的大小到整数寄存器中。
例如，要加载一个比指定的寄存器值小的尺寸，可以在 LDR 指令中加入以下对应后缀：
\begin{itemize}
  \item LDRB (8-bit, zero extend)
  \item LDRSB (8-bit, sign extend)
  \item LDRH (16-bit, zero extend)
  \item LDRSH (16-bit, sign extend)
  \item LDRSW (32-bit, sign extend)
\end{itemize}

无需指定 zero-extended（高位扩展为 0）加载指令将数据加载到 X 寄存器，因为向 W 寄存器写数据会自动 zero extend 整个寄存器宽度。

\paragraph{Store}

类似的，存储指令的一般形式如下：

\begin{lstcode}[language={[ARM]Assembler}]
  STR Rn, <addr>
\end{lstcode}

要存储的大小同样可能比寄存器小。
那么您可以添加类似 LDR 指令的后缀到 STR。
在这种情况下，存储的总是寄存器中的最低有效部分。

\paragraph{浮点和 NEON 向量的 Load 和 Store}

Load 和 Store 指令同样支持访问浮点 / NEON 寄存器。
此时，仅由所加载或存储的寄存器（B、H、S、D 或 Q 寄存器中的任意一个）来决定操作大小。
具体情况总结如下表：

加载指令：

\begin{stblr}
  {加载位数}
  {load-bits}
  {cccccccc}
  \hline[1pt]
  Load & Xt & Wt & Qt & Dt & St & Ht & Bt \\
  \hline
  LDR & 64 & 32 & 128 & 64 & 32 & 16 & 9 \\
  LDP & 128 & 64 & 256 & 128 & 64 & - & - \\
  LDRB & - & 8 & - & - & - & - & - \\
  LDRH & - & 16 & - & - & - & - & - \\
  LDRSB & 8 & 8 & - & - & - & - & - \\
  LDRSH & 16 & 16 & - & - & - & - & - \\
  LDRSW & 32 & - & - & - & - & - & - \\
  LDPSW & - & - & - & - & - & - & - \\
  \hline[1pt]
\end{stblr}

存储指令：

\begin{stblr}
  {存储位数}
  {store-bits}
  {cccccccc}
  \hline[1pt]
  Store & Xt & Wt & Qt & Dt & St & Ht & Bt \\
  \hline
  STR & 64 & 32 & 126 & 64 & 32 & 16 & 8 \\
  STP & 128 & 64 & 256 & 128 & 64 & - & - \\
  STRB & - & 8 & - & - & - & - & - \\
  STRH & - & 16 & - & - & - & - & - \\
  \hline[1pt]
\end{stblr}

加载数据到浮点或 NEON 寄存器的指令没有 sign-extension 选项。
并且，地址也是由通用寄存器指定的。

例如：

\begin{lstcode}[language={[ARM]Assembler}]
  LDR D0, [X0, X1]
\end{lstcode}

\begin{Tcbox}[title={注}]
  浮点或向量 NEON 加载和存储指令使用和整型加载和存储指令一样的寻址模式。
\end{Tcbox}

\paragraph{Load 和 Store 指令中的地址指定}

A64 可用的寻址模式与 A32 和 T32 中的相似。
有一些额外的限制以及一些新的功能，但是对于熟悉 A32 或 T32 的人来说，A64 可用的寻址模式并不新奇。

在 A64 中，一个地址操作数的基寄存器必须总是一个 X 寄存器。
但是，有几条零扩展或符号扩展的指令可以使用，来满足通过 W 寄存器来提供 32 位偏移。

\subparagraph{偏移模式}

偏移寻址模式将一个立即数或一个可选择可修改的寄存器值添加到一个 64 位的基寄存器中来产生一个地址。

\begin{stblr}
  {偏移寻址}
  {offset-addressing}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]!LDR X0, [X1]! & Load from the address in \lstinline!X1! \\
  \lstinline[language={[ARM]Assembler}]!LDR X0, [X1, #8]! & Load from address \lstinline!X1 + 8! \\
  \lstinline[language={[ARM]Assembler}]!LDR X0, [X1, X2]! & Load from address \lstinline!X1 + X2! \\
  \lstinline[language={[ARM]Assembler}]!LDR X0, [X1, X2, LSL, #3]! & Load from address \lstinline!X1 + (X2 << 3)! \\
  \lstinline[language={[ARM]Assembler}]!LDR X0, [X1, W2, SXTW]! & Load from address \lstinline!X1 + sign_extend(W2)! \\
  \lstinline[language={[ARM]Assembler}]!LDR X0, [X1, W2, SXTW, #3]! & Load from address \lstinline!X1 + (sign_extend(W2) << 3)! \\
  \hline[1pt]
\end{stblr}

通常，当指定移位或扩展选项时，移位量可以是 0（默认值）或 $log_2(access\; size\; in\; bytes)$（因此，$Rn \ll\; <shift>$ 即是 Rn 乘以访问大小）。
所以，偏移寻址支持常见的数组索引操作。

\begin{lstcode}[language=C]
// A C example showing accesses that a compiler is likely to generate.
void example_dup(int32_t a[], int32_t length) {
  int32_t first = a[0];  // LDR W3, [X0]
  for (int32_t i = 1; i < length; i++) {
    a[i] = first;  // STR W3, [X0, W2, SXTW, #2]
  }
}
\end{lstcode}

\subparagraph{索引模式}

索引模式与偏移模式类似，但它们还会更新基地址寄存器。
这里的语法与 A32 和 T32 相同，但操作集的限制性更强。
通常情况下，只能为索引模式提供立即数偏移。

索引模式有两种变体：
\begin{itemize}
  \item 在访问内存之前施加偏移量的预索引模式。
  \item 以及在访问内存之后施加偏移量的后索引模式。
\end{itemize}

\begin{stblr}
  {索引寻址}
  {index-addressing}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1]} & Load from the address in X1 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1, #8]!} & Pre-index: \textit{Update X1 first} (to X1 + \#8), then load from the new address \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, [X1], #8} & Post-index: \textit{Load from the unmodified address in X1 first}, then update X1 (to X1 + \#8) \\
  \lstinline[language={[ARM]Assembler}]{STP X0, X1, [SP, #-16]!} & Push X0 and X1 to the stack. \\
  \lstinline[language={[ARM]Assembler}]{LDP X0, X1, [SP], \#16} & Pop X0 and X1 off the stack. \\
  \hline[1pt]
\end{stblr}

例如，这些选项准确地映射到一些常见的 C 操作上：

\begin{lstcode}[language=C]
// A C example showing accesses that a compiler is likely to generate.
void example_strcpy(char * dst, const char * src)
{
  char c;
  do {
    c = *(src++);  // LDRB W2, [X1], #1
    *(dst++) = c;  // STRB W2, [X0], #1
  } while (c != '\0');
}
\end{lstcode}

\subparagraph{相对 PC 模式（load-literal）}

A64 添加了另外一个专门用于获取 literal pool 的寻址模式。
Literal pool 是编码成一个指令流的数据块。
它们不会被执行，但是其数据可以通过周围的代码相对于 PC 的内存地址获取到。
Literal pool 经常用于编码常数，而这些常数不能被塞进一个简单的 move-immediate 指令（因为留给立即数的编码位数不足）中。
A32 和 T32 指令集中，PC 寄存器可以当作一个通用寄存器来读，所以可以通过指定 PC 作为基地址寄存器简单的访问 literal pool。

然而，在 A64 下，PC 寄存器不可以用通常的方式获取了，但是提供了一个特殊的寻址模式（只针对 load 指令）来获取 PC 相对地址。
这个特殊作用的寻址模式也极大扩展了 PC 相对加载的范围（相比于 A32 和 T32），所以可以更稀疏地定位 literal pool 。

\begin{stblr}
  {PC 相对寻址}
  {PC-relative-addressing}
  {cc}
  \hline[1pt]
  Example instruction & Description \\
  \hline
  \lstinline[language={[ARM]Assembler}]{LDR W0, <label>} & Load 4 bytes from <label> into W0 \\
  \lstinline[language={[ARM]Assembler}]{LDR X0, <label>} & Load 8 bytes from <label> into X0 \\
  \lstinline[language={[ARM]Assembler}]{LDRSW X0, <label>} & Load 4 bytes from <label> and sign-extend into X0 \\
  \lstinline[language={[ARM]Assembler}]{LDR S0, <label>} & Load 4 bytes from <label> into S0 \\
  \lstinline[language={[ARM]Assembler}]{LDR D0, <label>} & Load 8 bytes from <label> into D0 \\
  \lstinline[language={[ARM]Assembler}]{LDR Q0, <label>} & Load 16 bytes from <label> into Q0 \\
  \hline[1pt]
\end{stblr}

\begin{remark}
  对于所有变体而言，<label> 都必须 4-byte 对齐。
\end{remark}

\paragraph{获取多个地址位置}

A64 中不存在 A32 和 T32 类似的 Load Multiple (LDM) 或 Store Multiple (STM) 指令。

然而，在 A64 代码中，含有 Load Pair (LDP) 和 Store Pair (STP) 指令。
与 A32 LDRD 和 STRD 指令不同的是，LDP 和 STP 可以读写任何两个整型寄存器。
LDP 和 STP 指令从相邻的内存地址读写数据。
这两个指令的内存取址模式的选项比其它内存访问指令更加受限。
它们只能使用一个基地址寄存器附加一个成比例的 7-bit 的有符号立即数，另外一个可选的预地址或后地址增加操作。
与 32-bit 的 LDRD 和 STRD 不同，LDP 和 STP 也可以进行非对齐访问。

\paragraph{非特权访问}

A64 的 LDTR 和 STTR 指令用于非特权级的数据加载和存储操作。

\lstinline!LDTR rt, [Xn{, #i9}]! 相当于 $rt = [Xn += i^{\pm}, <Unpriv>]_N$

\lstinline!STTR rt, [Xn{, #i9}]! 相当于 $[Xn += i^{\pm}, <Unpriv>]_N = rt$

\begin{itemize}
  \item 在 EL0、EL2 或 EL3 中，它们表现为一般的加载或存储指令。
  \item 在 EL1 下执行这些指令，则表现为就像在 EL0 中执行一样。
\end{itemize}
 
这些指令等效于 A32 的 LDRT 和 STRT 指令。

\paragraph{预取内存访问}

\textit{Prefetch from Memory}（PRFM）指令向代码提供了一个给内存系统暗示的功能，暗示内存系统一个特定的地址将很快就会被当前程序用到。
该功能的效果\textbf{由具体实现定义}，典型的实现是将数据或指令加载到 Cache 中。

该指令的语法为：

\lstinline!PRFM <prfop>, <addr> | label!

其中 prfop 是以下选项的拼接：

\begin{description}
  \item[Type] PLD 或 PST (prefetch for load or store)。
  \item[Target] L1、L2 或 L3（以那个 Cache 为目的）。
  \item[Policy] KEEP 或 STRM（保持在 cache 中，还是作为数据流）。
\end{description}

例如，PLDL1KEEP，加载预取 + L1 cache + 保持在 cache 中。

这些指令与 A32 的 PLD 和 PLI 指令类似。

\paragraph{Non-temporal load and store pair}

ARMv8 增加了一个关于 non-temporal 加载和存储的新概念。
相关指令是 LDNP 和 STNP，功能是读写一对寄存器的值。
并且，它们会给内存系统一个暗示，即缓存的数据不靠谱。
该暗示阻止内存系统激活诸如地址的缓存、预加载或合并等功能。
但是，这也无法获得缓存的加速。
一个典型的用例是生产数据流，但是注意高效使用这些指令需要一种微架构的特定方式。

Non-temporal 加载和存储缓解了内存序列化的需求。
在上述例子中，即使 LDNP 指令排在 LDR 指令之后，但是也可能先被观察到。
这种情况会导致从一个存储在 X0 中的不确定的地址中读到数据。
例如：

\begin{lstcode}
  LDR X0, [X3]
  LDNP X2, X1, [X0] // X0 may not be loaded when the instruction executes!
\end{lstcode}

为了解决这个问题，需要放置一个 load barrier 指令。

\begin{lstcode}
  LDR X0, [X3]
  DMB nshld
  LDNP X2, X1, [X0]
\end{lstcode}

\paragraph{内存访问的原子性}

使用单个通用寄存器进行的对齐内存访问保证是原子性的。
使用一对通用寄存器的 Load pair 和 store pair 指令进行内存地址对齐访问确保为两个独立的原子访问。
非对齐访问不具有原子性，因为它们通常需要两次单独的访问。
另外，浮点和 SIMD 内存访问不保证是原子性的。

\paragraph{内存屏障和栅栏指令}

ARMv7 和 ARMv8 都提供了不同的 barrier 操作支持。
这些操作会在~\ref{sec:memory-ordering} 更加详尽的描述。

\begin{itemize}
  \item Data Memory Barrier (DMB)。
  该指令强制所有按照程序顺序的早期内存访问变成全局可见后才会执行后续的访问操作。
  \item Data Synchronization Barrier (DSB)。
    在程序运行之前，所有挂起的加载和存储指令、Cache 维护指令和所有 TLB 维护指令都必须先完成。
    DSB 类似 DMB，但是附加了其它属性。
  \item Instruction Synchronization Barrier (ISB)。
    这个指令刷新 CPU 的流水线和预取 buffer，致使 ISB 后续的指令需要从缓存或内存中预取（或重新预取）。
\end{itemize}

ARMv8 介绍了关于释放一致性模型的单侧 fence 操作。
包括 Load-Acquire (LDAR) 和 Store-Release (STLR) 并且都是基于地址的同步原语。
这两个操作可以作为完整的 fence 成对使用。
它们只支持基地址寄存器的寻址方式，偏移或其它类型的索引寻址都不支持。

\paragraph{同步原语}

ARMv7-A 和 ARMv8-A 架构都提供了独占的内存访问操作。
A64 下是由一对 Load/Store exclusive (LDXR/STXR) 指令提供的。

LDXR 指令从一个内存地址加载一个值，并且尝试静默的给该地址上个互斥锁。
Store-Exclusive 指令只能在获取并持有锁的情况下才能向该地址写入新值。
组合使用 LDXR/STXR 能够构建标准的同步原语，如 spinlock。
一对 LDXRP 和 STXRP 指令允许代码自动更新跨越两个寄存器长度的地址。
可用的选项有 byte、halfword、word 和 doubleword。
这对指令与 Load Acquire/Store Release 成对指令一样，只支持基地址寄存器寻址方式。

不同于 ARMv7 异常入口或返回也能够清除 monitor，CLREX 指令在 ARMv8 下专门用于清除 monitor。
Monitor 也可能虚假的被清除，例如 cache 驱逐操作（evictions）或其它一些与该操作无关的原因。
\textit{软件必须要避免在 LDXR 和 STXR 指令对之间含有内存访问、系统控制寄存器更新或缓存维护指令。}

另外，还有一对 Acquire/Store Release 相关的互斥指令是 LDAXR 和 STLXR。
详见关于同步的章节。

\subsubsection{流程控制指令}

A64 指令集提供一些不同类型的跳转指令（见下表~\ref{tbl:a64-isa-branch}）。
相对于当前地址偏移的简单跳转指令则使用 B 指令。
简单的无条件相对跳转指令可以基于当前地址前后跳跃 128MB。
含有条件码后缀的简单的有条件相对跳转指令的跳转范围只有 $\pm1MB$。

当函数（subroutine）调用时，则需要使用 BL 指令保存返回地址到 link 寄存器（X30），这个指令没有有条件的跳转类型。
除了会保存返回地址（BL 指令的下一条指令）到寄存器（X30）外，BL 指令功能类似 B 指令。

\begin{ltblr}[caption={流程控制指令}, label={tbl:a64-isa-branch}]
  {colspec={c>{\centering\arraybackslash}X}}
  \hline[1pt]
  & Branch 指令 \\
  \hline
  \lstinline!B (offset)! & Program relative branch forward or back 128MB. A conditional version, for example B.EQ, has a 1MB range. \\
  \lstinline!BL (offset)! & As B but store the return address in X30, and hint to branch prediction logic that this is a function call. \\
  \lstinline!BR Xn! & Absolute branch to address in Xn. \\
  \lstinline!BLR Xn! & As BR but store the return address in X30, and hint to branch prediction logic that this is a function call. \\
  \lstinline!RET{Xn}! & As BR, but hint to branch prediction logic that this is a function return. Returns to the address in X30 by default, but a different register can be specified. \\
  \hline
  & Conditional branch 指令 \\
  \hline
  \lstinline!CBZ Rt, label! & Compare and branch if zero. If Rt is zero, branch forward or back up to 1MB. \\
  \lstinline!CBNZ Rt, label! & Compare and branch if non-zero. If Rt is not zero, branch forward or back up to 1MB. \\
  \lstinline!TBNZ Rt, bit, label! & Test and branch if zero. Branch forward or back up to 32kB. \\
  \lstinline!TBNZ Rt, bit, label! & Test and branch if non-zero. Branch forward or back up to 32kB. \\
  \hline[1pt]
\end{ltblr}

除了相对 PC 的跳转指令外，A64 指令集也包含了两个绝对跳转指令。
\lstinline!BR Xn! 指令执行一个到 Xn 寄存器的绝对跳转。
同时，\lstinline!BLR Xn! 也是类似的绝对跳转功能，但是它会保存返回地址到 link 寄存器 X30 中。
\lstinline!RET! 指令行为上类似 \lstinline!BR Xn!，但是它会暗示跳转预测逻辑它执行的是一个函数返回。
尽管 \lstinline!RET! 指令可以指定其它跳转目的寄存器，但是它默认使用 X30 所保存的返回地址。

A64 指令集还包括一些特别的条件跳转指令。
这些指令能在一些情况下提高代码的密度，因为在这些情况下没必要做明确的比较。

\begin{itemize}
  \item \lstinline!CBZ Rt, label! \quad Compare and branch if zero
  \item \lstinline!CBNZ Rt, label! \quad Compare and branch if not zero
\end{itemize}

这些指令先将 32-bit 或 64-bit 源寄存器与 0 进行比较，然后执行条件跳转。
跳转的偏移范围是 $\pm1MB$。
这些指令不会读或写状态码（NZCV）。

有两个类似的检测并跳转的指令：

\begin{itemize}
  \item \lstinline!TBZ Rt, bit, label! \quad Test and branch if Rt<bit> zero
  \item \lstinline!TBNZ Rt, bit, label! \quad Test and branch if Rt<bit> is not zero
\end{itemize}

这些指令检测由立即数指定的 bit 位与源寄存器中的 bit 位是否满足条件（Z 或 NZ），然后根据检测的结果跳转。
这个跳转指令的偏移范围是 $\pm32KB$。
这两个指令与 CBZ/CBNZ 一样不会读写状态码（NZCV）。

\subsubsection{系统控制及其它指令}

\BlockDesc{异常处理指令}

A64 有三个异常处理指令用于产生一个异常。
这些指令用于产生一个高异常级的代码调用，分别是 OS（EL1）、Hypervisor（EL2）和 Secure Monitor（EL3）：

\begin{itemize}
  \item \lstinline!SVC \#imm16! \quad Supervisor 调用，允许应用程序调用内核代码。
  \item \lstinline!HVC \#imm16! \quad Hypervisor 调用，允许 OS 代码 调用 hypervisor (EL2)。
  \item \lstinline!SMC \#imm16! \quad Secure Monitor 调用，允许 OS 或 hypervisor 调用 Secure Monitor (EL3)。
\end{itemize}

立即数存放到 \textit{Exception Syndrome Register} 里的 handler 中。
这是一个从 ARMv7 的改动，ARMv7 的立即数需要由所调用指令的 opcode 确定。
详情请看章节~\ref{sec:exception}。

若要从异常返回，则使用 \lstinline!ERET! 指令。
该指令从过将 SPSR\_ELn 寄存器复制到 PSTATE 来恢复处理器状态，并且跳转到保存在 ELR\_ELn 中的地址继续运行。

\BlockDesc{系统寄存器访问指令}

有两条可以访问系统寄存器的指令：
\begin{itemize}
  \item \lstinline!MRS Xt, <system register>! \quad 读取系统寄存器的值到通用寄存器。

    例如 \lstinline!MRS X4, ELR_EL1 // Copies ELR_EL1 to X4!
  \item \lstinline!MSR <system register>, Xt! \quad 写入通用寄存器中的配置值到系统寄存器。

    例如 \lstinline!MSR SPSR_EL1, X0 // Copies X0 to SPSR_EL1!
\end{itemize}

MSR 或 MRS 也可以单独获取 PSTATE 寄存器中的 field。
例如，选择关联于 EL0 的 Stack Pointer 或当前的异常级：

\begin{lstcode}
  // A value of 0 or 1 in this register is used to select
  // between using EL0 stack pointer or the current exception
  // level stack pointer
  MSR SPSel, #imm
\end{lstcode}

以下两个指令有一些特殊的形式可以用于清除或设置独立的异常掩码位：

\begin{lstcode}
  MSR DAIFClr, #imm4
  MSR DAIFSet, #imm4
\end{lstcode}

\BlockDesc{Debug 指令}

A64 有两个调试相关的指令：

\begin{lstcode}
  // Enters monitor mode debug, where there is on-chip debug monitor
  // code
  BRK #imm16
  // Enters halt mode debug, where external debug hardware is connected
  HLT #imm16
\end{lstcode}

\BlockDesc{Hint 指令}

HINT 指令可以被合理的视作 NOP，但是注意这些指令受特定实现的影响。

\begin{stblr}
  {Hint 指令}
  {a64-isa-hint}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  指令 & 说明 \\
  \hline
  NOP & No operation - not guaranteed to take time to execute \\
  YIELD & Hint that the current thread is performing a task that can be swapped out \\
  WFE & Wait for Event \\
  WFI & Wait for interrupt \\
  SEV & Send Event \\
  SEVL & Send Event Local \\
  \hline[1pt]
\end{stblr}

\BlockDesc{NEON 指令}

NEON 指令在 A64 下也有很大加强，有些加强至关重要。
章节~\ref{sec:floating-neon} 有更多的说明细节，下面简单列出 NEON 在 A64 下的改进：

\begin{itemize}
  \item 支持双精度浮点类型，向量化 C 代码下的双精度浮点类型。
  \item 新增将标量数据存储到 NEON 寄存器的指令。
  \item 新增插入和提取向量元素的指令。
  \item 新增类型转换和饱和整型算术运算指令。
  \item 新增浮点数值正规化（normalization）指令。
  \item 新增向量 reduction、summation 和获取最大最小值的 cross-lane 指令。
\end{itemize}

已经扩展了诸如比较、加法、查找绝对值和否定（negate）等指令，得以操作 64-bit 元素。

\BlockDesc{浮点指令}

A64 提供了一些类似 ARMv7 VFPv4 扩展的浮点指令，这些指令提供了对标量浮点值之间的单精度和双精度数学运算。
以下列举了一些改进和新特性：

\begin{itemize}
  \item 浮点比较直接设置状态码（NZCV）。
    A64 下不用在特意转换浮点 flag 为整型 flag。
  \item 增添了关于 IEEE754 - 2008 标准的指令，例如计算一对数字的最小值和最大值。
  \item 转换整型数据到浮点型时，可以明确指定为 rounding 模式。
    在特别的 rounding 模式下进行的简单转换，已不再需要设置全局 FPCR flag。
    ARMv8 的 A32 和 T32 也支持其中一些选项。
  \item 新增 64-bit 整型到浮点型格式转换指令。
  \item A64 下，直接在整型寄存器中进行涉及整型的浮点操作。
    进行转换操作时，已不再需要手动转换整型值和浮点值以及整型寄存器。
\end{itemize}

\BlockDesc{加密算法指令}

可以通过添加可选的加密算法指令扩展来极大的提升关于 AES 加密、SHA1 和 SHA256 hashing 等任务的效率。

\subsection{浮点与 NEON} \label{sec:floating-neon}

ARM 架构下，软件支持的高级 SIMD 架构的关联实现称为 NEON 技术。
AArch32（相当于 ARMv7 NEON 指令）和 AArch64 都含有 NEON 指令集。
AArch32 和 AArch64 下的 NEON 指令都可以加速大数据量的重复操作。
经典的应用是多媒体数字信号编解码。

AArch64 的 NEON 架构使用 32 个 128-bit 寄存器，是 ARMv7 的两倍。
浮点指令也使用同样的寄存器。
所有编译的代码和子程序都遵循 EABI，EABI 定义了在特殊的子程序中哪些寄存器可以被写入使用（corrupt，可以被破坏意为能被写入使用），哪些寄存器需要保留。
编译器可以自由的在代码任意点使用 NEON/VFP 寄存器保存浮点数和 NEON 数据。
所有的标准的 ARMv8 实现都需要包括浮点和 NEON。
但是，面向特殊用途的实现中可以采取以下组合：
\begin{itemize}
  \item 不实现 NEON 或浮点
  \item 完全实现包含异常的浮点和 SIMD。
  \item 实现不包含异常的浮点和 SIMD。
\end{itemize}

\BlockDesc{NEON 和浮点新特性}

AArch64 NEON 是基于 AArch32 NEON，包括以下改动：
\begin{itemize}
  \item 从 16 个寄存器增加到 32 个。
  \item 长度大的寄存器不再是通过长度小的寄存器组合而成，而是将 128-bit 的寄存器的低有效位映射为长度较小的寄存器。
    单精度的浮点数使用 128-bit 寄存器的低 32 位，双精度数使用用低 64 位。
  \item 去掉 V 前缀。
  \item 向向量寄存器中写入小于等于 64 bit 的数据，寄存器的高位则被清零。
  \item AArch64 下不存在使用通用寄存器的 SIMD 或饱和运算指令\footnote{
      饱和指令（Saturating instructions）是一类特殊的指令，用于执行饱和运算。
      饱和运算是一种数学运算，它限制结果在一个特定的范围内，超出范围的值将被截断或限制在范围边界上。

      例如，在使用 8 位无符号整数表示的情况下，如果一个运算结果大于 255（即超出了 8 位无符号整数的范围），则饱和运算将结果限制为 255。
      类似地，如果结果小于 0，则饱和运算将结果限制为 0。

      饱和指令通常用于数字信号处理（DSP）和媒体处理等应用中，这些应用对数据精度和动态范围有严格的要求。
      使用饱和指令可以确保结果不会溢出，并且可以避免由于溢出而引起的意外行为或失真。
    }。
    这些操作全部使用 NEON 寄存器。
  \item 新增 lane 插入和提取指令以支持新的寄存器 pack 模式。
  \item 添加额外的指令用于生产或消费 128-bit 向量寄存器的高 64 bit。
    会产生多于一个寄存器的结果（扩展到 256-bit 向量）或者消耗两个源（收缩成一个向量）的数据处理指令已经划分成不同的指令。
  \item 新增向量 reduction 操作集，提供 across-lane 加法、最小值和最大值操作。
  \item 扩展一些已有的指令以支持 64-bit 整数。
    例如：比较、加法、取绝对值和否定等指令，并且包括 staturating 版本。
  \item 扩展饱和指令，以便在无符号累加和有符号累加之间进行转换（to include Unsigned Accumulate into Signed, and Signed into Unsigned Accumulate）。\footnote{
      表明饱和指令现在具有更多的灵活性，可以在有符号累加和无符号累加之间进行转换，并在结果溢出时执行饱和处理，以确保结果在指定的范围内。
    }
  \item AArch64 NEON 现已支持双精度类型的浮点数和完整的 IEEE754 操作，包括 rounding 模式、非规范化数字和 NaN 处理。
\end{itemize}

AArch64 加强了浮点功能，改动如下（相对于 ARMv7）：

\begin{itemize}
  \item 前缀 V 替换成 F。
  \item 先已支持 IEEE754 浮点标准定义的单精度（32-bit）和双精度（64-bit）浮点向量数据类型和运算。
    遵循 FPCR 寄存器中指定的舍入模式来执行浮点数运算\footnote{
    “Honoring the FPCR Rounding Mode field”表示处理器或者软件库遵循浮点控制寄存器（Floating Point Control Register，FPCR）中的舍入模式字段（Rounding Mode field）。

      在 IEEE 754 浮点数标准中，舍入模式指定了在进行浮点数运算时如何处理结果的舍入方式。
      常见的舍入模式包括向最接近的偶数舍入、向正无穷大舍入、向负无穷大舍入、向零舍入等。
    }
    、默认的 NaN 控制、Flush-to-Zero 控制\footnote{
      Flush-to-Zero 控制允许在执行浮点数运算时将非常小的结果舍入为零。
      当启用 Flush-to-Zero 模式时，如果计算得到的结果小于一个设定的阈值（通常是一个非常小的正数，例如 IEEE 754 中的 subnormal number），则结果将被直接截断为零，而不是保留非常小的非零值。
    }
    和异常 trap 使能位（由具体实现所支持）。
  \item FP/NEON 寄存器的 Load/Store 寻址模式与整型的 Load/Store 相统一，包括加载或存储一对浮点寄存器的操作。
  \item 添加与整型 CSEL 和 CCMP 指令等效的浮点 FCSEL 和 选择并比较指令。

    类似 ARMv7，浮点 FCMP、FCMPE、FCCMP 和 FCCMP 指令根据浮点比较结果设置 PSTATE.\{N, Z, C, V\} 标志，但是不会更改 FPSR 寄存器中的状态标志。
  \item 合并所有浮点乘加（Multiply-Add）和乘减（Multiply-Subtract）指令\footnote{
      “Fused Multiply-Add (FMA)”指的是在单个指令中执行乘加运算的能力。
      这意味着指令可以同时进行乘法和加法操作，并且结果是精确的。
      这样可以提高性能，并且在一些情况下可以提高数值计算的精度。

      该变化意味着所有的浮点数乘加和乘减指令都支持 FMA 功能。
      也就是说，这些指令在执行乘加或乘减运算时，都能够同时进行乘法和加法（或减法），而不需要将乘法结果存储到临时变量中再进行加法或减法操作。

      使用 FMA 指令可以提高性能，因为它可以将乘法和加法操作合并为一个指令，并且可以在硬件级别上并行执行这两个操作。
      这样可以减少指令的数量，降低了指令调度和执行的开销，并且可以提高代码的并行性。
    }。

    VFPv4 首次介绍了 Fused multiply，这个功能意味着在执行加法运算前不会近似乘法运算的结果。
    早期的 ARM 浮点架构乘法累加操作对中间结果和最终结果都会进行近似，导致潜在的精度丢失。

  \item 新增转换操作，例如：64-bit 整型和单精度及双精度浮点型数据转换。
    转换浮点到整型数据（FCVTxU、FCVTxS）的指令有如下的有向舍入编码模式：

    \begin{itemize}
      \item[-] 到 0。
      \item[-] 到 $+\inf$。
      \item[-] 到 $-\inf$。
      \item[-] 到一个接近的偶数。
      \item[-] 到更远离零的那个整数\footnote{在“Nearest with ties to away”这种舍入模式下，如果一个值恰好处于两个整数的中间，它会舍入到远离零的整数。
          换句话说，如果一个值恰好处于两个整数的中间，它会舍入到更远离零的那个整数。
        }。
    \end{itemize}
  \item 新增包含相同有向舍入模式并且可根据当前环境进行舍入的浮点向邻近整型舍入的指令（FRINTx）。
  \item 新增不精确的舍入到奇数的双精度到单精度向下转换指令，适合通过正确的近似（FCVTXN）进行现场向下转换到半精度类型。
  \item 添加了 FMINNM 和 FMAXNM 指令，这两个指令用来实现 IEEE754 - 2008 中的操作 minNum() 和 maxNum()。
  如果其中一个操作数是静态 NaN，则返回数值。
  \item 新增浮点向量规范化加速指令（FRECPX 和 FMULX）。
\end{itemize}

\subsubsection{NEON 和 Floating-Point 架构}

NEON 寄存器保存有相同数据类型的元素组成的向量。
一个向量被分成许多 lane，每个 lane 含有一个称为元素（element）的数据值。

NEON 向量的 lane 数量取决于向量的大小和向量中的数据元素。

通常，每个 NEON 指令会产生 n 个并行操作，n 是输入向量分成的 lane 数量。
从一个 lane 到另外一个 lane 不能涉及进位或溢出。
向量的元素顺序是从最低有效位开始，说明元素 0 使用寄存器的最低有效位。

NEON 和 浮点指令操作适用于以下类型的元素：

\begin{itemize}
  \item 32-bit 单精度和 64-bit 双精度浮点类型。
    \begin{Tcbox}[title={Note}]
      16-bit 浮点类型也是支持的，但是只能作为一种被转换的类型，而不能被直接处理。
    \end{Tcbox}
  \item 8-bit、16-bit、32-bit 或 64-bit 的无符号和有符号整型。
  \item 8-bit 和 16-bit 多项式。

    多项式类型用于代码，例如使用 2 的幂有限域\footnote{
      有限域（Finite Field）算术是一种在有限域上进行的数学运算。
      有限域也称为 Galois 域，是一个包含有限数量元素的数学结构。
      在有限域中，加法和乘法运算满足特定的性质，类似于实数域或复数域中的运算。

      有限域中的元素可以是整数模素数的余数，也可以是多项式系数模一个不可约多项式的余数。
      在密码学、编码理论、数字通信等领域，有限域的理论和运算被广泛应用。
    }
    或者在 \{0, 1\} 上的简单多项式的错误纠正。
    通常的 ARM 整型代码一般使用查表的方式进行有限域运算。
    而 AArch64 NEON 则提供了使用巨大查找表的指令。

  \item 多项式运算很难从其他运算中合成出来，因此拥有一个基本的乘法运算非常有用，可以从中合成其他更大的运算。
\end{itemize}

NEON 单元将寄存器文件视作：

分别视作 32 个 128-bit 四字寄存器 V0-V31 为：

\Figure[caption={V 寄存器拆分}, label={fig:v-reg-div}, width=0.95]{divisions-of-the-v-regs}

分别视作 32 个 64-bit 双字寄存器 D0-D31 为：

\Figure[caption={D 寄存器拆分}, label={fig:d-reg-div}, width=0.95]{divisions-of-the-d-regs}

可以在任意时间访问这些寄存器。
由于所使用的指令决定了合适的视角（view），所以软件不需要明确地调整当前该使用哪种寄存器。

\paragraph{Floating-Point}

AArch64 的浮点单元将 NEON 寄存器文件视作：

\begin{itemize}
  \item 32 个 64-bit D 寄存器 D0-D31。
    D 寄存器称为双精度寄存器，可以保存双精度浮点数。
  \item 32 个 32-bit S 寄存器 S0-S31。
    S 寄存器称为单精度寄存器，可以保存单精度浮点数。
  \item 32 个 16-bit H 寄存器 H0-H31。
    H 寄存器称为半精度寄存器，可以保存半精度浮点数。
  \item 以上视角的寄存器合并。
\end{itemize}

\Figure[caption={浮点寄存器的拆分}, label={fig:fp-reg-div}, width=0.95]{fp-reg-div}

\paragraph{标量数据和 NEON}

标量数据是一个单一值，而非包含在向量中的多个值。
一些 NEON 指令使用标量操作数。
寄存器中的标量的获取通过向量的索引。

以通用的数组形式访问向量中的单个元素的格式如下：

\lstinline!<Instruction> Vd.Ts[index1], Vn.Ts[index2]!

其中，

\begin{itemize}
  \item[] Vd 是目的寄存器。
  \item[] Vn 是第一个源寄存器。
  \item[] Ts 用于指定元素的大小。
  \item[] index 是元素的索引。
\end{itemize}

例如：

\lstinline[language={[ARM]Assembler}]!INS V0.S[1], V1.S[0]!

\Figure[caption={插入一个元素到向量}, label={fig:insert-an-element-into-a-vector}, width=0.95]{insert-an-element-into-a-vector}

\lstinline!MOV V0.B[3], W0! 指令操作是将 W0 寄存器中的最低有效 byte 拷贝到 V0 寄存器的第四个 byte 位置中。

\Figure[caption={移动一个标量数到一个 lane}, label={fig:moving-a-scalar-to-a-lane}, width=0.95]{moving-a-scalar-to-a-lane}

NEON 标量可以是 8-bit、16-bit、32-bit 或是 64-bit 数值。
除了乘法指令外，其它指令都可以从寄存器文件中获取任意元素做为标量。

乘法指令只允许 16-bit 或 32-bit 标量，并且只能获取到寄存器文件中的前 128 个标量：

\begin{itemize}
  \item 16-bit 标量限制在寄存器 \lstinline!Vn.H[x]!，其中 $0 \leq n \leq 15$。
  \item 32-bit 标量限制为寄存器 \lstinline!Vn.S[x]!。
\end{itemize}

\paragraph{Floating-Point 参数}

浮点数值通过浮点寄存器传输给函数（或者返回来）。
可以同时使用整型（通用）和浮点寄存器。
也就是说，浮点参数以 H、S 或 D 寄存器传输，其它参数则通过 X 或 W 寄存器。
AArch64 调用标准强制规定只要使用到浮点运算的地方就必须使用硬件浮点运算，所以没有软件相关的浮点运算库。

详细的指令参考《ARMv8-A Architecture Reference Manual》，下面列举了一些浮点数据处理操作：

\begin{ltblr}
  {colspec={c>{\centering\arraybackslash}X}, width=1\textwidth}
  \hline[1pt]
  \lstinline!FABS Sd, Sn! & Calculates the absolute value. \\
  \lstinline!FNEG Sd, Sn! & Negates the value. \\
  \lstinline!FSQRT Sd, Sn! & Calculates the square root. \\
  \lstinline!FADD Sd, Sn, Sm! & Adds values. \\
  \lstinline!FSUB Sd, Sn, Sm! & Subtracts values. \\
  \lstinline!FDIV Sd, Sn, Sm! & Divides one value by another. \\
  \lstinline!FMUL Sd, Sn, Sm! & Multiplies two values. \\
  \lstinline!FNMUL Sd, Sn, Sm! & Multiplies and negates. \\
  \lstinline!FMADD Sd, Sn, Sm, Sa! & Multiplies and adds (fused). \\
  \lstinline!FMSUB Sd, Sn, Sm, Sa! & Multiplies, negates and subtracts (fused). \\
  \lstinline!FNMADD Sd, Sn, Sm, Sa! & Multiplies, negates and adds (fused). \\
  \lstinline!FNMSUB Sd, Sn, Sm, Sa! & Multiplies, negates and subtracts (fused). \\
  \lstinline!FPINTy Sd, Sn! & Rounds to an integral in floating-point format (where y is one of a number of rounding mode options) \\
  \lstinline!FCMP Sn, Sm! & Performs a floating-point compare. \\
  \lstinline!FCCMP Sn, Sm, \#uimm4, cond! & Performs a floating-point conditional compare. \\
  \lstinline!FCSEL Sd, Sn, Sm, cond! & Floating-point conditional select if (cond) Sd = Sn else Sd = Sm. \\
  \lstinline!FCVTSty Rn, Sm! & Converts a floating-point value to an integer value (ty specifies type of rounding). \\
  \lstinline!SCVTF Sm, Ro! & Converts an integer value to a floating-point value. \\
  \hline[1pt]
\end{ltblr}

\subsubsection{AArch64 NEON 指令格式}

AArch64 改动了 NEON 和浮点指令的语法以协调核心整型和标量浮点指令集语法。
这些指令的助记符和 ARMv7 NEON 非常接近。

\begin{itemize}
  \item 移除 ARMv7 NEON 指令中存在的前缀 V。

    重命名了与核心指令集冲突的助记符，并且移除 V 前缀。

    这意味相同名字的指令会做相同的事情，并且可以是核心指令、NEON 指令或者浮点指令，而只是语法上有区别。
    例如：

    \lstinline!ADD W0, W1, W2{, shift #amount}!
    和
    \lstinline!ADD X0, X1, X2{, shift #amount}!

    都是 A64 基础指令。

    \lstinline!ADD D0, D1, D2!

    是一个标量浮点指令。

    \lstinline!ADD V0.4H, V1.4H, V2.4H!

    则是一个 NEON 向量指令。

  \item 指令的前缀上添加了 S、U、F 或 P 前缀，用以表示 Signed、Unsigned、Floating-point 或 Polynomial 数据类型。
    指令根据该助记符来选择相应数据类型的操作。
    例如：

    \lstinline!PMULL V0.8B, V1.8B, V2.8B!

  \item 寄存器修饰符描述向量寄存器的组织形式（元素大小和 lane 数量）。
    例如：

    \lstinline!ADD Vd.T, Vn.T, Vm.T!

    其中，Vd、Vn 和 Vm 都是寄存器的名字，而 T 则是将被使用到的寄存器细分。
    就此例而言，T 是做为排列说明符 8B、16B、4H、8H、2S、4S 或 2D 中的一个。
    任意上述的排列说明符都可以使用，取决于数据类型的宽度（64、32、16 或 8-bit）以及寄存器的位宽（64 bit 或 128 bit）。

    若要对 2 个 64-bit 的 lane 相加，则是用

    \lstinline!ADD V0.2D, V1.2D, V2.2D!

  \item ARMv7 中，一些 NEON 数据处理指令存在 Normal、Long、Wide、Narrow 和 Staturating 变种。
    Long、Wide 和 Narrow 变种以后缀标识：

    \begin{itemize}
      \item[-] \textit{Normal 指令}可以对任何向量类型进行操作，并生成与操作数向量相同大小且通常相同类型的结果向量。
      \item[-] \textit{Long 指令}或 \textit{Lengthening 指令}对双字向量操作数进行操作并产生四字向量结果。
        结果元素的宽度是操作数的两倍。
        长指令使用附加到指令的 L 来指定。
        例如：

        \lstinline!SADDL V0.4S, V1.4H, V2.4H!

        下图展示了该操作，输入操作数在运算之前被提升。

        \Figure[caption={NEON Long 指令}, label={fig:NEON-long-insts}, width=0.6]{NEON-long-insts}

    \end{itemize}

  \item \textit{Wide} 或 \textit{Widening 指令}对双字和四字向量操作数进行操作，产生四字向量。
    产生的结果元素（第一个操作数）的长度是第二个操作数元素长度的两倍。
    Wide 指令含有一个 W 后缀。
    例如，

    \lstinline!SADDW V0.4S, V1.4H, V2.4S!

    下图展示该操作，输入的双字操作数在运算前被提升。

    \Figure[caption={NEON Wide 指令}, label={fig:NEON-wide-insts}, width=0.6]{NEON-wide-insts}

  \item \textit{Narrow} 或 \textit{Narrowing 指令}对四字向量进行操作，并且生成双字向量。
    生产的元素通常为操作数元素长度的一半。
    Narrow 指令用 N 后缀指定。
    例如，

    \lstinline!SUBHN V0.4H, V1.4S, V2.4S!

    下图展示该操作，输入操作数在运算前被降级。

    \Figure[caption={NEON Narrow 指令}, label={fig:NEON-narrow-insts}, width=0.6]{NEON-narrow-insts}

  \item 一些指令存在 Signed 和 unsigned staturating 变种（以 SQ 或 UQ 前缀标识），比如 SQADD 和 UQADD。
    如果结果超出了数据类型的最大值或最小值，那么 saturating 指令则返回其最大值或最小值。
    Saturation 的限制取决于指令所用的数据类型。

    \begin{stblr}
      {Saturation ranges}
      {NEON-saturation-ranges}
      {cc}
      \hline[1pt]
      Data type & Saturation range of x \\
      \hline
      Signed byte (S8) & $-27 \leq x < 27$ \\
      Signed halfword (S16) & $-215 \leq x < 215$ \\
      Signed word (S32) & $-231 \leq x < 231$ \\
      Signed doubleword (S64) & $-263 \leq x < 263$ \\
      Unsigned byte (U8) & $0 \leq x < 28$ \\
      Unsigned halfword (U16) & $0 \leq x < 216$ \\
      Unsigned word (U32) & $0 \leq x < 232$ \\
      Unsigned doubleword (U64) & $0 \leq x < 264$ \\
      \hline[1pt]
    \end{stblr}

  \item ARMv7 中示意为 pairwise 操作的 P 前缀现已在 ARMv8 中改成后缀，比如 ADDP。
    Pairwise 指令操作相邻的双字或四字操作数对。
    例如：

    \lstinline!ADDP V0.4S, V1.4S, V2.4S!

    \Figure[caption={Pairwise 操作}, label={fig:pairwise-op}, width=0.6]{pairwise-op}

  \item 添加 V 后缀到 across-all-lanes（整个寄存器）操作，比如 ADDV。
    例如：

    \lstinline!ADDV S0, V1.4S!

    \Figure[caption={Across all lanes 操作}, label={fig:across-all-lanes-op}, width=0.6]{across-all-lanes-op}

  \item 为新的加宽、缩小或加长的第二部分指令添加了 2 后缀，称为第二和上半部分说明符。
    如果存在该后缀，那么相应的操作会保持较窄元素的寄存器的高 64 位上执行操作。

    \begin{itemize}
      \item[-] 带有 2 后缀的加宽指令从包含较窄值的向量的高编号通道获取输入数据，并将扩展结果写入 128 位目标。
        例如：

        \lstinline!SADDW2 V0.2D, V1.2D, V2.4S!

        \Figure[caption={SADDW2}, label={fig:saddw2-inst}, width=0.6]{saddw2-inst}

      \item[-] 带有 2 后缀的 Narrowing 指令从 128-bit 的源操作数获取它们的输入数据，并且将缩小后的结果插入到 128-bit 目的寄存器的高序 lane 中，低序 lane 保持不变。
        例如：

        \lstinline!XTN2 V0.4S, V1.2D!

        \Figure[caption={XTN2}, label={fig:xtn2-inst}, width=0.6]{xtn2-inst}

      \item[-] 带有 2 后缀的 Lengthening 指令从 128-bit 源向量寄存器的高序 lane 中获取它们的输入数据，并将加长的结果保存到 128-bit 目的寄存器中。
        例如：

        \lstinline!SADDL2 V0.2D, V1.4S, V2.4S!

        \Figure[caption={SADDL2}, label={fig:saddl2-inst}, width=0.6]{saddl2-inst}
    \end{itemize}

  \item 比较指令已通过使用状态码来表明当前状态，以及当前状态是有符号的还是无符号的。
    例如，CMGT 和 CMHI、CMGE 和 CMHS。

\end{itemize}

\subsubsection{NEON 编码替代方案}

NEON 编码有很多种形式。
本节只是简单的列举（详细内容可查看《ARM NEON Programmers Guide》）。
其中包括内联函数的使用、C 代码的自动矢量化、库的使用，当然还有直接用汇编语言编写。

内联函数是编译器用适当的 NEON 指令替换的 C 或 C++ 伪函数调用。
这允许您使用 NEON 实现中可用的数据类型和操作，同时允许编译器处理指令调度和寄存器分配。
这些 intrinsic 函数定义在 ARM C 语言扩展文档里。

ARM 编译器 6 下，Auto-vectorization 由 \lstinline!-fvectorize! 选项配置，然而高级优化中该选项是自动打开的（\lstinline!-O2! 和更高）。
只要 \lstinline!-O0! 选项开启，无论指不指定 \lstinline!-fvectorize! Auto-vectorization 都是关闭的。
因此您需要在 \lstinline!-O1! 优化下通过以下命令开启 auto-vectorization：

\lstinline!armclang --target=armv8a-arm-none-eabi -fvectorize -O1 -c file.c!

有多个支持 NEON 代码的软件库。
这些库随时间动态更新，因此其状态也无法把控，所以当前的支持情况并没有列举到该文档中。

虽然技术上而言，手动优化 NEON 汇编代码是可行的，但是由于流水线和内存访问时序的内部复杂依赖，手动优化是非常困难的。
ARM 强烈推荐直接使用 intrinsic 调用函数，而不是手写汇编。

\begin{itemize}
  \item 使用 instrinsic 函数比使用汇编助记符更简单。
  \item Instrinsic 函数提供了很好的跨平台可移植性。
  \item 使用 instrinsic 不需要关心内部流水线和内存访问时序。
  \item 大多数情况下能够或得很好的性能。
\end{itemize}

如果您不是一个经验丰富的汇编开发者，那么使用 intrinsic 通常能获得更好的性能。
Intrinsic 提供了和直接用汇编编写代码一样丰富的控制，但是把分配寄存器的任务分配给了编译器，因此您可以专注于算法。
这样会比汇编语言具有更好的代码维护性。

\subsection{ABI}

ARM 架构的 ABI（Application Binary Interface）指定了所有可执行本机代码模块都必须遵循的最基础规则，
只有严格遵循这些规则，这些执行程序才能正确的共同工作。
特定的编程语言（如 C++）会补充一些额外的规则。
操作系统或执行环境（例如 Linux）也会添加一些规则以满足它们特定需求。
不过这些额外的规则超出了 ARM 架构的 ABI。

AArch64 架构有若干 ABI 组成元素：

\begin{description}
  \item[Executable and Linkable Format (ELF)]
    AArch64 架构的 ELF 指定 object 和 执行文件的格式。
  \item[Procedure Call Standard (PCS)]
    AArch64 函数调用标准发行指定可以分开写出、编译并链接多少个能够一起工作的子例程。
    它指定调用例程和被调用者之间的约定，或者一个例程和它的执行环境之间的约定。
    例如，当调用一个例程或者栈空间分布时的要求。
  \item[DWARF]
    DWARF 是一个广泛使用的调试数据格式标准。
    AArch64 的 DWARF 基于 DWARF 3.0 之上添加了一些额外规则。
    详情查看 DWARF for the ARM 64-bit Architecture (AArch64)。
  \item[C and C++ libraries]
    ARM Compiler ARM C and C++ Libraries 和 Floating-Point Support User Guide 描述了 ARM C 和 C++ 库。
  \item[C++ ABI]
    C++ Application Binary Interface Standard for the ARM 64-bit Architecture 描述通用的 C++ ABI。
\end{description}

\subsubsection{通用寄存器中的参数}

通用寄存器分成了 4 组来满足函数调用：

\begin{description}
  \item[Argument registers] 包括 X0-X7。
    这些寄存器用于给函数传参并返回结果。
    在函数内部和调用其它函数之间，它们可做为暂存寄存器或调用保存寄存器变量来保存函数内部的临时数值。
    由于 AArch64 上将传参寄存器的个数增加到了 8 个，所以相比 AArch32 而言，减少了对栈的使用率，从而提升了函数调用的性能。
  \item[Caller-saved temporary registers] 包括 X9-X15。
    如果调用函数想要在调用其它函数之后保留这些寄存器的值，那么它必须要将调用其它函数后会受到影响的寄存器保存到自己的栈空间中。
    被调用的函数在修改这些寄存器并返回调用函数前，不需要考虑保存和恢复它们。
    也就是说调用函数必须保存这些寄存器，以确保寄存器的数值正确。
  \item[Callee-saved registers] 包括 X19-X29。
    这些寄存器是被调用函数需要保存的。
    只要子例程确保在修改这些寄存器之前保存这些寄存器的值，并在返回调用函数之前恢复这些寄存器的值即可。
  \item[Registers with a special purpose] 包括 X8, X16-X18, X29, X30。

    \begin{itemize}
      \item 
        X8 是间接结果寄存器，用于传输间接结果地址。
        例如，当一个函数返回一个大型结构体时。
      \item 
        % X16 and X17 are IP0 and IP1, intra-procedure-call temporary registers.
        % These can be used by call veneers and similar code, or as temporary
        % registers for intermediate values between subroutine calls. They are
        % corruptible by a function. Veneers are small pieces of code which are
        % automatically inserted by the linker, for example when the branch target is
        % out of range of the branch instruction.
        X16 和 X17 做为程序内调用临时寄存器 IP0 和 IP1。
        用于调用 veneers \footnote{
          Veneers 是一些被链接器自动插入的微小代码块，比如，当跳转目的地址超出跳转指令的适用范围时。
        }和类似代码，或者做为子例程调用之间的临时变量保存寄存器使用。
        这些寄存器容易被函数破坏。
      \item 
        X18 是平台寄存器并且保留给平台的 ABI 使用。
        这是一个没有赋予特殊意义的平台附加临时寄存器。
      \item 
        X29 用作 FP（frame pointer register）。
      \item 
        X30 用作 LR（link register）。
    \end{itemize}

\end{description}

下图展示了 64-bit X 寄存器。
其它寄存器参数信息可以参考相关章节。

\Figure[caption={ABI 中的通用寄存器}, label={fig:general-purpose-regs}, width=0.95]{general-purpose-regs}

\subsubsection{间接结果地址}

重申一下，X8（XR）寄存器用于传输间接结果地址。
以下是相关例子：

\begin{lstlisting}[
  language=C,
  caption={间接地址},
  label={lst:indirect-result-location}
]
//test.c//
struct struct_A
{
  int i0;
  int i1;
  double d0;
  double d1;
} AA;

struct struct_A foo(int i0, int i1, double d0, double d1)
{
  struct struct_A A1;
  
  A1.i0 = i0;
  A1.i1 = i1;
  A1.d0 = d0;
  A1.d1 = d1;
  
  return A1;
}

void bar()
{
  AA = foo(0, 1, 1.0, 2.0);
}
\end{lstlisting}

下面通过以下命令获取到汇编代码：

\begin{lstlisting}
  armclang -target aarch64-arm-none-eabi -c test.c
  fromelf-c test.o
  # 当然，以交叉编译链 aarch64-linux-gnu-gcc 编译也是可行的，为了引述文档说明，默认使用上面的编译命令。
  aarch64-linux-gnu-gcc -O0 -S test.c
\end{lstlisting}

\begin{Tcbox}[title={Note}]
  为了演示该机理，上面的代码要以没有优化的选项编译代码，否则编译器可能会把相关细节优化掉。
\end{Tcbox}

\begin{lstlisting}[
  language={[ARM]Assembler},
]
foo//
  SUB SP, SP, #0x30
  STR W0, [SP, #0x2C]
  STR W1, [SP, #0x28]
  STR D0, [SP, #0x20]
  STR D1, [SP, #0x18]
  LDR W0, [SP, #0x2C]
  STR W0, [SP, #0]
  LDR W0, [SP, #0x28]
  STR W0, [SP, #4]
  LDR W0, [SP, #0x20]
  STR W0, [SP, #8]
  LDR W0, [SP, #0x18]
  STR W0, [SP, #10]
  LDR X9, [SP, #0x0]
  STR X9, [X8, #0]
  LDR X9, [SP, #8]
  STR X9, [X8, #8]
  LDR X9, [SP, #0x10]
  STR X9, [X8, #0x10]
  ADD SP, SP, #0x30
  RET
bar//
  STP X29, X30, [SP, #0x10]!
  MOV X29, SP
  SUB SP, SP, #0x20
  ADD X8, SP, #8
  MOV W0, WZR
  ORR W1, WZR, #1
  FMOV D0, #1.00000000
  FMOV D1, #2.00000000
  BL foo:
  ADRP X8, {PC}, 0x78
  ADD X8, X8, #0
  LDR X9, [SP, #8]
  STR X9, [X8, #0]
  LDR X9, [SP, #0x10]
  STR X9, [X8, #8]
  LDR X9, [SP, #0x18]
  STR X9, [X8, #0x10]
  MOV SP, X29
  LDP X20, X30, [SP], #0x10
  RET
\end{lstlisting}

在这个例子中，结构体包含 16 个 byte。
根据 AArch64 的 AAPCS，结构体对象会通过 XR 返回其内存地址。

所产生的代码展示出：

\begin{itemize}
  \item W0, W1, D0 和 D1 用于传递整型和双精度型参数。
  \item bar() 函数使用栈空间保存 foo() 函数 返回的结构体值，并将 sp 存入 X8 中。
  \item 在 foo() 函数拿到地址进行后续操作之前，bar() 函数传递 X8 以及通过 W0、W1、D0 和 D1 传递其他的参数到 foo() 函数。
  \item foo() 函数可能会破坏 X8，所以 bar() 使用 SP 获取返回结构体。
\end{itemize}

使用 X8（XR）寄存器的优势是它并未降低用以传递函数参数的寄存器可用性。
AAPC64 的栈帧如下图所示。
帧指针 X29 指向保存在堆栈上的上一帧指针，LR（X30）保存在上一帧指针之后。
链上的最后一个帧指针应该设置为 0。
栈指针必须 16 byte 对齐。
堆栈框架的确切布局可能存在一些变化，特别是可变参数或无帧的函数。
具体细节可以参考 AAPCS64 文档。

\Figure[caption={栈帧}, label={fig:stack-frame}, width=0.4]{stack-frame}

\begin{Tcbox}[title={Note}]
  AAPCS 只指定了 FP 和 LR 寄存器块布局以及如何把这些块链到一起。
  上图的其它内容（包括两个函数帧之间的边界的精确位置）是未定义的，这些内容由编译器自由定义。
\end{Tcbox}

图~\ref{fig:stack-frame} 说明了一个栈帧使用了两个被调函数保存的寄存器（X19 和 X20）和一个临时变量，布局如下（左边的数字代表相对于 FP 的偏移）：

\begin{lstlisting}
  40: <padding>
  32: temp
  24: X20
  16: X19
   8: LR'
   0: FP'
\end{lstlisting}

为了维持栈指针的 16 byte 对齐，填补（padding）是必要的。

\begin{lstlisting}[
  language={[ARM]Assembler},
]
  function:
  STP X29, X30, [SP, #-48]! // Push down stack pointer and store FP and LR
  MOV X29, SP               // Set the frame pointer to the bottom of the new
                            // frame
  STP X19, X20, [X29, #16]  // Save X19 and X20

  /*
   * Main body of code
   */

  LDP X19, X20, [X29, #16] // Restore X19 and X29
  LDP X29, X30, [SP], #48  // Restore FP' and LR' before setting the stack
                           // pointer to its original position
  RET                      // Return to caller
\end{lstlisting}

\subsubsection{NEON 和 浮点寄存器中的参数}

AArch64 架构还有 32 个 NEON 和 浮点操作寄存器 V0 - V31。
以寄存器名称的不同来表明访问数据的大小。

\begin{Tcbox}[title={Note}]
  与 AArch32 不同，AArch64 中的 128-bit 和 64-bit 视角的 NEON 和 浮点寄存器不会在较窄的视角下重叠多个寄存器，所以 q1、d1 和 s1 都是寄存器 bank 中的同一条目。
\end{Tcbox}

\Figure[caption={ABI 中的 SIMD 和浮点寄存器}, label={fig:simd-fp-reg-abi}, width=0.95]{simd-fp-reg-abi}

\begin{itemize}
  \item V0 - V7 用于函数调用的参数传递以及从函数调用中返回值。
    在函数中，这些寄存器也会用于保存临时值（但是通常只用于函数调用）。
  \item V8 - V15 在函数调用期间必须由被调函数保护。
    只有低 64 bit 需要保护。
  \item V16 - V31 不需要保护（或者可以由调用函数保护）。
\end{itemize}

\subsection{异常处理} \label{sec:exception}

严格来讲，中断将打断软件的运行流程。
然而，在 ARM 术语中，这实际是异常。
异常是一些状态和系统事件，这些事件需要特权软件（异常处理函数）采取一些措施来保证系统的正常运行。
每类异常都由相关的异常处理函数与其关联。
一旦异常被处理完成，特权软件将恢复 CPU 核到异常前的执行状态。

异常分为以下几类：

\BlockDesc{Interrupts}

系统有两种中断类型为 IRQ 和 FIQ。

FIQ 优先级高于 IRQ。
这两种异常类型通常与 CPU 核的输入引脚相连。
假定没有关闭中断的情况下，外部硬件发起一个中断线路请求，并且在当前的指令执行完成后（虽然一些指令可以加载多个数值，但是可以被中断），引发对应的异常类型。
FIQ 和 IRQ 是 CPU 核的物理信号，当触发这些信号时，CPU 核便会响应关联的异常（中断使能的情况下）。
绝大多数的系统中，各种中断源都是用中断控制器连接的。
中断控制器对中断进行仲裁和优先级排序，每次提供一个串行化的信号给连接到 CPU 核的 FIQ 或 IRQ 信号口。
由于中断的发生与 CPU 在任意时刻执行的软件没有直接的关系，所以它们被分类为异步异常。
详情可见于 \textit{The Generic Interrupt Controller} 章节。

\BlockDesc{Aborts}

Abort 可能由取指令错误或者数据访问错误产生。
Abort 异常可能从外部的内存系统的数据访问错误产生（表面指定的地址与系统的真实内存不对应）。
另外，Abort 也可以通过 CPU 核的 MMU 产生。
操作系统使用 MMU abort 来给应用程序动态分配内存。

在取指令的过程中，指令在 pipeline 中可被标注为 abort 异常。
指令 abort 仅发生在 CPU 核尝试执行指令的时候。
异常发生在指令执行之前。
如果 pipeline 在会产生 abort 的指令进入 pipeline 的执行阶段前被刷新了，那么系统不再产生该 abort 异常。
数据 abort 由 load 或 store 指令产生，并且发生在系统尝试读写数据之后。

如果 Abort 异常由指令流的执行或尝试执行所产生，那么可以描述为同步异常，并且返回地址提供了产生异常的详细信息。

异步的 abort 异常不是由执行指令所产生，同时返回地址也不一定会提供产生 abort 的详细原因。
ARMv8-A 架构下，指令和数据 abort 是同步的。
异步异常是 IRQ/FIQ 和系统错误（System errors, SError）。

\BlockDesc{Reset}

复位（reset）被视为所实现的最高异常级别的特殊向量。
该向量即为，当发起该异常时 ARM 处理器将跳转的指令位置。
\lstinline!RVBAR_ELn! 保存该 reset 向量地址，其中 n 是所实现的最高异常级的序号。

所有核都有一个 reset 入口并且当它们被复位后立即采取复位异常。
该异常的优先级是系统内最高的，并且不能被屏蔽。
该异常用于上电后执行核上的初始化代码。

\BlockDesc{Exception generating instructions}

某些指令的执行也会产生异常。
一般，执行这些指令用于从运行在更高异常级的软件中获取其提供的服务（例如，系统调用服务）。

\begin{itemize}
  \item SVC（Supervisor Call）指令开启了用户模式程序向操作系统请求服务的功能。
  \item HVC（Hypervisor Call）指令开启了客户操作系统向虚拟机监控程序请求服务的功能。
  \item SMC（Secure monitor）指令开启了普通程序向安全程序请求服务的功能。
\end{itemize}

如果所产生的异常是由于 EL0 下取指而生成的，那么它将被视为 EL1 下的异常。
除非在非安全状态下设置了 \lstinline!HCR_EL2.TGE! 位，那么它将被带入 EL2 下。

如果所产生的异常是由其它异常级下取指所产生的，那么异常级保持不变。

本文档的前面讲述了 ARMv8-A 架构有 4 个异常级。
处理器的运行只能通过进入或返回一个异常的方式切换运行级。
当处理器从更高的异常级切换到更低的异常级时，运行状态可以保持不变，或者处理器可以从 AArch64 切换到 AArch32。
相反，处理器从更低的异常级切换到更高的异常级时，运行状态可以保持不变，或者处理器可以从 AArch32 切换到 AArch64。

\Figure[caption={异常执行流程}, label={fig:exception-flow}, width=0.6]{exception-flow}

上图示意出在应用程序运行过程中发生异常的程序流程。
处理器跳转到包含所有异常类的入口的向量表。
向量表包含通常表明有异常原因的调度代码，并且调度代码选择调用合适的函数处理所处异常。
调度代码执行完成后并返回到高级的处理函数，该函数执行 ERET 指令返回应用程序。

\subsubsection{异常处理寄存器}

如果发生异常，PSTATE 信息将被保存到 \lstinline!SPSR_ELn!（Saved Program Status Register）寄存器中，系统有 \lstinline!SPSR_EL3!、\lstinline!SPSR_EL2! 和 \lstinline!SPSR_EL1!。

\Figure[caption={AArch64 下的 SPSR}, label={fig:aarch64-spsr}, width=0.95]{aarch64-spsr}
\Figure[caption={AArch32 下的 SPSR}, label={fig:aarch32-spsr}, width=0.95]{aarch32-spsr}

% The SPRSR.M field (bit 4) is used to record the execution state (0 indicates AArch64 and 1
% indicates AArch32).
\lstinline!SPSR.M! 字段（bit 4）用于记录运行状态（0 表明 AArch64，1 为 AArch32）。

\begin{stblr}
  {PSTATE 字段}
  {pstate-field}
  {c>{\centering\arraybackslash}X}
  \hline[1pt]
  字段 & 说明 \\
  \hline
  NZCV & Condition flags \\
  Q & Cumulative saturation bit \\
  DAIF & Exception mask bits \\
  SPSel & SP selection (EL0 or ELn), not applicable to EL0 \\
  E & Data endianness (AArch32 only) \\
  IL & Illegal flag \\
  SS & Software stepping bit \\
  \hline[1pt]
\end{stblr}

The exception bit mask bits (DAIF) allow the exception events to be masked. The exception is
not taken when the bit is set.

\begin{description}
  \item[D] Debug exceptions mask.
  \item[A] SError interrupt Process state mask, for example, asynchronous External Abort.
  \item[I] IRQ interrupt Process state mask.
  \item[F] FIQ interrupt Process state mask.
\end{description}

SPSel 字段选择当前的该使用哪个异常级栈指针 \lstinline!SP_EL0!。
切换栈指针可以在除了 EL0 之外的任何异常级进行。
后续章节会讨论如何切换。

设置 IL 字段会导致执行下一条指令以触发异常。
该字段使用非法执行的返回，例如，尝试从 AArch64 返回 EL2 而实际系统运行状态是 AArch32。

SS（Software Stepping）字段在调试相关章节讲解。
调试器使用它执行一条指令然后对后续的指令发起一个调试异常。

当采取一个异常时，一些分开的字段（CurrentEL、DAIF 和 NZCV 等等）以一种紧凑的方式拷贝到 \lstinline!SPSR_ELn!（返回时相反）。

当以事件引发一个异常，处理器会自动采取一些特定的动作。
这些动作有更新 \lstinline!SPSR_ELn!（n 是异常发生时所处异常级）、
保存正确从异常返回时所需的 PSTATE 信息、
更新 PSTATE 以反应处理器的新状态（可能意味着异常级的发起或保持不变）以及
将从异常所需的返回地址保存到 \lstinline!ELR_ELn!。

\Figure[caption={异常处理}, label={fig:exception-handling}, width=0.5]{exception-handling}

记住，\lstinline!_ELn! 后缀表示这些寄存器在不同异常级的多个备份。
例如，\lstinline!SPSR_EL1! 与 \lstinline!SPSR_EL2! 是不同的物理寄存器。
另外，在同步或 SError 异常的情况下，也会把 \lstinline!ESR_ELn! 更新为表面异常产生原因的值。

软件通过执行 ERET 指令来通知处理器何时从异常返回。
执行 ERET 将从 \lstinline!SPSR_ELn! 恢复异常前的 PSTATE 值并且从 \lstinline!ELR_ELn! 恢复之前的程序运行地址。

上面已经讲述了 SPSR 如何为异常返回记录必要的状态信息。
下面将继续讲述 link 寄存器如何存储程序地址信息。
架构架构为函数调用和异常返回提供了单独的链接寄存器。

我们已经在 A64 指令集相关章节了解到 X30 寄存器用于从子例程中返回（通过 RET 指令）。
一旦我们执行了跳转链接（branch with link）指令（BL 或 BLR），那么返回值将被更新到 X30 寄存器中。
而 \lstinline!ELR_ELn! 寄存器用于存储从异常返回的地址。
当进入一个异常时，该寄存器值将被硬件自动更新，并且当执行 ERET 指令返回时，该寄存器的值会写入到 PC 中。

\begin{Tcbox}[title={Note}]
  当从异常返回时，如果 SPSR 的值与系统寄存器的设置冲突，那么您将看到一个错误。
\end{Tcbox}

\lstinline!ELR_ELn! 保存有指定异常类型的返回地址。
对于一些异常而言，这个返回值是发生异常指令地址的下一条指令地址。
例如，当一个 SVC 指令执行时，我们希望返回时能执行下一条指令。
在其他情况下，我们可能希望重新执行发生异常的指令。

对于异步异常来说，\lstinline!ELR_ELn! 指向由于获取中断而尚未执行或完全执行的第一条指令的地址。
系统允许处理函数代码修改 \lstinline!ELR_En!，例如，如果有必要返回到中止同步异常之后的指令地址。
ARMv8-A 模型已经明显比 ARMv7-A 简单了，然而处于兼容性的原因，从特定类型的异常中返回时仍然需要从链接寄存器中减去 4 或 8。

除了 SPSR 和 ELR 寄存器，每个异常级都包含其专用的栈指针寄存器。
这些寄存器被命名为 \lstinline!SP_EL0!、\lstinline!SP_EL1!、\lstinline!SP_EL2! 和 \lstinline!SP_EL3!。
这些寄存器用于指向专用栈，这些专用栈则可用于保存一些会被异常处理函数破坏的寄存器，那么便可以在异常返回时恢复这些被保存的寄存器。

异常处理代码可能会切换 \lstinline!SP_ELn! 为 \lstinline!SP_EL0!。
例如，\lstinline!SP_EL1! 可能指向一块小型的内核可以确保永久有效的栈内存上。
\lstinline!SP_EL0! 则可能指向一块大型的内核无法确保安全的（栈溢出）任务栈上。
通过控制 SPSel 字段进行切换，方法如下：

\begin{lstlisting}[
  language={[ARM]Assembler},
]
MSR SPSel, #0  // switch to SP_EL0
MSR SPSel, #1  // switch to SP_ELn
\end{lstlisting}

\subsubsection{同步和异步异常}

AArch64 中，异常分为同步和异步异常。
同步异常是由于尝试执行指令所引起的，并且返回地址包含导致异常的指令的详细信息。
异步异常不是指令的执行所引起的，返回地址也不一定会包含产生异常的信息。

异步异常是由 IRQ、FIQ 或 SError 产生的。
有不少可能导致系统错误异常的产生原因，其中最常见的是异步数据中止（例如 cache line 中的脏数据写回外部内存所触发的中止）。

同步异常的产生源头有：

\begin{itemize}
  \item MMU 产生的指令中止。
    比如，指令的内存地址设置为不可执行。
  \item MMU 产生的数据中止。
    例如，访问权限不足或对齐检查。
  \item SP 和 PC 对齐检查。
  \item 同步的外部中止。
    比如，读取也表时发生的中止。
  \item 未分配的指令
  \item 调试异常。
\end{itemize}

\BlockDesc{同步中止}

有很多产生同步异常的原因：

\begin{itemize}
  \item MMU 产生
  \item SP 和 PC 对齐检查
  \item 未分配的指令
  \item 服务调用指令（SVC、SMC 和 HVC）
\end{itemize}

操作系统可以用这些异常实现一些正常功能。
例如，在 Linux 中，一个 task 请求分配新的内存页的功能就是通过 MMU 中止机制。

ARMv7-A 架构中，预取中止、数据中止和未定义异常是分开的条目。
但是在 AArch64 中，这些异常会统一产生一个同步中止。
异常处理函数读取 syndrome 和 FAR 寄存器获取必要的信息来区分这些异常。

\BlockDesc{处理同步异常}

异常处理函数通过读取一些寄存器来获取异常产生的原因等信息。
其中，\lstinline!ESR_ELn!（Exception Syndrome Register）提供异常的产生原因。
\lstinline!FAR_ELn!（Fault Address Register）保存有关于同步指令、数据中止和对齐错误相关的出错的虚拟地址。

\lstinline!ELR_ELn!（Exception Link Register）保存产生数据访问中止时的指令地址（Data Abort）。
这通常在内存错误之后更新，但也会在其它情况下设置，比如跳转到一个非对齐的地址。

如果将异常从使用 AArch32 的异常级别转移到使用 AArch64 的异常级别，那么异常将以目标异常级的方式写 FAR 寄存器，也就是说 \lstinline!FAR_ELn! 的高 32 bit 会全部设成 0。

对于实现了 EL2（Hypervisor）或 EL3（Secure Kernel）的系统来说，同步异常通常由当前或者更高的异常级接管。
异步异常可以被路由到更高异常级处理。
\lstinline!SCR_EL3! 寄存器指定哪些异常被路由到 EL3。
同样的，\lstinline!HCR_EL2! 指定哪些异常被路由到 EL2。
IRQ、FIQ 和 SError 由一些单独的 bit 来独立控制。

\BlockDesc{系统调用}

一些指令和系统函数只能在特定的异常级下执行。
如果运行在一个较低的异常级下的代码需要采取特权操作，例如，当应用程序向内核请求功能时。
一种方式是使用 SVC 指令，该指令允许应用程序产生一个异常。
系统调用的参数则通过通用寄存器传入，或者编码在系统调用中。

\BlockDesc{EL2/EL3 的系统调用}

与应用程序向 EL1（内核）请求系统调用类似，请求 EL2 和 EL3 的服务同样有相应指令，分别为 HVC 和 SMC。
当处理器运行在 EL0 下，它无法直接向 EL2 提交服务请求，只能通过 SVC 先向内核提交请求，然后通过 EL1 下的内核来向 EL2 发起请求。

运行在 EL1 下的 OS 内核可以通过 HVC 指令调用 hypervisor 服务，也可以通过 SMC 调用安全监控服务。
如果处理器实现了 EL3，那么 EL2 能够捕获来自 EL1 的 SMC 指令。
如果没有 EL3，那么 SMC 不会被分配并且只在当前异常级触发。

同样，EL2 下的代码可以使用 SMC 调用 EL3 代码。
如果 SVC 指令在 EL2 或 EL3 下执行，那么它仍然会同一异常级产生一个同步异常，并且异常级下的处理函数来决定如何响应。

\BlockDesc{未分配的指令}

未分配的指令产生一个同步中止，当处理器执行以下指令时产生该类异常：

\begin{itemize}
  \item 没有分配操作码的指令
  \item 需要更高特权级执行的指令
  \item 禁用的指令
  \item PSTATE.IL 字段设置后的任意指令
\end{itemize}

% -----
\BlockDesc{The Exception Syndrome Register (ESR)}

\lstinline!ESR_ELn! 寄存器保存异常的信息，可由异常处理函数从中获取异常产生的原因。
它只会在发生同步异常和 SError 异常时更新。
它不会在产生 IRQ 或 FIQ 时更新，IRQ 和 FIQ 的状态信息保存在 GIC 的寄存器中（详情查阅 \textit{The Generic Interrupt Controller}）。
ESR 寄存器的编码如下：

\begin{description}
  \item[31:26] 异常类，异常处理函数可用以区分异常类别（例如未分配的指令、从 MCR/MRC 到 CP15 所产生的异常、FP 操作异常、SVC、HVC、SMC、数据中止和对齐异常）。
  \item[25] 异常指令的长度（0 代表 16-bit 指令；
    1代表 32-bit 指令），并且设置给特定异常类。
  \item[24:0] 形成 Instruction Specific Syndrome (ISS) 字段，包含该类异常的信息。
    例如：当系统调用指令（SVC、HVC 或 SMC）执行时，该字段包含指令的立即数，比如当执行 \lstinline!SVC 0x123456! 时该字段包含 0x123456。
\end{description}

\subsubsection{异常引起的执行状态和异常级的变化}

异常产生时，处理器可能改变运行状态也可能保持不变。
例如，当处理器运行在 AArch32 状态时，外部中断源可能引发中断，但是 OS 内核的中断处理函数运行在 AArch64 状态。

SPSR 寄存器会保存处理器的运行状态，以便异常返回时切换回去。
这个切换的动作是由处理器自动完成的，但是每个异常级别的运行状态的控制是通过以下方式完成的：

\begin{itemize}
  \item 硬件配置输入决定最高异常级别的初始运行状态（不一定为 EL3）。
    但是，并没有固定，因为有 \lstinline!RMR_ELn! 寄存器可以在处理器运行时改变最高异常级的运行状态。
    EL3 是安全监控代码，它是一个有特定运行状态的安全的小型代码块。
  \item EL2 和 EL1 的运行状态由 \lstinline!SCR_EL3.RW! 和 \lstinline!HCR_EL2.RW! 位。
    \lstinline!SCR_EL3.RW! 在 EL3 下配置控制 EL2 的运行状态。
    \lstinline!HCR_EL2.RW! 在 EL2 或 EL3 下配置控制 EL1/0 的运行状态。
  \item EL0 不会处理异常（只运行应用程序代码）。
\end{itemize}

如下图所示，考虑当应用程序正在 EL0 上运行时，发生了 IRQ 中断的情况。
而内核的 IRQ 处理函数运行于 EL1。
中断发生时，处理器会决定如何设置运行状态。
它通过查看更高异常级（EL2）的控制寄存器的 RW 位。
这个例子中它会查看 \lstinline!HCR_EL2.RW!。

\Figure[caption={到 EL1 的异常}, label={fig:exception-to-el1}, width=0.4]{exception-to-el1}

那么接下来还要考虑异常级别的切换。
同样的，异常发生时异常级别可以切到更高或保持不变。
老生常谈，EL0 不处理异常。

同步异常通常由当前异常级别或更高的异常级别处理。
然而，异步异常可以被路由到更高异常级。
对于安全代码来说，\lstinline!SCR_EL3! 可用于指定哪些异常可以路由到 EL3。
对于 hypervisor 代码而言，\lstinline!HCR_EL2! 可用于指定哪些异常可以路由到 EL2。

在所有的路由情况下，IRQ、FIQ 和 SError 都由独立的字段来控制。
处理器只会把异常带入到它被路由的异常级去处理。
异常不可能到比它出发的异常级低的级别去处理。
中断只能在其处理的异常级才能被屏蔽。

将异常从 AArch32 带入到 AArch64 时，需要做一些特殊考虑。
AArch64 处理代码可能需要访问 AArch32 的寄存器，因此架构将寄存器映射到 AArch32 上来对其进行访问。

AArch32 寄存器的 R0 到 R12 对应 X0 到 X12。
AArch32 不同模式的所有储备 SP 和 LR 寄存器对应于 X13 到 X23，储备 的 FIQ 寄存器 R8 到 R12 对应 X24 到 X29。
这些寄存器的 \verb![63:32]! 位在 AArch32 模式下无法获取，其值为 0 或者为上次在 AArch64 下写入的值。
架构不保证这些高位值，所以一般都以 W 寄存器去访问。

\subsubsection{AArch64 的异常向量表}

当异常发生时，处理器必须执行可以处理该异常的处理函数代码。
异常处理代码保存的内存地址称作异常向量。
ARM 架构下，异常向量存在一个表中，称为异常向量表。
除了 EL0 外，每个异常级都有一个异常向量表。
向量表中保存异常发生时要被执行的代码，而不是一些地址。
不同异常的向量被放在表中的固定地址偏移上。
分别通过向量基地址寄存器 \lstinline!VBAR_EL3!、\lstinline!VBAR_EL2! 和 \lstinline!VBAR_EL1! 设置每个表的虚拟地址。

向量表中的每个条目长度为 32 指令（单个指令为 4-byte）长度。
这相对 ARMv7 的向量表条目只有 4 byte 来说，有了重大的改变。
对于 ARMv7 来说，一个 4-byte 的条目只能存放一个跳转类型的指令，跳转到一个真正的异常处理函数地址上。
而 AArch64 的异常向量的空间足够大，可以直接在异常向量中直接处理异常。

下表展示了一个异常向量表。
基地址由 \lstinline!VBAR_ELn! 设置，而每个条目都在基于该地址的偏移上。
每个表含有 16 个条目，每个条目为 128 byte（32 条指令）。
向量表由 4 组 4 条目组成，使用哪个条目则由以下因素决定：

\begin{itemize}
  \item 异常类型（SError、FIQ、IRQ 和 同步异常）
  \item 如果异常在同一异常级产生，那么使用栈指针（SP0 或 SPx）
  \item 如果异常在较低的异常级产生，那么决定较低一级的执行状态（AArch64 或 AArch32）
\end{itemize}

\begin{ltblr}[caption={异常向量表}, label={tbl:exp-table}]
  {colspec={c>{\centering\arraybackslash}X>{\centering\arraybackslash}X}}
  \hline[1pt]
  地址 & 异常类型 & 描述\\
  \hline
  VBAR\_ELn+0x000  & Synchronous & \SetCell[r=4]{c} Current EL with SP0\\
  +0x080 & IRQ/vIRQ & \\
  +0x100 & FIQ/vFIQ & \\
  +0x180 & SError/vSError & \\
  \hline
  +0x200 & Synchronous & \SetCell[r=4]{c} Current EL with SPx\\
  +0x280 & IRQ/vIRQ & \\
  +0x300 & FIQ/vFIQ & \\
  +0x380 & SError/vSError & \\
  \hline
  +0x400 & Synchronous & \SetCell[r=4]{c} Lower EL using AArch64\\
  +0x480 & IRQ/vIRQ & \\
  +0x500 & FIQ/vFIQ & \\
  +0x580 & SError/vSError & \\
  \hline
  +0x600 & Synchronous & \SetCell[r=4]{c} Lower EL using AArch32\\
  +0x680 & IRQ/vIRQ & \\
  +0x700 & FIQ/vFIQ & \\
  +0x780 & SError/vSError & \\
  \hline[1pt]
\end{ltblr}

举个例子来理解上述的异常条目的选择。

如果内核代码正在 EL1 下运行，而此时正好发生了一个中断 IRQ，该中断并未关联到更高的异常级（hypervisor 或 secure 环境），那么该中断也是由 EL1 下的内核代码来处理（内核此时的栈是 \lstinline!SP_EL1!，并且设置在 SPSel 字段，那么异常处理代码也使用 \lstinline!SP_EL1!）。
所以，异常发生时的跳转地址即为 \lstinline!VBAR_EL1 + 0x280!。

由于 ARMv8 中不存在 \lstinline!LDR PC, [PC, #offset]! 指令，所以程序员必须使用更多的指令才能从寄存器表中读取到目的地址。
异常向量的间距的设计旨在避免未使用的向量对典型大小的指令高速缓存线造成高速缓存污染。
Reset 的地址是由\textbf{设计决定的}完全独立的地址，通常是硬件固化配置。
该地址可由 \lstinline!RVBAR_EL1/2/3! 等寄存器获取。

无论当前的异常级还是较低的异常级中每个异常都有独立的异常向量的设计给 OS 或 hypervisor 带来灵活性，即可以灵活的决定较低异常级的运行状态（AArch64 还是 AArch32）。
\lstinline!SP_ELn! 用于较低异常级产生的异常。
但是，软件可以在异常处理代码中切换到 \lstinline!SP_EL0!。
使用此机制有助于从处理程序的线程中访问变量值。

\subsubsection{中断处理}

ARM 通常使用中断（interrupt）来表示中断信号。
在 ARM A-profile 和 R-profile 处理器上，表示外部的 IRQ 或 FIQ 中断信号。
架构并未指定这些信号的使用方法。
FIQ 一般保留为安全中断源。
在早期的架构中，FIQ 和 IRQ 用于表示高中断优先级和标准中断优先级，但是 ARMv8-A 已经不是这种概念了。

当处理器在 AArch64 运行状态下产生一个异常时，所有的 PSTATE 中断屏蔽字段都会被自动设置。
这意味后面的异常都被关闭掉了。
如果软件想要支持嵌套异常，例如运行一个更高优先级的中断打断正在处理的低级的中断，那么软件必须明确的重新使能这些中断。

使用的指令如下：

% \noindent
{
  \lstinline!MSR DAIFClr, #imm!
}

立即数是一个 4-bit 长度的字段，表示：

\begin{itemize}
  \item PSTATE.A (SError)
  \item PSTATE.D (Debug)
  \item PSTATE.I (IRQ)
  \item PSTATE.F (FIQ)
\end{itemize}

\Figure[caption={C 中断处理示意}, label={fig:irq-hdl-in-c}, width=0.5]{irq-hdl-in-c}

一个汇编语言编写的 IRQ 处理函数类似为：

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={汇编 IRQ handler},
  label={lst:asm-irq-hdl}
]

IRQ_Handler
                          // Stack all corruptible registers
STP X0, X1, [SP, #-16]!   // SP = SP -16
//...
STP X2, X3, [SP, #-16]!   // SP = SP - 16
                          // unlike in ARMv7, there is no STM instruction and
                          // so we may need several STP instructions
BL read_irq_source        // a function to work out why we took an interrupt
                          // and clear the request
BL C_irq_handle           // the C interrupt handler
                          // restore from stack the corruptible registers
LDP X2, X3, [SP], #16     // S = SP + 16
LDP X0, X1, [SP], #16     // S = SP + 16
//...
ERET
\end{lstlisting}

然而，从性能考虑，下面的代码会更好一些：

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={汇编 IRQ handler (better)},
  label={lst:asm-irq-hdl-b}
]

SUB SP, SP, #<frame_size>   // SP = SP - <frame_size>
STP X0, X1, [SP}            // Store X0 and X1 at the base of the frame

STP X2, X3, [SP]            // Store X2 and X3 at the base of the frame + 16
//...                       // bytes more register storing
//...
                            // Interrupt handling
BL read_irq_source          // a function to work out why we took an interrupt
                            // and clear the request
BL C_irq_handler            // the C interrupt handler
                            // restore from stack the corruptible registers
LDP X0, X1, [SP]            // Load X0 and X1 at the base of the frame
LDP X2, X3, [SP]            // Load X2 and X3 at the base of the frame + 16
//...                       // bytes more register loading
ADD SP, SP, #<frame_size>   // Restore SP at its original value
//...
ERET 
\end{lstlisting}

\Figure[caption={处理嵌套中断}, label={fig:hdl-nest-irqs}, width=0.8]{hdl-nest-irqs}

嵌套的处理函数需要更多代码。
它必须将 \lstinline!SPSR_EL1! 和 \lstinline!ELR_EL1! 保存到栈上。
处理代码中也必须在确定（以及清除）中断来源后重新使能所有 IRQ。
然而（与 ARMv7-A 不同），用于子例程调用的链接寄存器和异常使用的链接寄存器是不同的，所以必须要避免对 LR 和 模式做任何特殊的操作。

\begin{probsolu}[title={Problem and Solution \theprob}]{
  如何处理嵌套中断？写出处理嵌套中断的代码。
  （可以从 FreeRTOS、RT-Thread 等代码中找到参考）
  }\label{pb:how-to-hdl-nest-irqs}

  经查阅，RT-Thread 在进入中断处理函数之前保存了浮点寄存器 Q0-Q31、通用寄存器 X0-X30、FPCR、FPSR、SP\_EL0、SPSR\_EL1 和 ELR\_EL1 到栈上。
  最后将栈保存到 X0 寄存器中。

  具体可查阅 RT-Thread 代码 \lstinline!aarch64/common/context_gcc.S!。
\end{probsolu}

\subsubsection{GIC}

ARM 提供了一个标准的中断控制器可用于 ARMv8-A 系统中。
该中断控制器的编程接口定义在 GIC 架构中。
GIC 架构定义了多个版本，本文档主要介绍 GICv2。
ARMv8-A 处理器与 GIC 连接，例如，GIC-400 或 GIC-500 等。
GIC 支持在多核之间路由软件产生的、私有和共享的外设中断。

\subsection{Caches}

ARM 架构开发初期，处理器的速度和访问内存的速度大体相近。
当今的处理器核心的运行速度要比内存访问速度快上许多。
然而，外部总线和存储设备的频率并没有达到与处理器相同的程度，所以可以在芯片内部实现一些与处理器内核同等速度的 RAM。
不过这些 RAM 与 DRAM 比起来非常昂贵，相比起来，DRAM 一般拥有数千倍以上的容量。
ARM 架构下，访问外部 ram 通常需要数十个处理器周期，甚至数千个。

Cache 是一个小型的快速的内存块，它存在于主内存和处理器之间，保存有主内存中的数据缓存。
访问 Cache 的速度比访问外存快很多。
处理核需要读取或者写入一个特定地址时，先去查看 Cache 里面有没有保存该地址的数据。
如果 Cache 找到该地址，那么它就使用 Cache 中的数据，并不再访问主内存。
由于减少了对外部内存的访问次数所以大大增加了系统的潜在性能。
另外，由于避免了驱动外部信号所以也减少了系统的功耗。

\Figure[caption={Cache 的基本组成}, label={fig:basic-cache-arrangement}]{basic-cache-arrangement}

ARMv8 架构处理器一般有 2 - 3 级 cache，通常每个 CPU 核都含有较小的一级 I-Cache 和 D-Cache。
基于 Cortex-A53 和 Cortex-A57 的处理器一般有 2 级及以上的 Cache，即较小的一级 I-Cache 和 D-Cache，以及更大的 Cluster 共享的二级 Cache。
另外，还可以增加 Cluster 之间共享的更大的 3 级 Cache。

系统初始状态访问数据不会得到加速，此时 Cache 也需要填充从内存中读取的数据。
然而，当 Cache 中缓存了一定量的数据，系统再次需要这些数据时，Cache 的加速功能便显现出来。
处理器在取指令或数据读写时先去检查 Cache，但是有一部分内存地址必须要标记为不可缓存的，比如外设寄存器地址空间。
由于 Cache 中只能缓存一小部分主存数据，所以必须要想出一种高效的方式来快速检测数据是否在 Cache 中。

有时，Cache 中的数据和外部主存的数据会出现不一致。
可能的情况有，处理器更新了 Cache 中的数据，但是还没有写回主存；
或者，某个硬件机构在处理器获取主存的数据后更改了主存中的数据，例如 DMA。
这种数据一致性的问题将在后续章节继续讲述。
这种问题在多核和有 DMA 的情况下特别需要注重。

\subsubsection{Cache 术语}

Von Neumann 架构定义单个 Cache 用于指令和数据的缓存（统一 Cache）。
Harvard 架构更新了该种形式，提出 I-Cache 和 D-Cache 分开缓存指令和数据的形式。
ARMv8 架构则在 L1 Cache 中使用 Harvard 形式，更高级使用统一的 Cache。

Cache 需要保存地址、数据和一些状态信息。

下图简略描述了 Cache 的术语及基础框架。

\Figure[caption={Cache 术语}, label={fig:cache-terminology}]{cache-terminology}

\begin{itemize}
  \item \textit{tag} 是保存在 Cache 中的部分内存地址，这部分地址用于连系内存地址和 Cache line。
    64 位内存地址的高字段告诉 Cache 数据信息在内存中的来源，该高字段即称为 \textit{tag}。
    总缓存大小衡量的是它可以保存的数据量，但用于保存 \textit{tag} 的 RAM 不包括在计算中。
    然而，tag 仍然是占用物理空间的。
  \item 如果每个 tag 下只存放一个 word，那么 tag 所占的比重就太大了，导致 Cache 的利用率很低。
    所以就定义了每个 tag 下可以存放 \textit{Cache line} 大小的数据。
    Cache line 是 Cache 可以提供的最小数据量，并且 Cache line 中保存的数据是内存中连续的数据 word。
    当 Cache line 中存有指令或数据时，称为有效（valid），反之则为无效（invalid）。

    Cache line 数据相关联有一个或多个状态位。
    通常，有一个有效位表明 Cache line 是否存在有效数据，意味着 tag 中含有真是数据。
    D-Cache 中也可能含有污染（dirty）位，用以表明该 Cache line 中的数据（或部分数据）与主存中数据是否不同（比其更新）。
  \item \textit{way} 是 Cache 的细分，每个 way 都具有相同的大小，相同的索引方式。
    \textit{set} 由所有 way 中的所有具有相同索引方式的 line 组成。
  \item 地址中的低字段（做为 offset），则不需要保存到 tag 中。
    Cache 给出的是一行（cache line）数据，所以地址中有 5 到 6 个最低有效位恒为 0（也就是说 cache line 有 $2^5$ - $2^6$ 个 byte）。
\end{itemize}

\BlockDesc{组（Set）相连 Cache 和 way}

ARM 架构下的 Cache 基本都是组相连的，这种类型的 Cache 极大的减少了直接映射型 Cache 的抖动（thrashing）问题\footnote{
Where main memory is accessed in a pattern that leads to multiple main memory locations competing for the same cache lines, resulting in excessive cache misses.
This is most problematic for caches that have low associativity.
 }，从而提升程序的执行速度并且增加了更多可预测的执行。
不过，该种类型的 Cache 也会增加硬件的复杂度和略微增加功耗，这是由于每个 cycle 下会比较多个 tag。

在这种类型的 Cache 组织方式下，Cache 被分成许多大小相同的块，这些块就是 \textit{way}。
那么内存地址便可以映射到 way，而不是 line 上。
可以使用地址中的索引字段继续选择特定的 line，但是此时它指向的是每个 way 中的单独 line。
通常，L1 Cache 中有 2 - 4 路，Contex-A57 则有 3-way 的 L1 I-Cache。
而 L2 Cache 通常有 16 路。

外部的 L3 Cache 的大小更大，所以有更多路，因此有更高的关联性。
具有相同索引值的 line 属于同一 set，于是检查是否命中需要查看 set 中的所有 tag。

下图是一个 2-way 相连的 Cache。
主存中的 0x00、0x40 和 0x80 可能出现在其中一路中，但是不会同时存在于两路中。

\Figure[caption={2-way 组相连 Cache}, label={fig:2-way-set-associative-cache}]{2-way-set-associative-cache}

关联性的增加（即增加 way 数）可以降低 thrashing 的概率。
最理想的情况是全相连 Cache，即主存和 Cache 一一映射，每个地址都能找到对应。
如果不是想缓存很少的数据来说（例如 TLB），构建这样的 Cache 是不现实的。
实际上，8-way 以上的对与性能来说提升很小，16-way 的关联性对于更大的 L2 才更有用。

\BlockDesc{tag 和 物理地址}

一个 tag 对应一条 line，用于记录关联于 line 的外部内存物理地址。
Cache line 的大小是由\textbf{实现决定的}，但是所有的 CPU 核都具有相同的 Cache line 大小，因为这些核之间是相互连系的。

要访问的物理地址决定数据缓存在 Cache 中的位置。
最低有效字段用于选择 Cache 中的相关条目。
中间字段用于选择 set 中的特定 line。
最高有效字段标识地址的剩余部分，并与保存的 tag 进行比较。
ARMv8 下数据 Cache 通常是 \textit{Physically Indexed, Physically Tagged}（PIPT），也可以是 non-aliasing \textit{Virtually Indexed, Physically Tagged}（VIPT）。

Cache line 包含以下成员：

\begin{itemize}
  \item 关联物理地址中的 tag 值。
  \item 表明 line 是否存在的有效位，亦即 tag 是否有效。
    如果缓存在多个核心之间是一致的，有效位也可以是 MESI 状态的状态位。
  \item 表明 Cache line 与外部内存不一致的 dirty 位。
\end{itemize}

一个简单的 4 路组相连的 32KB L1 D-Cache 如下所示，该 Cache 的 line 大小为 16-word（64 byte）。

\Figure[caption={32KB 4-way D-Cache}, label={fig:32KB-4-way-D-Cache}]{32KB-4-way-D-Cache}

\BlockDesc{包容或排它 Cache}

包容型 Cache 即数据可以同时存在与 L1 和 L2 Cache 中。
排它型 Cache 即数据只能同时存在于单级 Cache，同一地址不可能同时在 L1 和 L2 中出现。

\subsubsection{Cache 控制器}

Cache 控制器负责管理 Cache 缓存，它对于应用程序来说几乎是透明的。
它自动的将内存中的代码或数据写入到 Cache 中。
它从处理器核处获取内存读写请求并且执行必要的 Cache 缓存或外部内存操作。

它收到处理核的请求命令后，首先检查该请求地址是否在 Cache 中，这个步骤称为 \textit{cache look-up}。
它将请求中的部分地址位与 Cache line 对应的 tag 进行比对来完成 \textit{cache look-up} 操作。
如果上述对比成功，那么说明 Cache 中存在匹配 line，称为命中（hit），并且控制器将该行标注为有效（valid），从而使用 Cache 缓存作为对写请求的数据来源。

当读写请求无法从 Cache 中找到匹配的 tag，或者 tag 是无效的，那么即产生 Cache 未命中（miss）。
此时，请求必须传给下一级内存层级 L2 Cache，或外部内存。
这将产生一个 cache line 填充（cahe linefill），即将内存中的数据拷贝到 cache 中。
请求的数据或指令流也会同时发送给处理核。
该过程对于软件开发人员是透明的，是不直接可见的。
处理核不用等到 cache line 填充完数据才能使用。
Cache 控制器通常先从 cache line 中获取关键字（\textit{critical word}）。
例如，当执行一个加载指令而发生 cahce miss 并产生一个 cache linefill 时，CPU 核先从 cache line 中获取部分请求的数据。
这部分关键数据先提供给 CPU 核的流水线（pipeline），然后 Cache 和外部总线接口在后台读取 cache line 中剩余的数据。

\BlockDesc{缓存策略}

Cache 策略简而言之就是，数据 Cache 何时需要申请 line；
存储指令执行时并且数据 Cache 命中后应该发生什么事情。

Cache 的分配机制有以下几种：

\begin{description}
  \item[Write allocation (WA)] 在写未命中时分配 cache line。
    这意味 CPU 执行存储指令时会发生读操作。
    在写操作执行前，cache 会先获取数据填充对应的 cache line。
    即使只是写入一个 byte，Cache 中也会保存一个完整行，因为这是它的最小单元。
  
  \item[Read allocation (RA)] 在读为命中时分配 cache line。
\end{description}

Cache 更新机制有：

\begin{description}
  \item[Write-back (WB)] 写时更新 Cache，并且只会将 cache line 标记为污染（dirty）。
    外部内存只在该行被驱逐出去或明确的清理操作发生时更新。
  
  \item[Write-through (WT)] 写时更新 Cache 和外部内存。
    该机制不会标注 cache line 为污染。
\end{description}

两种更新机制的数据读操作命中时的 Cache 行为相同。

普通内存的可缓存属性分为 \textit{inner} 和 \textit{outer} 属性。
至于这两种属性的范围是\textbf{由实现所决定的}。
一般来说，inner 属性用于集成 Cache（CPU 核内集成的 Cache），outer 属性可在处理器内存总线上供外部 Cache 使用。

\Figure{cacheable-properties-of-memory}

处理器可以预测式的访问普通内存，也就是说处理器可以自动暗中加载数据到 cache 中。
这个行为并不需要开发人员的干涉，也无需指定请求地址。
当然，开发人员也可以暗示处理器哪些数据将被使用。
ARMv8 提供的预加载暗示（hint）指令。
但是 cache 是否支持预测和预加载是由\textbf{实现决定}。
下面的指令是架构提供的：

\begin{description}
  \item[AArch64] \lstinline!PRFM PLDL1KEEP, [Xm, #imm]! 意思是将 \lstinline!Xm + offset! 的数据加载到 L1 缓存中作为临时预取，这意味着数据可能会被使用多次。
  \item[AArch32] \lstinline!PLD Rm! 将数据从 Rm 中的地址预加载到缓存。
\end{description}

A64 预取内存指令更一般的形式：

\begin{lstcode}
  PRFM <prfop>, addr

  Where:

  <prfop>     <type><target><policy> | #uimm5
  <type>      PLD for prefetch for load
              PST for prefetch for store
  <target>    L1 for L1 cache, L2 for L2 cache, L3 for L3 cache
  <policy>    KEEP for retain or temporal prefetch means allocate in cache
              normally
              STRM for streaming or non-temporal prefetch means the memory
              is used only once
  uimm5       Represents the hint encodings as a 5-bit immediate.
              These are optional.
\end{lstcode}

\BlockDesc{POC 和 POU}

对于基于 set 和基于 way 的 cache 清理和 invalidate 来说，操作是施加到指定 cache 级上的。
对于使用虚拟地址的操作，该架构定义两个观察点。

\begin{description}
  \item[\textit{Point of Coherency} (PoC)] 对于一个特定的地址，PoC 是所有观察者的点，例如，处理器、DSP 或 DMA 引擎等可以访问内存的单元，这些单元都确保可以在一个内存地址下看到同样的数据。
    通常这个观察点为外部内存。
  \item[\textit{Point of Unification} (POU)] PoU 是指令和数据 Cache 和 TLB 在内存地址可以看到的相同数据。
    例如，L2 Cache 即为 Harvard 架构的一级 Cache 和 TLB 可见的相同点。
    如果没有 L2 等外部 cache，那么内存则为 PoU。
\end{description}

了解 PoU 可以确保在取指修改后的代码时的正确性。
可以通过以下两个阶段的来处理：

\begin{itemize}
  \item 通过地址来清理相关的数据 cache 条目。
  \item 通过地址来无效指令 cache 条目。
\end{itemize}

即使对于共享内存地址来说，ARM 架构也不需要硬件来确保指令 cache 和内存的一致性。

\BlockDesc{Cache 维护}

有时在软件中清除和无效 cache 是必要的。
在外部内存已经发生改变这种操作可能就是必要的，并且这时需要从 cache 中把陈旧的数据移除掉。
在 MMU 相关的活动后也有必要进行上述的 cache 操作，比如：改变内存访问权限、cache 策略或虚拟地址到物理地址的映射，或者诸如 JIT 和动态库加载产生动态代码时必须要进行指令和数据 cache 同步。

\begin{itemize}
  \item 无效 cache 或 cache line 意味着清除它的数据，即清除 cache line 中的有效位。
    \textbf{初始化后必须要无效 cache，因为此时数据是未定义的。}
    这也可以被看作是一种使缓存外的内存域中的更改对缓存的使用者可见的方式。
  \item 清理缓存或缓存行意味着将标记为污染的数据写入到下一级缓存或主内存中，并清除缓存行中的污染位。
    这使得缓存行的内容与下一级缓存或内存系统保持一致。
    这仅适用于使用写回策略的数据缓存。
    这也是使缓存中的更改对外部内存域的用户可见的一种方式，但仅适用于数据缓存。
  \item 清零。
    这会在缓存内将一块内存清零，而无需先从外部域读取其内容，仅适用于数据缓存。
\end{itemize}

您可以选择哪些条目需要应用于这些操作：

\begin{description}
  \item[All] 指整个缓存，不适用于数据缓存或统一缓存。
  \item[\textit{Modified Virtual Address} (MVA)] 是虚拟地址 (VA) 的另一种名称，是指包含特定虚拟地址的缓存行。
  \item[Set or Way] 指通过其在缓存结构中的位置选定的特定缓存行。
\end{description}

AArch64 缓存维护操作使用具有以下一般形式的指令执行：

\lstinline!<cache> <operation>{, <Xt>}!

有多种操作可用。

\begin{ltblr}[caption={数据、指令和统一缓存的操作}, label={tbl:diu-cache-ops}]
  {colspec={cc>{\centering\arraybackslash}Xc}}
  \hline[1pt]
  Cache & 操作 & 描述 & AArch32 等效\\
  \hline
     & CISW & Clean and invalidate by Set/Way & DCCISW \\ 
     & CIVAC & Clean and Invalidate by Virtual Address to Point of Coherency & DCCIMVAC \\
     & CSW & Clean by Set/Way & DCCSW \\
  DC & CVAC & Clean by Virtual Address to Point of Coherency & DCCMVAC \\
     & CVAU & Clean by Virtual Address to Point of Unification & DCCMVAU \\
     & ISW & Invalidate by Set/Way & DCISW \\
     & IVAC & Invalidate by Virtual Address, to Point of Coherency & DCIMVAC \\
  \hline
  DC &  ZVA & Cache zero by Virtual Address & - \\
  \hline
     & IALLUIS & Invalidate all, to Point of Unification, Inner Sharable & ICIALLUIS \\
  IC & IALLU & Invalidate all, to Point of Unification, Inner Shareable & ICIALLU \\
     & IVAU & Invalidate by Virtual Address to Point of Unification & ICIMVAU \\
  \hline[1pt]
\end{ltblr}

那些接受地址参数的指令使用一个 64 位寄存器，该寄存器保存要维护的虚拟地址。
该地址没有对齐限制。
接受组 / 路 / 级别参数的指令，使用一个 64 位寄存器，其低 32 位遵循 ARMv7 架构中描述的格式。
AArch64 数据缓存失效指令，\lstinline!DC IVAC!，需要写入权限，否则会生成权限故障。

所有指令缓存维护指令可以以任何顺序执行，相对于其他指令缓存维护指令、数据缓存维护指令和加载存储指令，除非在指令之间执行了 DSB。

除了 \lstinline!DC ZVA! 之外的数据缓存操作，如果它们指定了一个地址，只有在它们指定相同地址时，才保证按程序顺序执行。
指定地址的那些操作，相对于不指定地址的所有维护操作，按程序顺序执行。

考虑以下代码。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={对于 PoU 的 cache 无效和清理操作},
  label={lst:cache-ic-pou}
]
IC IVAU, X0  // Instruction Cache Invalidate by address to Point of Unification
DC CVAC, X0  // Data Cache Clean by address to Point of Coherency
IC IVAU, X1  // Might be out of order relative to the previous operations if
             // x0 and x1 differ
\end{lstlisting}

前两条指令按顺序执行，因为它们引用相同的地址。
然而，最后一条指令可能相对于前面的操作重新排序，因为它引用了不同的地址。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={对于 PoU 的 cache 无效操作},
  label={lst:cache-i-pou}
]
IC IVAU, X0  // I cache Invalidate by address to Point of Unification
IC IALLU     // I cache Invalidate All to Point of Unification
             // Operations execute in order
\end{lstlisting}

这仅适用于发出指令。
只有在执行 DSB 指令后才能确保完成。

在 ARMv8-A 中，使用 \lstinline!DC ZVA! 指令预加载数据缓存的零值是一项新功能。
处理器的运行速度通常显著快于外部内存系统，有时从内存加载缓存行可能需要很长时间。

缓存行清零的行为类似于预取，它是一种提示处理器未来可能会使用某些地址的方式。
然而，清零操作可能会更快，因为不需要等待外部内存访问完成。
与从内存读取实际数据到缓存不同，您会得到填充了零的缓存行。
它可以提示处理器，代码完全覆盖了缓存行的内容，因此不需要初始读取。

考虑这样一种情况：您需要一个大的临时存储缓冲区，或者正在初始化一个新的结构。
您可以让代码直接开始使用内存，或者在使用之前预取它。
两者都会消耗大量的周期和内存带宽来读取初始内容到缓存中。
通过使用缓存清零选项，您可能可以节省这种浪费的带宽，并且让代码执行得更快。

缓存维护指令执行的时机可以根据指令是通过虚拟地址 (VA) 还是通过组 / 路 (Set/Way) 操作而定。

您可以选择作用域，可以是 PoC 或 PoU，对于可以广播的操作，您可以选择共享性。

以下示例代码展示了一种通用机制，用于将整个数据缓存或统一缓存清理（对于 PoC）。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={对于 PoU 的 cache 无效操作},
  label={lst:cache-i-pou}
]
       MRS X0, CLIDR_EL1
       AND W3, W0, #0x07000000  // Get 2 x Level of Coherence
       LSR W3, W3, #23
       CBZ W3, Finished
       MOV W10, #0              // W10 = 2 x cache level
       MOV W8, #1               // W8 = constant 0b1
Loop1: ADD W2, W10, W10, LSR #1 // Calculate 3 x cache level
       LSR W1, W0, W2           // extract 3-bit cache type for this level
       AND W1, W1, #0x7
       CMP W1, #2
       B.LT Skip                // No data or unified cache at this level
       MSR CSSELR_EL1, X10      // Select this cache level
       ISB                      // Synchronize change of CSSELR
       MRS X1, CCSIDR_EL1       // Read CCSIDR
       AND W2, W1, #7           // W2 = log2(linelen)-4
       ADD W2, W2, #4           // W2 = log2(linelen)
       UBFX W4, W1, #3, #10     // W4 = max way number, right aligned
       CLZ W5, W4               /* W5 = 32-log2(ways), bit position of way in DC operand */
       LSL W9, W4, W5           /* W9 = max way number, aligned to position in DC operand */
       LSL W16, W8, W5          // W16 = amount to decrement way number per iteration
Loop2: UBFX W7, W1, #13, #15    // W7 = max set number, right aligned
       LSL W7, W7, W2           /* W7 = max set number, aligned to position in DC operand */
       LSL W17, W8, W2          // W17 = amount to decrement set number per iteration
       Loop3: ORR W11, W10, W9  // W11 = combine way number and cache number...
       ORR W11, W11, W7         // ... and set number for DC operand
       DC CSW, X11              // Do data cache clean by set and way
       SUBS W7, W7, W17         // Decrement set number
       B.GE Loop3
       SUBS X9, X9, X16         // Decrement way number
       B.GE Loop2
Skip: ADD W10, W10, #2          // Increment 2 x cache level
       CMP W3, W10
       DSB                      /* Ensure completion of previous cache maintenance operation */
       B.GT Loop1
\end{lstlisting}

一些需要注意的要点：

\begin{itemize}
  \item 在正常情况下，清理或使整个缓存失效是固件应该执行的任务之一，作为核心上电或关机代码序列的一部分。
  这可能需要相当长的时间，因为 L2 缓存中的行数可能相当多，需要逐个遍历它们。

    因此，这种清理绝对是为特殊场合准备的！
  \item 缓存维护操作，如 \lstinline!DC CSW!，在上述节中有描述。
  \item 在代码序列开始时必须禁用缓存，以防止在序列中段分配新行。
  如果缓存是排它性的，行可能会在级别之间迁移。
  \item 在 SMP 系统中，另一个核心可能会在序列中段从缓存中获取脏缓存行，阻止它们到达 PoC。
  Cortex-A53 和 Cortex-A7 处理器都可以做到这一点。
  \item 如果存在 EL3，则必须从安全世界使缓存失效，因为某些条目可能是“安全脏”数据，不能从普通世界使其失效。
  如果不处理，“安全脏”数据在被驱逐时可能会破坏内存系统，因为在安全世界或普通世界中进行正常缓存使用。
\end{itemize}

如果软件需要在指令执行和内存之间保持一致性，它必须使用 ISB 和 DSB 内存屏障以及缓存维护指令来管理这种一致性。
下面的代码序列可用于此目的。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={对于 PoU 的 cache 无效操作},
  label={lst:cache-i-pou}
]
/* Coherency example for data and instruction accesses within the same Inner
Shareable domain. Enter this code with <Wt> containing a new 32-bit instruction,
to be held in Cacheable space at a location pointed to by Xn. */
STR Wt, [Xn]
DC CVAU, Xn // Clean data cache by VA to point of unification (PoU)
DSB ISH     // Ensure visibility of the data cleaned from cache
IC IVAU, Xn // Invalidate instruction cache by VA to PoU
DSB ISH     // Ensure completion of the invalidations
ISB         // Synchronize the fetched instruction stream
\end{lstlisting}

这个代码序列仅适用于适合单个 I 或 D 缓存行的指令序列。

该代码根据给定的起始基地址（存储在寄存器 x0 中）和长度（存储在寄存器 x1 中），对指定区域的数据和指令缓存进行虚拟地址清理和失效操作。

\begin{lstlisting}[
  language={[ARM]Assembler},
  caption={对于 PoU 的 cache 无效操作},
  label={lst:cache-i-pou}
]

//
// X0 = base address
// X1 = length (we assume the length is not 0)
//

// Calculate end of the region
ADD x1, x1, x0  // Base Address + Length
//
// Clean the data cache by MVA
//
MRS X2, CTR_EL0 // Read Cache Type Register

// Get the minimun data cache line
//

UBFX X4, X2, #16, #4 // Extract DminLine (log2 of the cache line)
MOV X3, #4           // Dminline iss the number of words (4 bytes)
LSL X3, X3, X4       // X3 should contain the cache line
SUB X4, X3, #1       // get the mask for the cache line

BIC X4, X0, X4       // Aligned the base address of the region
clean data cache:
DC CVAU, X4          // Clean data cache line by VA to PoU
ADD X4, X4, X3       // Next cache line
CMP X4, X1           // Is X4 (current cache line) smaller than the end
                     // of the region
B.LT clean_data_cache // while (address < end_address)

DSB ISH              // Ensure visibility of the data cleaned from cache

//
//Clean the instruction cache by VA
//
// Get the minimum instruction cache line (X2 contains ctr_el0)
AND X2, X2, #0xF  // Extract IminLine (log2 of the cache line)
MOV X3, #4        // IminLine is the number of words (4 bytes)
LSL X3, X3, X2    // X3 should contain the cache line
SUB x4, x3, #1    // Get the mask for the cache line

BIC X4, X0, X4    // Aligned the base address of the region
clean_instruction_cache:
IC IVAU, X4       // Clean instruction cache line by VA to PoU
ADD X4, X4, X3    // Next cache line
CMP X4, X1        // Is X4 (current cache line) smaller than the end
                  // of the region
B.LT clean_instruction_cache // while (address < end_address)

DSB ISB           // Ensure completion of the invalidations
ISH               // Synchronize the fetched instruction stream
\end{lstlisting}

\BlockDesc{Cache 探测}

缓存维护操作可以通过缓存集、路或虚拟地址进行。
与平台无关的代码可能需要了解缓存的大小、缓存行的大小、集合和路的数量，以及系统中有多少级缓存。
这种需求最有可能出现在后重置的缓存失效和清零操作中。
在架构缓存上的所有其他操作很可能是基于 PoC 或 PoU 进行的。

有一些系统控制寄存器包含了这些信息：

\begin{itemize}
  \item 软件可以通过读取缓存级别 ID 寄存器（\lstinline!CLIDR_EL1!）来确定存在的缓存级别数量。
  \item Cache line 大小可以在缓存类型寄存器中获取（\lstinline!CTR_EL0!）。
  \item 如果需要由在执行级别 EL0 运行的用户代码访问，可以通过设置系统控制寄存器（\lstinline!SCTLR/SCTLR_EL1!）的 UCT 位来实现。
\end{itemize}

要确定缓存中的集合数量（set）和路数（way），需要对两个单独的寄存器进行异常级别的访问。

\begin{enumerate}
  \item 代码必须首先写入缓存大小选择寄存器（\lstinline!CSSELR_EL1!），以选择要获取信息的缓存。
  \item 然后，代码读取缓存大小 ID 寄存器（\lstinline!CCSIDR/CCSIDR_EL1!）。
  \item 数据缓存零 ID 寄存器（\lstinline!DCZID_EL0!）包含用于零操作的块大小。
  \item \lstinline!SCTLR/SCTLR_EL1! 中的 \lstinline![DZE]! 位和 Hypervisor Configuration Register (\lstinline!HCR/HCR_EL2!) 中的\lstinline![TDZ]!位控制哪些执行级别和哪些世界可以访问 \lstinline!DCZID_EL0!。
    \lstinline!CLIDR_EL1!、\lstinline!CSSELR_EL1! 和 \lstinline!CCSIDR_EL1! 只能通过特权代码访问，即在 AArch32 中为 PL1 或更高级别，在 AArch64 中为 EL1 或更高级别。
  \item 如果在异常级别上禁止执行通过虚拟地址进行数据缓存零操作（\lstinline!DC ZVA!）指令，例如通过 \lstinline!SCTLR_EL1.DZE! 位控制 EL0 级别，或通过 \lstinline!HCR_EL2.TDZ! 位控制 EL1 和 EL0 级别的非安全执行，则读取此寄存器会返回一个指示不支持该指令的值。

  \item \lstinline!CLIDR! 寄存器只知道集成到处理器本身中的缓存有多少级。
  它无法提供关于外部内存系统中的任何缓存的信息。

    例如，如果仅集成了 L1 和 L2，则 \lstinline!CLIDR/CLIDR_EL1! 标识了两个级别的缓存，处理器不知道任何外部 L3 缓存。

    在执行缓存维护操作或维护与集成缓存的一致性的代码时，可能需要考虑非集成缓存。
\end{enumerate}

\Figure[width=0.2]{cache-discovery}

此外，在 big.LITTLE 系统中，描述的缓存层次结构可能会因核心而异，例如，Cortex-A53 和 Cortex-A57 处理器具有不同的 \lstinline!CTR.L1IP! 字段。

\subsection{MMU}

内存管理单元（MMU）的一个重要功能是使系统能够运行多个任务，作为在它们自己的私有虚拟内存空间中运行的独立程序。
它们不需要知道系统的物理内存映射，即硬件实际使用的地址，也不需要知道可能同时执行的其他程序。

\Figure[width=0.8]{mmu}

您可以为每个程序使用相同的虚拟内存地址空间。
即使物理内存是分散的，您也可以使用连续的虚拟内存映射。
这个虚拟地址空间与系统中实际的物理内存映射是分开的。
您可以编写、编译和链接应用程序以在虚拟内存空间中运行。

下图展示了一个示例系统，即内存的虚拟视图和物理视图。
在单个系统中的不同处理器和设备可能具有不同的虚拟和物理地址映射。
操作系统将 MMU 编程以在这两种内存视图之间进行转换。

\Figure[width=0.8]{virt-phys-mem}

为了实现这一点，在虚拟内存系统中，硬件必须提供地址转换，即将处理器发出的虚拟地址转换为主存储器中的物理地址。

虚拟地址是由您、编译器和链接器在将代码放置到内存中时使用的地址。
物理地址是实际硬件系统使用的地址。

MMU 使用虚拟地址的最高有效位来索引翻译表中的条目，并确定正在访问哪个块。
MMU 将代码和数据的虚拟地址转换为实际系统中的物理地址。
这种转换是在硬件中自动进行的，并且对应用程序是透明的。
除了地址转换外，MMU 还控制每个内存区域的内存访问权限、内存排序和缓存策略。

\Figure[width=0.8]{address-translation-with-tb}

MMU 使得任务或应用程序可以编写为不需要了解系统的物理内存映射或可能同时运行的其他程序。
这使得您可以为每个程序使用相同的虚拟内存地址空间。

它还使您可以在物理内存是分散的情况下使用连续的虚拟内存映射。
这个虚拟地址空间与系统中实际的物理内存映射是分开的。
应用程序被编写、编译和链接以在虚拟内存空间中运行。

\BlockDesc{TLB}



\begin{Tcbox}[title={扩展}]
\textbf{TLB thrashing}

  TLB 抖动可能会发生在工作集页数太多，而翻译后备缓冲（TLB）作为内存管理单元（MMU）的缓存，用于将虚拟地址翻译为物理地址的大小太小的情况下。
  即使指令缓存或数据缓存没有抖动，TLB 抖动也可能发生，因为它们的缓存大小不同。
  指令和数据被缓存在小块（缓存行）中，而不是整个页面，但地址查找是在页面级别进行的。
  因此，即使代码和数据工作集适合缓存，如果工作集在许多页面中分散，虚拟地址工作集可能不适合 TLB，导致 TLB 抖动。

  更多关于 thrashing 的概念可以参考\href{https://en.wikipedia.org/wiki/Thrashing_(computer_science)}{维基百科}。
\end{Tcbox}

\subsection{Memory ordering} \label{sec:memory-ordering}

\subsection{SMP}

\subsection{Others}

\section{RISC-V}

\subsection{Privileged Architecture}

\subsection{Unprivileged ISA}

\section{内存层级}

\section{每个程序员都应该知道的内存知识}

关于内存相关的知识，强烈建议阅读
\href{https://people.freebsd.org/~lstewart/articles/cpumemory.pdf}{What Every Programmer Should Know About Memory}。


% nvim: set ts=2 sts=2 sw=2 et:
